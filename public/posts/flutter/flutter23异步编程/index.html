<!DOCTYPE HTML>

<html><head>
    <title>LM</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
    <link rel="icon" href="/images/Infinite.png" type="image/x-icon">
    <link rel="stylesheet" href="/assets/css/main.css"/>
</head><body class="is-preload" id="top">
        

        <div id="wrapper">
<header id="header">
    <h1><a href="/" style="font-size: 1.2em">LM' s Note</a></h1>
    <nav class="links">
        <ul>
            <li><a href="/posts" style="font-size: 0.9em"><strong>Posts</strong></a></li>
        </ul>
    </nav>
    <nav class="main">
        <ul>
            <li class="search">
                <a class="fa-search" href="#search">Search</a>
                <form id="search" action="/404.html">
                    <input type="text" name="query" placeholder="请输入关键字"/>
                </form>
            </li>
            <li class="menu">
                
                <a href="/posts" class="fa-bars">Post</a>
            </li>
        </ul>
    </nav>
</header>
            
<div id="main">
    <header>
            <div class="title">
                <h2 style="font-size:2em"><a href="javascript:void(0)">Flutter(23)——异步编程</a></h2>
                <p>@LM | 2021-08-25</p>
            </div>
        </header>
        <div class="content">
            <blockquote>
<p>参考原文：<a href="https://www.jianshu.com/p/0aefa62372c6">Flutter 异步编程：Future、Isolate 和事件循环</a></p>
</blockquote>
<h2 id="1dart-是一种单线程语言">1.Dart 是一种单线程语言</h2>
<p>Dart 是一种单线程语言，意味着同一时刻程序只能执行一个操作，其他操作在这个操作完成后执行，只要这个操作还在执行，它就不会被其他 Dart 代码中断。依赖于 Dart 的 Flutter 也是如此。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-dart" data-lang="dart"><span style="color:#66d9ef">void</span> myBigLoop(){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1000000</span>; i<span style="color:#f92672">++</span>){
        _doSomethingSynchronously();
    }
}
</code></pre></div><p>在上述例子中，<code>myBigLoop()</code> 方法在执行完成前永远不会被中断，在整个方法执行期间应用将会被阻塞。</p>
<h2 id="2运行模型">2.运行模型</h2>
<p>在这里需要关注的是 Dart 的代码序列器（事件循环）。</p>
<p>当你启动一个 Flutter 或 Dart 应用时，应用将创建并启动一个新的线程进程 Isolate，这个线程将是整个应用的主线程。</p>
<p>在主线程启动后，应用会在此初始化 2 个 FIFO（先进先出）队列，<code>MicroTask</code>和 <code>Event</code>队列，在上述操作执行完成后，才会执行<code>main()</code>方法，并启动事件循环。</p>
<p>事件循环是一种由一个内部时钟控制的无限循环，在每个时钟周期内，如果没有其他 Dart 代码执行，则执行以下操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-dart" data-lang="dart"><span style="color:#66d9ef">void</span> eventLoop(){
    <span style="color:#66d9ef">while</span> (microTaskQueue.isNotEmpty){
        fetchFirstMicroTaskFromQueue();
        executeThisMicroTask();
        <span style="color:#66d9ef">return</span>;
    }

    <span style="color:#66d9ef">if</span> (eventQueue.isNotEmpty){
        fetchFirstEventFromQueue();
        executeThisEventRelatedCode();
    }
}
</code></pre></div><p>可以注意到，这个操作的作用是从<code>MicroTask</code>和 <code>Event</code>队列提取出事件到循环中执行，直到两个队列中所有事件执行完成。</p>
<h3 id="microtask-队列">MicroTask 队列</h3>
<p><code>MicroTask</code>队列用于非常简短且需要异步执行的内部动作，这些动作需要在其他事件完成之后并在将执行权送还给<code>Event</code>队列之前运行。</p>
<h3 id="event-队列">Event 队列</h3>
<p>大多数需要使用异步的动作都使用<code>Event</code>队列进行处理，如外部事件 I/O，绘图等。值得注意的是，Future 操作也通过<code>Event</code>队列处理。</p>
<h2 id="3future">3.Future</h2>
<p>Future 是一个异步执行并且在未来的某一个时刻完成（或失败）的任务。Future 并非并行执行，而是遵循事件循环处理事件的顺序规则执行。当你实例化一个 Future 时，应用会执行以下操作：</p>
<ul>
<li>该 Future 的一个实例被创建并记录在由 Dart 管理的内部数组中；</li>
<li>需要由此 Future 执行的代码直接推送到 Event 队列中去；</li>
<li>该 Future 实例会返回一个状态（= incomplete）；</li>
<li>如果存在下一个同步代码，执行它（非 Future 的执行代码）;</li>
</ul>
<p>只要事件循环从 Event 循环中获取它，被 Future 引用的代码将像其他任何 Event 一样执行。当该代码将被执行并将完成（或失败）时，<code>then()</code> 或 <code>catchError()</code> 方法将直接被触发。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-dart" data-lang="dart"><span style="color:#66d9ef">void</span> main(){
    print(<span style="color:#e6db74">&#39;Before the Future&#39;</span>);
    Future((){
        print(<span style="color:#e6db74">&#39;Running the Future&#39;</span>);
    }).then((_){
        print(<span style="color:#e6db74">&#39;Future is complete&#39;</span>);
    });
    print(<span style="color:#e6db74">&#39;After the Future&#39;</span>);
}
</code></pre></div><p>上述代码执行输出</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">Before the Future
After the Future
Running the Future
Future is complete
</code></pre></div><p>应用的执行执行流程如下：</p>
<ol>
<li><code>print(&quot;Before the Future&quot;)</code></li>
<li>将 <code>(){print(&quot;Running the Future&quot;);}</code> 添加到 <code>Event</code> 队列；</li>
<li><code>print(&quot;After the Future&quot;)</code></li>
<li>事件循环获取（在第二步引用的）代码并执行它</li>
<li>当代码执行时，它会查找 <code>then()</code> 语句并执行它</li>
</ol>
<h2 id="4async">4.Async</h2>
<p>当你使用 async 关键字作为方法声明的后缀时，Dart 会将其理解为：</p>
<ul>
<li>该方法的返回值是一个 Future；</li>
<li>它同步执行该方法的代码直到第一个 await 关键字，然后它暂停该方法其他部分的执行；</li>
<li>一旦由 await 关键字引用的 Future 执行完成，下一行代码将立即执行。</li>
</ul>
<p>这是 Dart 异步代码的同步实现。注意到的是，async 并非并行执行，也是遵循事件循环处理事件的顺序规则执行。</p>
<h2 id="5多线程伪">5.多线程（伪）</h2>
<p>如何在 Flutter 中如何并行运行代码，这里我们可以使用 Isolate。</p>
<h3 id="isolate-是什么">Isolate 是什么？</h3>
<p>Isolate 是 Dart 中的 线程。然而，它与常规「线程」的实现存在较大差异，Isolate 在 Flutter 中并不共享内存，不同 Isolate 之间通过消息进行通信，实际上 Isolate 更新进程。</p>
<h3 id="每个-isolate-都有自己的事件循环">每个 Isolate 都有自己的事件循环</h3>
<p>每个 Isolate 都拥有自己的事件循环及队列。这意味着在一个 Isolate 中运行的代码与另外一个 Isolate 不会存在任何关联。</p>
<h3 id="启动-isolate">启动 Isolate</h3>
<h4 id="创建并握手">创建并握手</h4>
<p>由于Isolate 不共享任何内存并通过消息进行交互，因此，我们需要在调用者与 isolate 间建立通信。每个 Isolate 都暴露一个将消息传递给 Isolate 的被称为 SendPort 的端口，调用者和 isolate 需要互相知道彼此的端口才能进行通信。需要注意的是约束 isolate 的入口必须是顶级函数或静态方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-dart" data-lang="dart"><span style="color:#75715e">// 新的 isolate 端口
</span><span style="color:#75715e">// 该端口将在未来使用
</span><span style="color:#75715e">// 用来给 isolate 发送消息
</span><span style="color:#75715e"></span>SendPort newIsolateSendPort;
<span style="color:#75715e">// 新 Isolate 实例
</span><span style="color:#75715e"></span>Isolate newIsolate;

<span style="color:#75715e">// 启动一个新的 isolate
</span><span style="color:#75715e">// 然后开始第一次握手
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> callerCreateIsolate() <span style="color:#66d9ef">async</span> {
    <span style="color:#75715e">// 本地临时 ReceivePort
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 用于检索新的 isolate 的 SendPort
</span><span style="color:#75715e"></span>    ReceivePort receivePort <span style="color:#f92672">=</span> ReceivePort();

    <span style="color:#75715e">// 初始化新的 isolate
</span><span style="color:#75715e"></span>    newIsolate <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> Isolate.spawn(
        callbackFunction,
        receivePort.sendPort,
    );

    <span style="color:#75715e">// 检索要用于进一步通信的端口
</span><span style="color:#75715e"></span>    newIsolateSendPort <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> receivePort.first;
}

<span style="color:#75715e">// 新 isolate 的入口
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> callbackFunction(SendPort callerSendPort){
    <span style="color:#75715e">// 一个 SendPort 实例，用来接收来自调用者的消息
</span><span style="color:#75715e"></span>    ReceivePort newIsolateReceivePort <span style="color:#f92672">=</span> ReceivePort();

    <span style="color:#75715e">// 向调用者提供此 isolate 的 SendPort 引用
</span><span style="color:#75715e"></span>    callerSendPort.send(newIsolateReceivePort.sendPort);

    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 进一步流程
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>}
</code></pre></div><h4 id="向-isolate-提交消息">向 Isolate 提交消息</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-dart" data-lang="dart"><span style="color:#75715e">// 向新 isolate 发送消息并接收回复的方法
</span><span style="color:#75715e">// 在该例中，我将使用字符串进行通信操作
</span><span style="color:#75715e">// （发送和接收的数据）
</span><span style="color:#75715e"></span>Future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">String</span><span style="color:#f92672">&gt;</span> sendReceive(<span style="color:#66d9ef">String</span> messageToBeSent) <span style="color:#66d9ef">async</span> {
    <span style="color:#75715e">// 创建一个临时端口来接收回复
</span><span style="color:#75715e"></span>    ReceivePort port <span style="color:#f92672">=</span> ReceivePort();

    <span style="color:#75715e">// 发送消息到 Isolate，并且
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 通知该 isolate 哪个端口是用来提供回复的
</span><span style="color:#75715e"></span>    newIsolateSendPort.send(
        CrossIsolatesMessage<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">String</span><span style="color:#f92672">&gt;</span>(
            sender: port.sendPort,
            message: messageToBeSent,
        )
    );

    <span style="color:#75715e">// 等待回复并返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> port.first;
}

<span style="color:#75715e">// 扩展回调函数来处理接输入报文
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> callbackFunction(SendPort callerSendPort){
    <span style="color:#75715e">// 初始化一个 SendPort 来接收来自调用者的消息
</span><span style="color:#75715e"></span>    ReceivePort newIsolateReceivePort <span style="color:#f92672">=</span> ReceivePort();

    <span style="color:#75715e">// 向调用者提供该 isolate 的 SendPort 引用
</span><span style="color:#75715e"></span>    callerSendPort.send(newIsolateReceivePort.sendPort);

    <span style="color:#75715e">// 监听输入报文、处理并提供回复的
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Isolate 主程序
</span><span style="color:#75715e"></span>    newIsolateReceivePort.listen((<span style="color:#66d9ef">dynamic</span> message){
        CrossIsolatesMessage incomingMessage <span style="color:#f92672">=</span> message <span style="color:#f92672">as</span> CrossIsolatesMessage;

        <span style="color:#75715e">// 处理消息
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">String</span> newMessage <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;complemented string &#34;</span> <span style="color:#f92672">+</span> incomingMessage.message;

        <span style="color:#75715e">// 发送处理的结果
</span><span style="color:#75715e"></span>        incomingMessage.sender.send(newMessage);
    });
}

<span style="color:#75715e">// 帮助类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CrossIsolatesMessage</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">final</span> SendPort sender;
    <span style="color:#66d9ef">final</span> T message;

    CrossIsolatesMessage({
        <span style="color:#960050;background-color:#1e0010">@</span>required <span style="color:#66d9ef">this</span>.sender,
        <span style="color:#66d9ef">this</span>.message,
    });
}
</code></pre></div><h4 id="销毁这个新的-isolate-实例">销毁这个新的 Isolate 实例</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-dart" data-lang="dart"><span style="color:#75715e">// 释放一个 isolate 的例程
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> dispose(){
    newIsolate<span style="color:#f92672">?</span>.kill(priority: Isolate.immediate);
    newIsolate <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
}
</code></pre></div><h4 id="简单示例">简单示例</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-dart" data-lang="dart"><span style="color:#75715e">//请求的目的端口
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> SendPort server_TargetPort <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;

<span style="color:#75715e">//客户端发起连接,拿到服务端的消息接收端口
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> Connect() <span style="color:#66d9ef">async</span>
{
    ReceivePort client_receivePort <span style="color:#f92672">=</span> ReceivePort();
    <span style="color:#75715e">//client_receivePort.sendPort 是指client_receivePort用于接收消息的端口
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">await</span> Isolate.spawn(Server_onReceivedMsg, [client_receivePort.sendPort,<span style="color:#e6db74">&#34;hello world&#34;</span>]);
   <span style="color:#75715e">//自行设计的约定，第一个消息为服务端消息接收端口
</span><span style="color:#75715e"></span>    server_TargetPort <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> client_receivePort.first;
}
<span style="color:#75715e">//发送消息
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> SendToServer(<span style="color:#66d9ef">String</span> msg)
{
    ReceivePort port <span style="color:#f92672">=</span> ReceivePort();
    server_TargetPort.send([port.sendPort,msg])
    <span style="color:#66d9ef">var</span> resp <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> port.first;
    print(resp.toString());
}

<span style="color:#75715e">//服务端接收消息
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> Server_onReceivedMsg(List args) <span style="color:#66d9ef">async</span>
{
	<span style="color:#75715e">//第一个参数为客户端拥用于接收消息的端口
</span><span style="color:#75715e"></span>    SendPort sendPort <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">0</span>];
    <span style="color:#75715e">//第二个参数为&#34;hello world&#34;
</span><span style="color:#75715e"></span>    print(arg[<span style="color:#ae81ff">1</span>].toString());

	<span style="color:#75715e">//创建服务端端口
</span><span style="color:#75715e"></span>    ReceivePort server_receivePort <span style="color:#f92672">=</span> ReceivePort();
    <span style="color:#75715e">//把服务端接收消息的端口发送给客户端
</span><span style="color:#75715e"></span>    sendPort.send(server_receivePort.sendPort);
    
	<span style="color:#75715e">//循环接收消息
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">await</span> <span style="color:#66d9ef">for</span> (List data <span style="color:#66d9ef">in</span> server_receivePort)
    {
        SendPort replayTo <span style="color:#f92672">=</span> data[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">String</span> msg <span style="color:#f92672">=</span> data[<span style="color:#ae81ff">1</span>];
        replayTo.send(<span style="color:#e6db74">&#34;success : &#34;</span> <span style="color:#f92672">+</span> msg);
    }
 }

<span style="color:#66d9ef">void</span> test()
{
	Connect();
	SendToServer(<span style="color:#e6db74">&#34;abc&#34;</span>);
	SendToServer(<span style="color:#e6db74">&#34;efg&#34;</span>);
}
</code></pre></div>
            <p style="margin-top:1em;"></p>
        </div>
        <footer>
            <p class="post-copyright-license" style="margin-top:1em; margin-bottom:1em">
                <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
                                                            rel="noopener" target="_blank"><i
                    class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。
            </p>
        </footer>
    
    <ul class="actions pagination" style="margin-bottom:5px; float:right">
        <li><a href="#top" class="button large">回到顶部</a></li>
        
          <li><a href="https://ac-lm.github.io/posts/flutter/flutter22%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC/" class="button large previous">上一页</a></li>
        
        
    </ul>
</div>


        </div>
<script src="/assets/js/jquery.min.js"></script>
<script src="/assets/js/browser.min.js"></script>
<script src="/assets/js/breakpoints.min.js"></script>
<script src="/assets/js/util.js"></script>
<script src="/assets/js/main.js"></script></body>
</html>
