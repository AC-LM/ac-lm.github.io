<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Django on AC-LM &#39;s blog</title>
    <link>https://ac-lm.github.io/posts/django/</link>
    <description>Recent content in Django on AC-LM &#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 27 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ac-lm.github.io/posts/django/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Django(13)——Django部署</title>
      <link>https://ac-lm.github.io/posts/django/django13django%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django13django%E9%83%A8%E7%BD%B2/</guid>
      <description>1.配置uwsgi  安装：pip install uwsgi 测试：uwsgi --http-socket :80 --file test.py  # test.py def application(env, start_response): start_response(&amp;#39;200 OK&amp;#39;, [(&amp;#39;Content-Type&amp;#39;,&amp;#39;text/html&amp;#39;)]) return [b&amp;#34;Hello World&amp;#34;]  配置文件：uwsgi.ini  [uwsgi] # 使用nginx连接时使用 # socket=0.0.0.0:8000 # 直接做web服务器, python manage.py runserver ip:port http=0.0.0.0:8000 # 路径为 0.0.0.0，表本地，使用127.0.0.1可能会无法从外网访问 # 项目目录 chdir=/home/mayanan/bj18/dailyfresh # 项目中wsgi.py文件的目录，相对于项目目录 wsgi-file=dailyfresh/wsgi.py # 指定启动的工作进程数 processes=4 # 指定工作进程中的线程数 threads=2 master=True # 保存启动后，主进程的pid pidfile=uwsgi.pid # 设置uwsgi后台运行, uwsgi.log保存日志信息 daemonize=uwsgi.log  启动：uwsgi --ini uwsgi.ini，uwsgi 通过 ini 文件启动后会在相同目录下生成一个 pid 文件，包含主进程的进程号 重载：uwsgi --reload uwsgi.</description>
    </item>
    
    <item>
      <title>Django(12)——404文件</title>
      <link>https://ac-lm.github.io/posts/django/django12404%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django12404%E6%96%87%E4%BB%B6/</guid>
      <description>Django的404 Django 能自动的寻找 404文件，在路径错误时自动跳转，需要注意的是，当 DEBUG = True 时，系统不会调用 404 文件。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;404页面找不着了x&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Error:404,页面找不到了&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;{{ request_path }}&amp;lt;/h2&amp;gt; &amp;lt;hr&amp;gt; &amp;lt;p&amp;gt;404页面名字不允许改变，必须为404.html，且必须放到/templates根目录下&amp;lt;/p&amp;gt; &amp;lt;hr&amp;gt; &amp;lt;a&amp;gt;500,400页面也类似&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; </description>
    </item>
    
    <item>
      <title>Django(11)——setting文件</title>
      <link>https://ac-lm.github.io/posts/django/django11setting%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django11setting%E6%96%87%E4%BB%B6/</guid>
      <description>1.setting.py import os BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) #引入os，os包可以对文件进行操作管理 SECRET_KEY = &amp;#39;^#kms19!iawj2b&amp;amp;v3egmynpfwj8^v@2f(_1+jlw+#^vy^pg7oy&amp;#39; #随机生成的密钥 DEBUG = True #代表是调试环境 ALLOWED_HOSTS = [] #允许的主机路径，不填写或者ALLOWED_HOSTS = [“*”]代表允许任意主机域名，如果要指定，在里面输入， #比如域名只允许为 www.baidu.com 那么 ALLOWED_HOSTS = [“www.baidu.com”] INSTALLED_APPS = [ &amp;#39;django.contrib.admin&amp;#39;, &amp;#39;django.contrib.auth&amp;#39;, &amp;#39;django.contrib.contenttypes&amp;#39;, &amp;#39;django.contrib.sessions&amp;#39;, &amp;#39;django.contrib.messages&amp;#39;, &amp;#39;django.contrib.staticfiles&amp;#39;, ] #当前项目应用，只有加入这里才能进行模型同步等操作,注册app等 MIDDLEWARE = [ &amp;#39;django.middleware.security.SecurityMiddleware&amp;#39;, &amp;#39;django.contrib.sessions.middleware.SessionMiddleware&amp;#39;, &amp;#39;django.middleware.common.CommonMiddleware&amp;#39;, &amp;#39;django.middleware.csrf.CsrfViewMiddleware&amp;#39;, &amp;#39;django.contrib.auth.middleware.AuthenticationMiddleware&amp;#39;, &amp;#39;django.contrib.messages.middleware.MessageMiddleware&amp;#39;, &amp;#39;django.middleware.clickjacking.XFrameOptionsMiddleware&amp;#39;, ] #django的中间件,自己写的中间件要在这里填写路径注册,才会生效 ROOT_URLCONF = &amp;#39;untitled.urls&amp;#39; #主路由，也就是项目的主urls(根urls)  TEMPLATES = [ { &amp;#39;BACKEND&amp;#39;: &amp;#39;django.template.backends.django.DjangoTemplates&amp;#39;, &amp;#39;DIRS&amp;#39;: [os.path.join(BASE_DIR, &amp;#39;templates&amp;#39;)] , &amp;#39;APP_DIRS&amp;#39;: True, &amp;#39;OPTIONS&amp;#39;: { &amp;#39;context_processors&amp;#39;: [ &amp;#39;django.</description>
    </item>
    
    <item>
      <title>Django(10)——用户认证模块auth</title>
      <link>https://ac-lm.github.io/posts/django/django10%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%A8%A1%E5%9D%97auth/</link>
      <pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django10%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%A8%A1%E5%9D%97auth/</guid>
      <description>参考原文：Django自带的用户认证auth模块 @Zzbj 
 1.介绍 Django内置了强大的用户认证系统auth，它默认创建并使用auth_user表来存储用户数据。
from django.contrib import auth # 使用auth认证系统 from django.contrib.auth.models import User # auth认证系统默认使用User表 2.auth.authenticate() Django提供简单的用户认证功能，如果认证成功（用户名和密码正确有效），便会返回一个User对象。
from django.contrib import auth user_obj = auth.authenticate(username=username,password=pwd) 3.auth.login(request, user) 该函数实现一个用户登录的功能，它本质上会在后端为该用户生成相关session数据。在使用login(request, user_obj)登录后之后，便可以通过request.user拿到当前登录的用户对象，否则request.user得到的是一个匿名用户对象。
from django.shortcuts import render, HttpResponse, redirect from django.contrib import auth def login(request): if request.method == &amp;#34;POST&amp;#34;: username = request.POST.get(&amp;#39;username&amp;#39;) pwd = request.POST.get(&amp;#39;password&amp;#39;) # 调用auth模块的认证方法，判断用户名和密码是否正确，正确返回一个user_obj user_obj = auth.authenticate(username=username, password=pwd) if user_obj: # 登录成功,设置Session数据 auth.login(request, user_obj) return HttpResponse(&amp;#39;登录成功&amp;#39;) else: return render(request, &amp;#39;login.</description>
    </item>
    
    <item>
      <title>Django(9)——CSRF中间件</title>
      <link>https://ac-lm.github.io/posts/django/django9csrf%E4%B8%AD%E9%97%B4%E4%BB%B6/</link>
      <pubDate>Sun, 25 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django9csrf%E4%B8%AD%E9%97%B4%E4%BB%B6/</guid>
      <description>1.CSRF中间件 CSRF中间件django.middleware.csrf.CsrfViewMiddleware默认在setting.py设置中激活。
在使用 POST 表单的任何模板中，如果表单用于内部 URL，请在元素内使用csrf_token标签，例如&amp;lt;form method=&amp;quot;post&amp;quot;&amp;gt;{% csrf_token %}，对于针对外部 URL 的 POST 表单，不应这样做，因为这将导致 CSRF 令牌被泄露，从而导致漏洞。
2.异步 对于任何 AJAX POST 请求，都需要将 CSRF 令牌作为 POST 数据传递进来，您可以获取这样的令牌。
function getCookie(name) { let cookieValue = null; if (document.cookie &amp;amp;&amp;amp; document.cookie !== &amp;#39;&amp;#39;) { const cookies = document.cookie.split(&amp;#39;;&amp;#39;); for (let i = 0; i &amp;lt; cookies.length; i++) { const cookie = cookies[i].trim(); // Does this cookie string begin with the name we want?  if (cookie.substring(0, name.</description>
    </item>
    
    <item>
      <title>Django(8)——外键查询</title>
      <link>https://ac-lm.github.io/posts/django/django8%E5%A4%96%E9%94%AE%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sat, 24 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django8%E5%A4%96%E9%94%AE%E6%9F%A5%E8%AF%A2/</guid>
      <description>参考原文：Django 外键查询 @尛刀石 
 class Publish(models.Model): id = models.AutoField(primary_key=True, auto_created=True) pname = models.CharField(max_length=40) city = models.CharField(max_length=50) def __str__(self): return self.pname class Author(models.Model): id = models.AutoField(primary_key=True, auto_created=True) aname = models.CharField(max_length=10) def __str__(self): return self.aname class Book(models.Model): id = models.AutoField(primary_key=True, auto_created=True) bname = models.CharField(max_length=30) price = models.IntegerField() publish = models.ForeignKey(Publish, on_delete=models.CASCADE) author = models.ManyToManyField(Author) def __str__(self): return self.bname 1.一对多 a.通过类属性查询 # get方法的到的结果是一个对应类的对象 # 查询某本书的出版社名字 book = Book.objects.get(id=1) book.publish.pname # 查询某出版社下面有多少本书 # 此处的book是Book这张表的表名的小写（必须是小写）加上_set pub = Publish.</description>
    </item>
    
    <item>
      <title>Django(7)——分页的实现</title>
      <link>https://ac-lm.github.io/posts/django/django7%E5%88%86%E9%A1%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django7%E5%88%86%E9%A1%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>1.Paginator 官方示例：view.py from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger from django.shortcuts import render def listing(request): contact_list = Contacts.objects.all() paginator = Paginator(contact_list, 25) # Show 25 contacts per page page = request.GET.get(&amp;#39;page&amp;#39;) try: contacts = paginator.page(page) except PageNotAnInteger: # If page is not an integer, deliver first page. contacts = paginator.page(1) except EmptyPage: # If page is out of range (e.g. 9999), deliver last page of results. contacts = paginator.page(paginator.num_pages) return render(request, &amp;#39;list.</description>
    </item>
    
    <item>
      <title>Django(6)——系统命令</title>
      <link>https://ac-lm.github.io/posts/django/django6%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django6%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</guid>
      <description>pip install django django-admin startproject 项目名称 python manage.py runserver python -m django --version python manage.py runserver 8080 python manage.py runserver 0.0.0.0:8000 python manage.py startapp 应用名称 LANGUAGE_CODE = &amp;#39;zh-hans&amp;#39; TIME_ZONE = &amp;#39;Asia/Shanghai&amp;#39; python manage.py makemigrations 应用名称 #记录改动 python manage.py migrate #创建表 python manage.py createsuperuser </description>
    </item>
    
    <item>
      <title>Django(5)——接口开发</title>
      <link>https://ac-lm.github.io/posts/django/django5%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/</link>
      <pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django5%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/</guid>
      <description>参考链接：Django Web接口开发 @全栈测试开发日记 
 1.在项目文件下urls.py添加接口根路径: #api path(&amp;#39;api/&amp;#39;,include(&amp;#39;django_web.urls&amp;#39;)), # url(r&amp;#39;^api/&amp;#39;,include((&amp;#39;django_web.urls&amp;#39;,&amp;#39;django_web&amp;#39;),namespace=&amp;#39;django_web&amp;#39;)), 2.在app应用django_web下新建urls.py添加具体接口： from django.urls import path from django_web.views import views_api #在django_web下创建urls.py，配置具体接口的二级目录 urlpatterns = [ # guest system interface: # ex : /api/add_event/ path(&amp;#39;add_event/&amp;#39;,views_api.add_event,name=&amp;#39;add_event&amp;#39;), # ex : /api/get_event_list/ path(&amp;#39;get_event_list/&amp;#39;,views_api.get_event_list,name=&amp;#39;get_event_list&amp;#39;), # ex: /api/add_guest/ path(&amp;#39;add_guest/&amp;#39;,views_api.add_guest,name=&amp;#39;add_guest&amp;#39;), # ex: /api/get_guest_list/ path(&amp;#39;get_guest_list/&amp;#39;,views_api.get_guest_list,name=&amp;#39;get_guest_list&amp;#39;), # ex: /api/user_sign/ path(&amp;#39;user_sign/&amp;#39;,views_api.user_sign,name=&amp;#39;user_sign&amp;#39;), ] 3.在创建接口视图函数view_api.py文件，实现具体接口： # -*- coding: utf-8 -*- from django_web.models import Event,Guest from django.http import JsonResponse from django.core.exceptions import ValidationError,ObjectDoesNotExist from django.</description>
    </item>
    
    <item>
      <title>Django(4)——cookie处理</title>
      <link>https://ac-lm.github.io/posts/django/django4cookie%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django4cookie%E5%A4%84%E7%90%86/</guid>
      <description>设置cookie # 编写视图函数，进行设置 from datetime import datetime,timedelta def set_cookie(request): &amp;#34;&amp;#34;&amp;#34;设置cookie&amp;#34;&amp;#34;&amp;#34; response = HttpResponse(&amp;#34;设置cookie&amp;#34;) &amp;#39;&amp;#39;&amp;#39; max_age 设置过期时间，单位是秒 &amp;#39;&amp;#39;&amp;#39; # response.set_cookie(&amp;#39;name&amp;#39;, &amp;#39;tong&amp;#39;, max_age=14 * 24 * 3600) &amp;#39;&amp;#39;&amp;#39; expires 设置过期时间，是从现在的时间开始到那个时间结束 &amp;#39;&amp;#39;&amp;#39; response.set_cookie(&amp;#39;name&amp;#39;, &amp;#39;tong&amp;#39;, expires=datetime.now()+timedelta(days=14)) return response 获取cookie # 视图函数中定义 get_cookie 方法 def get_cookie(request): &amp;#34;&amp;#34;&amp;#34;获取cookie&amp;#34;&amp;#34;&amp;#34; name = request.COOKIES[&amp;#39;name&amp;#39;] return HttpResponse(name) </description>
    </item>
    
    <item>
      <title>Django(3)——设置当前时间</title>
      <link>https://ac-lm.github.io/posts/django/django3%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4/</link>
      <pubDate>Thu, 03 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django3%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4/</guid>
      <description>1.时间字段 在model中，有DateTimeField、DateField和TimeField三种类型可以用来创建日期字段，其值分别对应着datetime()、date()、time()三中对象。
2.属性 DateTimeField.auto_now 这个参数的默认值为false，设置为true时，能够在保存该字段时，将其值设置为当前时间，并且每次修改model，都会自动更新。因此这个参数在需要存储“最后修改时间”的场景下，十分方便。需要注意的是，设置该参数为true时，并不简单地意味着字段的默认值为当前时间，而是指字段会被“强制”更新到当前时间，你无法程序中手动为字段赋值；如果使用django再带的admin管理器，那么该字段在admin中是只读的。
DateTimeField.auto_now_add 这个参数的默认值也为False，设置为True时，会在model对象第一次被创建时，将字段的值设置为创建时的时间，以后修改对象时，字段的值不会再更新。该属性通常被用在存储“创建时间”的场景下。与auto_now类似，auto_now_add也具有强制性，一旦被设置为True，就无法在程序中手动为字段赋值，在admin中字段也会成为只读的。
3.如何将创建时间设置为“默认当前”并且可修改 那么问题来了。实际场景中，往往既希望在对象的创建时间默认被设置为当前值，又希望能在日后修改它。怎么实现这种需求呢？
django中所有的model字段都拥有一个default参数，用来给字段设置默认值。可以用default=timezone.now来替换auto_now=True或auto_now_add=True。timezone.now对应着django.utils.timezone.now()，因此需要写成类似下面的形式：
from django.db import models import django.utils.timezone as timezone class Doc(models.Model): add_date = models.DateTimeField(&amp;#39;保存日期&amp;#39;,default = timezone.now) mod_date = models.DateTimeField(&amp;#39;最后修改日期&amp;#39;, auto_now = True) </description>
    </item>
    
    <item>
      <title>Django(2)——HTML模板</title>
      <link>https://ac-lm.github.io/posts/django/django2html%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django2html%E6%A8%A1%E6%9D%BF/</guid>
      <description>1.遍历字典 在模版中要遍历字典(dict)，一般使用如下代码实现
{% for key,value in param.items %} {{ key }} {{ value }} {% endfor %} </description>
    </item>
    
    <item>
      <title>Django(1)——Models</title>
      <link>https://ac-lm.github.io/posts/django/django1models/</link>
      <pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django1models/</guid>
      <description>模型的基本概念 每个模型都是一个 Python 的类，这些类继承自django.db.models.Model。模型类的每个属性都相当于一个数据库的字段。
from django.db import models class Person(models.Model): first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30) 上述代码相当于使用数据库语言创建一个Person表单，有两个字段 first_name 与 last_name
CREATE TABLE myapp_person ( &amp;#34;id&amp;#34; serial NOT NULL PRIMARY KEY, &amp;#34;first_name&amp;#34; varchar(30) NOT NULL, &amp;#34;last_name&amp;#34; varchar(30) NOT NULL ); 使用模型 定义模型后，需要告诉 Django 你将使用这些模型。通过编辑你的设置文件 setting.py，改变 INSTALLED_APPS 设置来添加包含你的 models.py 的模块的名称来实现这一点。
INSTALLED_APPS = [ #... &amp;#39;myapp&amp;#39;, #模块名 #... ] 字段 字段类型 字段选项  max_length：该参数指定用于存储数据的VARCHAR 数据库字段的大小。 null：如果是True，Django会将空置的值存储为 NULL。默认是False。 blank ：如果是True，这个字段是空白的。默认是False。注意，这与null不同的是，null与数据库相关，而blank则是与验证相关的。如果一个字段有 blank=True ，表单验证就允许输入空值。如果一个字段有blank=False ，则需要字段。 choices：2元组的可迭代，例如，列表或元组的元素选择。 default：字段的默认值。 unique：如果是真的，这个字段必须在整个表中是唯一的。 related_nam：使用外键时调用的名字。  自动主键字段 在默认情况下，Django默认提供了主键字段：id = models.</description>
    </item>
    
  </channel>
</rss>
