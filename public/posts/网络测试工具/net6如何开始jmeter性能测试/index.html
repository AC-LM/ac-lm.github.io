<!DOCTYPE HTML>

<html><head>
    <title>LM</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
    <link rel="icon" href="/images/Infinite.png" type="image/x-icon">
    <link rel="stylesheet" href="/assets/css/main.css"/>
</head><body class="is-preload" id="top">
        

        <div id="wrapper">
<header id="header">
    <h1><a href="/" style="font-size: 1.2em">LM' s Note</a></h1>
    <nav class="links">
        <ul>
            <li><a href="/posts" style="font-size: 0.9em"><strong>Posts</strong></a></li>
        </ul>
    </nav>
    <nav class="main">
        <ul>
            <li class="search">
                <a class="fa-search" href="#search">Search</a>
                <form id="search" method="get" action="#">
                    <input type="text" name="query" placeholder="施工中" disabled="disabled"/>
                </form>
            </li>
            <li class="menu">
                <a class="fa-bars" href="#menu">Menu</a>
            </li>
        </ul>
    </nav>
</header>
<section id="menu">
    
    <section>
        <h2>施工中</h2>
    </section>
</section>
<div id="main">
    <header>
            <div class="title">
                <h2 style="font-size:2em"><a href="javascript:void(0)">Net(6)——如何开始Jmeter性能测试</a></h2>
                <p>@LM | 2020-11-25</p>
            </div>
        </header>
        <div class="content">
            <h2 id="1线程组">1.线程组</h2>
<p>一个性能测试请求负载是基于一个线程组完成的。一个测试计划必须有一个线程组。在测试计划下面多个线程是并行执行的，也就是说这些线程组是同时被初始化并同时执行线程组下的Sampler的。</p>
<p>线程组主要包含三个参数：线程数、准备时长（Ramp-Up Period(in seconds)）、循环次数。</p>
<ul>
<li>线程数：虚拟用户数。一个虚拟用户占用一个进程或线程。设置多少虚拟用户数在这里也就是设置多少个线程数。</li>
<li>准备时长：设置的虚拟用户数需要多长时间全部启动。如果线程数为20 ，准备时长为10 ，那么需要10秒钟启动20个线程。也就是每秒钟启动2个线程。</li>
<li>循环次数：每个线程发送请求的次数。如果线程数为20 ，循环次数为100 ，那么每个线程发送100次请求。总请求数为20*100=2000 。如果勾选了“永远”，那么所有线程会一直发送请求，直到选择停止运行脚本。</li>
</ul>
<h2 id="2调配器">2.调配器</h2>
<p>线程组下还有调配器设置，用于设置脚本执行的开始时间、结束时间、持续时间及启动延迟时间</p>
<ul>
<li>启动时间:测试计划什么时候启动，启动延迟会覆盖它。当启动时间已过，手动运行脚本时也当前时间也会覆盖它(但启动时间页面显示不会变)。</li>
<li>结束时间：测试计划什么时候结束，持续时间会覆盖它。</li>
<li>持续时间（秒）：测试计划持续多长时间，会覆盖结束时间。</li>
<li>启动延迟（秒）：测试计划延迟多长时间启动，会覆盖启动时间</li>
</ul>
<h2 id="3取样器">3.取样器</h2>
<p>添加完成线程组后，在线程组上右键（添加&mdash;&gt;Sampler&mdash;&gt;HTTP请求）选择HTTP请求。取样器（Sampler）是与服务器进行交互的单元。一个取样器通常进行三部分的工作</p>
<ul>
<li>向服务器发送请求</li>
<li>记录服务器的响应数据</li>
<li>记录响应时间信息</li>
</ul>
<h2 id="4http请求">4.HTTP请求</h2>
<p>一个HTTP请求有着许多的配置参数</p>
<ul>
<li>名称：本属性用于标识一个取样器，建议使用一个有意义的名称。</li>
<li>注释：对于测试没有任何作用，仅用户记录用户可读的注释信息。</li>
<li>服务器名称或IP： HTTP请求发送的目标服务器名称或IP地址。</li>
<li>端口号：目标服务器的端口号，默认值为80 。</li>
<li>协议：向目标服务器发送HTTP请求时的协议，可以是http或者是https ，默认值为http 。</li>
<li>方法：发送HTTP请求的方法，可用方法包括GET、POST、HEAD、PUT、OPTIONS、TRACE、DELETE等。</li>
<li>Content encoding ：内容的编码方式，默认值为ISO</li>
<li>路径：目标URL路径（不包括服务器地址和端口）</li>
<li>自动重定向：如果选中该选项，当发送HTTP请求后得到的响应是302/301时，Jmeter自动重定向到新的页面。</li>
<li>Use keep Alive：当该选项被选中时，Jmeter和目标服务器之间使用Keep-Alive方式进行HTTP通信，默认选中。</li>
<li>Use multipart/from-data for HTTP POST：当发送HTTP POST 请求时，使用Use multipart/from-data方法发送，默认不选中。</li>
</ul>
<h2 id="5监听器">5.监听器</h2>
<p>Jmeter中使用监听器元件收集取样器记录的数据并以可视化的方式来呈现。Jmeter有各种不同的监听器类型。</p>
<p>添加聚合报告，右键点击线程组，在弹的菜单（添加&mdash;&gt;监听器&mdash;&gt;聚合报告）中选择聚合报告。</p>
<ul>
<li>Label：请求的名称</li>
<li>Samples：总共发给服务器的请求数量</li>
<li>Average：单个请求的平均响应时间，单位是毫秒</li>
<li>Median： 50%的请求的响应时间小于</li>
<li>90%Line： 90%的请求的响应时间小于</li>
<li>95%Line： 95%的请求的响应时间小于</li>
<li>99%Line： 99%的请求的响应时间小于</li>
<li>Min： 最小的响应时间</li>
<li>Max： 最大的响应时间</li>
<li>Error%： 错误率=错误的请求的数量/请求的总数</li>
<li>Throughput： 吞吐量即表示每秒完成的请求数</li>
<li>Received KB/sec： 每秒从服务器端接收到的数据量</li>
<li>Sent KB/Sec： 每秒从发送到服务器端的数据量</li>
</ul>
<h2 id="6断言">6.断言</h2>
<p>如何判断Jmeter参数化的用户有没真正的登录成功？或者有没有返回登录成功的页面？这就需要用到断言</p>
<p>右键点击“HTTP请求”&mdash;-&gt;添加&mdash;-&gt;断言&mdash;-&gt;响应断言</p>
<ul>
<li>要测试的响应字段： 响应文本、Document(text)、URL样本、响应信息、Response Headers等选项。虽然接口返回的是HTML页面，但对于Jmeter来说返回数据为文本，所以，这里可以勾选“响应文本”。</li>
<li>模式匹配规则： 包括、匹配、 Equals、Substring。这里只需要验证返回数据中是否包含主要的关键字，所以，这里勾选“包括” 。</li>
<li>要测试的模式： 其实就是断言的数据。点击“添加” 按钮，输入要断言的数据。</li>
</ul>
<h2 id="7集合点">7.集合点</h2>
<p>虽然我们的“性能测试”理解为“多用户并发测试”，但真正的并发是不存在的，为了更真实的实现并发的操作，我们可以在需要压力的地方设置集合点。</p>
<p>右键点击 HTTP请求&mdash;-&gt;定时器&mdash;-&gt;Synchronizing Timer</p>
<ul>
<li>Number of Simulated Users to Group by：每次释放的线程数量。如果设置为0，等同于线程组中设置的线程数量。</li>
<li>Timeout in milliseconds： 如果设置为0，Timer将会等待线程数达到了&quot;Number of Simultaneous Users to Group&quot;中设置的值才释放。如果大于0，那么超过Timeout in milliseconds中设置的最大等待时间(毫秒为单位)后还没达到&quot;Number of Simultaneous Users to Group&quot;中设置的值，Timer将不再等待，释放已到达的线程。</li>
</ul>

            <p style="margin-top:1em;"></p>
        </div>
        <footer>
            <p class="post-copyright-license" style="margin-top:1em; margin-bottom:1em">
                <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
                                                            rel="noopener" target="_blank"><i
                    class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。
            </p>
        </footer>
    
    <ul class="actions pagination" style="margin-bottom:5px; float:right">
        <li><a href="#top" class="button large">回到顶部</a></li>
        
          <li><a href="https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net5sqlmap%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/" class="button large previous">上一页</a></li>
        
        
          <li><a href="https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net7%E5%9C%A8linux%E4%B8%AD%E7%9A%84%E6%90%AD%E5%BB%BAjmeter%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" class="button large next">下一页</a></li>
        
    </ul>
</div>


        </div>
<script src="/assets/js/jquery.min.js"></script>
<script src="/assets/js/browser.min.js"></script>
<script src="/assets/js/breakpoints.min.js"></script>
<script src="/assets/js/util.js"></script>
<script src="/assets/js/main.js"></script></body>
</html>
