<!DOCTYPE HTML>

<html><head>
    <title>LM</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
    <link rel="icon" href="/images/Infinite.png" type="image/x-icon">
    <link rel="stylesheet" href="/assets/css/main.css"/>
</head><body class="is-preload" id="top">
        

        <div id="wrapper">
<header id="header">
    <h1><a href="/" style="font-size: 1.2em">LM' s Note</a></h1>
    <nav class="links">
        <ul>
            <li><a href="/posts" style="font-size: 0.9em"><strong>Posts</strong></a></li>
        </ul>
    </nav>
    <nav class="main">
        <ul>
            <li class="search">
                <a class="fa-search" href="#search">Search</a>
                <form id="search" action="/404.html">
                    <input type="text" name="query" placeholder="请输入关键字"/>
                </form>
            </li>
            <li class="menu">
                
                <a href="/posts" class="fa-bars">Post</a>
            </li>
        </ul>
    </nav>
</header>
            
<div id="main">
    <header>
            <div class="title">
                <h2 style="font-size:2em"><a href="javascript:void(0)"></a></h2>
                <p>@LM | 0001-01-01</p>
            </div>
        </header>
        <div class="content">
            <p><a href="https://socket.io/docs/v4/how-it-works/">Introduction | Socket.IO</a></p>
<h1 id="工作原理">工作原理</h1>
<p>Socket.IO 服务器（节点.js）和 Socket.IO 客户端（浏览器、节点.js或其他<a href="https://socket.io/docs/v4/#what-socketio-is">编程语言</a>）之间的双向通道尽可能使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">Web 插座连接</a>建立，并将使用 HTTP 长轮询作为回退。</p>
<p>Socket.IO 代码库分为两个不同的层：</p>
<ul>
<li>低级管道：我们称之为 Engine.IO，发动机内部 Socket.IO</li>
<li>高级别 API： Socket.IO 本身</li>
</ul>
<h2 id="engineiohttpssocketiodocsv4how-it-worksengineio">Engine.IO<a href="https://socket.io/docs/v4/how-it-works/#engineio">#</a></h2>
<p>Engine.IO 负责建立服务器和客户端之间的低级连接。它处理：</p>
<ul>
<li>各种<a href="https://socket.io/docs/v4/how-it-works/#transports">运输</a>和<a href="https://socket.io/docs/v4/how-it-works/#upgrade-mechanism">升级机制</a></li>
<li><a href="https://socket.io/docs/v4/how-it-works/#disconnection-detection">断开检测</a></li>
</ul>
<p>源代码可在此处找到：</p>
<ul>
<li>服务器<a href="https://github.com/socketio/engine.io">：https://github.com/socketio/engine.io</a></li>
<li>客户<a href="https://github.com/socketio/engine.io-client">：https://github.com/socketio/engine.io-client</a></li>
<li>解析器<a href="https://github.com/socketio/engine.io-parser">：https://github.com/socketio/engine.io-parser</a></li>
<li>协议描述： <a href="https://github.com/socketio/engine.io-protocol">https://github.com/socketio/engine.io-protocol</a></li>
</ul>
<h3 id="运输httpssocketiodocsv4how-it-workstransports">运输<a href="https://socket.io/docs/v4/how-it-works/#transports">#</a></h3>
<p>目前有两个已实现的运输：</p>
<ul>
<li><a href="https://socket.io/docs/v4/how-it-works/#http-long-polling">赫特普长波</a></li>
<li><a href="https://socket.io/docs/v4/how-it-works/#websocket">网络套接头</a></li>
</ul>
<h4 id="赫特普长波httpssocketiodocsv4how-it-workshttp-long-polling">赫特普长波<a href="https://socket.io/docs/v4/how-it-works/#http-long-polling">#</a></h4>
<p>HTTP 长投票传输（也简称为&quot;投票&quot;）由连续的 HTTP 请求组成：</p>
<ul>
<li>从服务器接收数据的长期请求<code>GET</code></li>
<li>短运行请求，用于向服务器发送数据<code>POST</code></li>
</ul>
<p>由于运输的性质，连续发射可以串联，并在同一 HTTP 请求范围内发送。</p>
<h4 id="网络套接头httpssocketiodocsv4how-it-workswebsocket">网络套接头<a href="https://socket.io/docs/v4/how-it-works/#websocket">#</a></h4>
<p>Web插座传输由<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">Web 插座连接</a>组成，它提供了服务器和客户端之间的双向和低延迟通信通道。</p>
<p>由于运输的性质，每个发射是发送到自己的Web插座框架（有些发射甚至可能导致两个不同的网络插座帧，更多的信息<a href="https://socket.io/docs/v4/custom-parser/#the-default-parser">在这里</a>）。</p>
<h3 id="握手httpssocketiodocsv4how-it-workshandshake">握手<a href="https://socket.io/docs/v4/how-it-works/#handshake">#</a></h3>
<p>在 Engine.IO 连接的开始，服务器会发送一些信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{  <span style="color:#f92672">&#34;sid&#34;</span>: <span style="color:#e6db74">&#34;FSDjX-WRwSA4zTZMALqx&#34;</span>,  <span style="color:#f92672">&#34;upgrades&#34;</span>: [<span style="color:#e6db74">&#34;websocket&#34;</span>],  <span style="color:#f92672">&#34;pingInterval&#34;</span>: <span style="color:#ae81ff">25000</span>,  <span style="color:#f92672">&#34;pingTimeout&#34;</span>: <span style="color:#ae81ff">20000</span>}
</code></pre></div><p>复制</p>
<ul>
<li>是会话的 ID，它必须包含在所有后续 HTTP 请求中的查询参数中<code>sid``sid</code></li>
<li>该阵列包含由服务器支持的所有&quot;更好&quot;传输的列表<code>upgrades</code></li>
<li>和值用于心跳机制<code>pingInterval``pingTimeout</code></li>
</ul>
<h3 id="升级机制httpssocketiodocsv4how-it-worksupgrade-mechanism">升级机制<a href="https://socket.io/docs/v4/how-it-works/#upgrade-mechanism">#</a></h3>
<p>默认情况下，客户端会与 HTTP 长投票传输建立连接。</p>
<p><strong>但是为什么？</strong></p>
<p>虽然 Web 插座显然是建立双向通信的最佳方式，但经验表明，由于公司代理、个人防火墙、防病毒软件等原因，建立 Web 插座连接并不总是可能的。</p>
<p>从用户的角度来看，不成功的 Web 插座连接可以在至少 10 秒内转换，等待实时应用程序开始交换数据。这<strong>明显地</strong>伤害了用户体验。</p>
<p>综上所及，Engine.IO 首先关注可靠性和用户体验，其次关注边际潜在 UX 改进和提高服务器性能。</p>
<p>要升级，客户端将：</p>
<ul>
<li>确保其传出缓冲器是空的</li>
<li>将当前传输置于仅读模式</li>
<li>尝试与其他运输建立连接</li>
<li>如果成功，关闭第一次运输</li>
</ul>
<p>您可以查看浏览器的网络监视器：</p>
<p><img src="https://socket.io/assets/images/network-monitor-2e47dbe233100aa290595f8687a9fcba.png" alt="成功升级"></p>
<ol>
<li>握手 （包含会话 ID 在此处 - - 在随后的请求中使用）<code>zBjrh...AAAK</code></li>
<li>发送数据（HTTP 长投票）</li>
<li>接收数据（HTTP 长投票）</li>
<li>升级（网络插座）</li>
<li>接收数据（HTTP 长投票，在成功建立 Web 插座连接后关闭）</li>
</ol>
<h3 id="断开检测httpssocketiodocsv4how-it-worksdisconnection-detection">断开检测<a href="https://socket.io/docs/v4/how-it-works/#disconnection-detection">#</a></h3>
<p>Engine.IO 连接被视为关闭时：</p>
<ul>
<li>一个 HTTP 请求（获取或 POST）失败（例如，当服务器关闭时）</li>
<li>网络插座连接已关闭（例如，当用户关闭浏览器中的选项卡时）</li>
<li><code>socket.disconnect()</code>在服务器端或客户端调用</li>
</ul>
<p>还有一个心跳机制，检查服务器和客户端之间的连接是否仍然启动和运行：</p>
<p>在给定间隔（握手中发送的价值），服务器发送 PING 数据包，客户端有几秒钟（值）将 PONG 数据包发回。如果服务器没有收到 PONG 数据包，它将考虑连接已关闭。相反，如果客户端内部未收到 PING 数据包，则会考虑连接已关闭。<code>pingInterval``pingTimeout``pingInterval + pingTimeout</code></p>
<p>断开原因列<a href="https://socket.io/docs/v4/server-socket-instance/#disconnect">在这里</a>（服务器侧）和<a href="https://socket.io/docs/v4/client-socket-instance/#disconnect">此处</a>（客户端）。</p>

            <p style="margin-top:1em;"></p>
        </div>
        <footer>
            <p class="post-copyright-license" style="margin-top:1em; margin-bottom:1em">
                <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
                                                            rel="noopener" target="_blank"><i
                    class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。
            </p>
        </footer>
    
    <ul class="actions pagination" style="margin-bottom:5px; float:right">
        <li><a href="#top" class="button large">回到顶部</a></li>
        
          <li><a href="https://ac-lm.github.io/posts/python/z5/" class="button large previous">上一页</a></li>
        
        
          <li><a href="https://ac-lm.github.io/posts/python/z3/" class="button large next">下一页</a></li>
        
    </ul>
</div>


        </div>
<script src="/assets/js/jquery.min.js"></script>
<script src="/assets/js/browser.min.js"></script>
<script src="/assets/js/breakpoints.min.js"></script>
<script src="/assets/js/util.js"></script>
<script src="/assets/js/main.js"></script></body>
</html>
