<!DOCTYPE HTML>

<html><head>
    <title>LM</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
    <link rel="icon" href="/images/Infinite.png" type="image/x-icon">
    <link rel="stylesheet" href="/assets/css/main.css"/>
</head><body class="is-preload" id="top">
        

        <div id="wrapper">
<header id="header">
    <h1><a href="/" style="font-size: 1.2em">LM' s Note</a></h1>
    <nav class="links">
        <ul>
            <li><a href="/posts" style="font-size: 0.9em"><strong>Posts</strong></a></li>
        </ul>
    </nav>
    <nav class="main">
        <ul>
            <li class="search">
                <a class="fa-search" href="#search">Search</a>
                <form id="search" action="/404.html">
                    <input type="text" name="query" placeholder="请输入关键字"/>
                </form>
            </li>
            
        </ul>
    </nav>
</header>
            
<div id="main">
    <header>
            <div class="title">
                <h2 style="font-size:2em"><a href="javascript:void(0)">Python(36)—文件写入读取</a></h2>
                <p>@LM | 2021-09-18</p>
            </div>
        </header>
        <div class="content">
            <h2 id="1只读模式打开文件">1.只读模式打开文件</h2>
<p>打开一个文件用 <code>open()</code> 方法，<code>open()</code>会返回一个可迭代的文件对象：</p>
<pre tabindex="0"><code>&gt;&gt;&gt; f = open('test.txt', 'r')
</code></pre><p>r 表示是文本文件，rb 是二进制文件，函数默认值就是 r</p>
<p>如果文件不存在，<code>open()</code>函数就会抛出一个 <code>IOError</code> 的错误，并且给出错误码和详细的信息告诉你文件不存在：</p>
<pre tabindex="0"><code>&gt;&gt;&gt; f=open('test.txt', 'r')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
FileNotFoundError: [Errno 2] No such file or directory: 'test.txt'
</code></pre><p>文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的</p>
<pre tabindex="0"><code>&gt;&gt;&gt; f.close()
</code></pre><p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，Python 引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法：</p>
<pre tabindex="0"><code>with open('/path/to/file', 'r') as f:
    print(f.read())
</code></pre><h2 id="2读取文件">2.读取文件</h2>
<p>python 文件对象提供了三个读方法： <code>read()、readline()、readlines()</code>，每种方法可以接受一个变量以限制每次读取的数据量。</p>
<ul>
<li><code>read()</code>会读取整个文件，并将文件内容放到一个字符串变量中。注意，如果文件大于可用内存，则程序可能会报错，因此，为了保险起见，可以通过调用<code>read(size)</code>方法，指定每次最多读取 size 个字节的内容。</li>
<li><code>readlines()</code> 会读取整个文件，像<code>read()</code>一样，但是<code>readlines()</code>会自动将文件内容分析成一个行的列表，该列表可以进行迭代。</li>
<li><code>readline()</code>每次只读取一行，并将结果放入一个字符串变量中。</li>
</ul>
<p>PS：上述三种方法都会把每行末尾的<code>\n</code>也一并读取。</p>
<h2 id="3写入模式打开文件">3.写入模式打开文件</h2>
<p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，需要传入标识符<code>'w'</code>或者<code>'wb'</code>表示写文本文件或写二进制文件：</p>
<pre tabindex="0"><code>&gt;&gt;&gt; f = open('test.txt', 'w') # 若是'wb'就表示写二进制文件
&gt;&gt;&gt; f.write('Hello, world!')
&gt;&gt;&gt; f.close()
</code></pre><p>PS：<code>'w'</code>模式打开文件时，如果路径没有这个文件，程序就会自动创建一个；如果有，那么程序会把原文件的内容清空后再写入新的东西。如果不想清空原来的内容而是直接在后面追加新的内容，需要使用<code>'a'</code>模式。</p>
<p>我们可以反复调用<code>write()</code>来写入文件，但是务必调用<code>f.close()</code>来关闭文件。因为当我们写文件时，系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，等到空闲时再慢慢写入。只有调用<code>close()</code>方法时，系统才保证把没有写入的数据全部写入磁盘。</p>
<h2 id="4写入文件">4.写入文件</h2>
<p>python文件对象提供了两个写方法： <code>write()、writelines()</code>。</p>
<ul>
<li><code>write()</code>方法和<code>read()、readline()</code>方法对应，是将字符串写入到文件中。</li>
<li><code>writelines()</code>方法和<code>readlines()</code>方法对应，也是针对列表的操作。它接收一个字符串列表作为参数，将他们写入到文件中。注意的是，<code>writelines()</code>不会自动加入换行符，因此，需要显式加入。</li>
</ul>
<h2 id="5关于open的mode参数">5.关于<code>open()</code>的mode参数</h2>
<ul>
<li><code>'r'</code>：读</li>
<li><code>'w'</code>：写</li>
<li><code>'a'</code>：追加</li>
<li><code>'r+' == r+w</code>：（可读可写，文件若不存在就报错(IOError)）</li>
<li><code>'w+' == w+r</code>：（可读可写，文件若不存在就创建）</li>
<li><code>'a+' ==a+r</code>：（可追加可写，文件若不存在就创建）</li>
</ul>
<p>PS：如果是二进制文件，只需在后面添加<code>b</code>，<code>'rb'　　'wb'　　'ab'　　'rb+'　　'wb+'　　'ab+'</code></p>

            <p style="margin-top:1em;"></p>
        </div>
        <footer>
            <p class="post-copyright-license" style="margin-top:1em; margin-bottom:1em">
                <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
                                                            rel="noopener" target="_blank"><i
                    class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。
            </p>
        </footer>
    
    <ul class="actions pagination" style="margin-bottom:5px; float:right">
        <li><a href="#top" class="button large">回到顶部</a></li>
        
          <li><a href="https://ac-lm.github.io/posts/python/python35%E4%BD%BF%E7%94%A8-selenium-%E8%87%AA%E5%8A%A8%E5%8C%96-electron/" class="button large previous">上一页</a></li>
        
        
          <li><a href="https://ac-lm.github.io/posts/python/python37#noqa/" class="button large next">下一页</a></li>
        
    </ul>
</div>


        </div>
<script src="/assets/js/jquery.min.js"></script>
<script src="/assets/js/browser.min.js"></script>
<script src="/assets/js/breakpoints.min.js"></script>
<script src="/assets/js/util.js"></script>
<script src="/assets/js/main.js"></script></body>
</html>
