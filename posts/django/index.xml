<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Django on AC-LM &#39;s blog</title>
    <link>https://ac-lm.github.io/posts/django/</link>
    <description>Recent content in Django on AC-LM &#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 21 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ac-lm.github.io/posts/django/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Django(6)——系统命令</title>
      <link>https://ac-lm.github.io/posts/django/django6%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django6%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</guid>
      <description>pip install django django-admin startproject 项目名称 python manage.py runserver python -m django --version python manage.py runserver 8080 python manage.py startapp 应用名称 LANGUAGE_CODE = &amp;#39;zh-hans&amp;#39; TIME_ZONE = &amp;#39;Asia/Shanghai&amp;#39; python manage.py makemigrations 应用名称 #记录改动 python manage.py migrate #创建表 python manage.py createsuperuser </description>
    </item>
    
    <item>
      <title>Django(1)——Models</title>
      <link>https://ac-lm.github.io/posts/django/django1models/</link>
      <pubDate>Thu, 03 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django1models/</guid>
      <description>模型的基本概念 每个模型都是一个 Python 的类，这些类继承自django.db.models.Model。模型类的每个属性都相当于一个数据库的字段。
from django.db import models class Person(models.Model): first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30) 上述代码相当于使用数据库语言创建一个Person表单，有两个字段 first_name 与 last_name
CREATE TABLE myapp_person ( &amp;#34;id&amp;#34; serial NOT NULL PRIMARY KEY, &amp;#34;first_name&amp;#34; varchar(30) NOT NULL, &amp;#34;last_name&amp;#34; varchar(30) NOT NULL ); 使用模型 定义模型后，需要告诉 Django 你将使用这些模型。通过编辑你的设置文件 setting.py，改变 INSTALLED_APPS 设置来添加包含你的 models.py 的模块的名称来实现这一点。
INSTALLED_APPS = [ #... &amp;#39;myapp&amp;#39;, #模块名 #... ] 字段 字段类型 字段选项  max_length：该参数指定用于存储数据的VARCHAR 数据库字段的大小。 null：如果是True，Django会将空置的值存储为 NULL。默认是False。 blank ：如果是True，这个字段是空白的。默认是False。注意，这与null不同的是，null与数据库相关，而blank则是与验证相关的。如果一个字段有 blank=True ，表单验证就允许输入空值。如果一个字段有blank=False ，则需要字段。 choices：2元组的可迭代，例如，列表或元组的元素选择。 default：字段的默认值。 unique：如果是真的，这个字段必须在整个表中是唯一的。 related_nam：使用外键时调用的名字。  自动主键字段 在默认情况下，Django默认提供了主键字段：id = models.</description>
    </item>
    
    <item>
      <title>Django(2)——HTML模板</title>
      <link>https://ac-lm.github.io/posts/django/django2html%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Thu, 03 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django2html%E6%A8%A1%E6%9D%BF/</guid>
      <description>1.遍历字典 在模版中要遍历字典(dict)，一般使用如下代码实现
{% for key,value in param.items %} {{ key }} {{ value }} {% endfor %} </description>
    </item>
    
    <item>
      <title>Django(3)——设置当前时间</title>
      <link>https://ac-lm.github.io/posts/django/django3%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4/</link>
      <pubDate>Thu, 03 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django3%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4/</guid>
      <description>1.时间字段 在model中，有DateTimeField、DateField和TimeField三种类型可以用来创建日期字段，其值分别对应着datetime()、date()、time()三中对象。
2.属性 DateTimeField.auto_now 这个参数的默认值为false，设置为true时，能够在保存该字段时，将其值设置为当前时间，并且每次修改model，都会自动更新。因此这个参数在需要存储“最后修改时间”的场景下，十分方便。需要注意的是，设置该参数为true时，并不简单地意味着字段的默认值为当前时间，而是指字段会被“强制”更新到当前时间，你无法程序中手动为字段赋值；如果使用django再带的admin管理器，那么该字段在admin中是只读的。
DateTimeField.auto_now_add 这个参数的默认值也为False，设置为True时，会在model对象第一次被创建时，将字段的值设置为创建时的时间，以后修改对象时，字段的值不会再更新。该属性通常被用在存储“创建时间”的场景下。与auto_now类似，auto_now_add也具有强制性，一旦被设置为True，就无法在程序中手动为字段赋值，在admin中字段也会成为只读的。
3.如何将创建时间设置为“默认当前”并且可修改 那么问题来了。实际场景中，往往既希望在对象的创建时间默认被设置为当前值，又希望能在日后修改它。怎么实现这种需求呢？
django中所有的model字段都拥有一个default参数，用来给字段设置默认值。可以用default=timezone.now来替换auto_now=True或auto_now_add=True。timezone.now对应着django.utils.timezone.now()，因此需要写成类似下面的形式：
from django.db import models import django.utils.timezone as timezone class Doc(models.Model): add_date = models.DateTimeField(&amp;#39;保存日期&amp;#39;,default = timezone.now) mod_date = models.DateTimeField(&amp;#39;最后修改日期&amp;#39;, auto_now = True) </description>
    </item>
    
    <item>
      <title>Django(4)——cookie处理</title>
      <link>https://ac-lm.github.io/posts/django/django4cookie%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 03 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django4cookie%E5%A4%84%E7%90%86/</guid>
      <description>设置cookie # 编写视图函数，进行设置 from datetime import datetime,timedelta def set_cookie(request): &amp;#34;&amp;#34;&amp;#34;设置cookie&amp;#34;&amp;#34;&amp;#34; response = HttpResponse(&amp;#34;设置cookie&amp;#34;) &amp;#39;&amp;#39;&amp;#39; max_age 设置过期时间，单位是秒 &amp;#39;&amp;#39;&amp;#39; # response.set_cookie(&amp;#39;name&amp;#39;, &amp;#39;tong&amp;#39;, max_age=14 * 24 * 3600) &amp;#39;&amp;#39;&amp;#39; expires 设置过期时间，是从现在的时间开始到那个时间结束 &amp;#39;&amp;#39;&amp;#39; response.set_cookie(&amp;#39;name&amp;#39;, &amp;#39;tong&amp;#39;, expires=datetime.now()+timedelta(days=14)) return response 获取cookie # 视图函数中定义 get_cookie 方法 def get_cookie(request): &amp;#34;&amp;#34;&amp;#34;获取cookie&amp;#34;&amp;#34;&amp;#34; name = request.COOKIES[&amp;#39;name&amp;#39;] return HttpResponse(name) </description>
    </item>
    
    <item>
      <title>Django(5)——接口开发</title>
      <link>https://ac-lm.github.io/posts/django/django5%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/</link>
      <pubDate>Thu, 03 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ac-lm.github.io/posts/django/django5%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/</guid>
      <description>参考链接：Django Web接口开发 @全栈测试开发日记 
 1.在项目文件下urls.py添加接口根路径: #api path(&amp;#39;api/&amp;#39;,include(&amp;#39;django_web.urls&amp;#39;)), # url(r&amp;#39;^api/&amp;#39;,include((&amp;#39;django_web.urls&amp;#39;,&amp;#39;django_web&amp;#39;),namespace=&amp;#39;django_web&amp;#39;)), 2.在app应用django_web下新建urls.py添加具体接口： from django.urls import path from django_web.views import views_api #在django_web下创建urls.py，配置具体接口的二级目录 urlpatterns = [ # guest system interface: # ex : /api/add_event/ path(&amp;#39;add_event/&amp;#39;,views_api.add_event,name=&amp;#39;add_event&amp;#39;), # ex : /api/get_event_list/ path(&amp;#39;get_event_list/&amp;#39;,views_api.get_event_list,name=&amp;#39;get_event_list&amp;#39;), # ex: /api/add_guest/ path(&amp;#39;add_guest/&amp;#39;,views_api.add_guest,name=&amp;#39;add_guest&amp;#39;), # ex: /api/get_guest_list/ path(&amp;#39;get_guest_list/&amp;#39;,views_api.get_guest_list,name=&amp;#39;get_guest_list&amp;#39;), # ex: /api/user_sign/ path(&amp;#39;user_sign/&amp;#39;,views_api.user_sign,name=&amp;#39;user_sign&amp;#39;), ] 3.在创建接口视图函数view_api.py文件，实现具体接口： # -*- coding: utf-8 -*- from django_web.models import Event,Guest from django.http import JsonResponse from django.core.exceptions import ValidationError,ObjectDoesNotExist from django.</description>
    </item>
    
  </channel>
</rss>
